v2.0 raw
# ImageBaseAddress=0x00081400
# entry
# 81400 Instruction { source: "Initialzing flags and internal regs.", opcode: Init, args: [], resolved: None }
0f 
# 81401 Instruction { source: "Initialzing stack register to 0x000ffffc.", opcode: LoadImm32, args: [Register(0x0c), Constant32(0x000ffffc=1048572)], resolved: None }
80 0c fc ff 0f 00 
# 81407 Instruction { source: "PseudoCall(Label24(:main))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8140d Instruction { source: "PseudoCall(Label24(:main))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 17 14 08 00 
# 81413 Instruction { source: "PseudoCall(Label24(:main))", opcode: JmpImm, args: [Label24(:main)], resolved: None }
40 51 14 08 
# 81417 Instruction { source: "PseudoCall(Label24(:main))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8141d Instruction { source: "Halting after return from entry function.", opcode: Halt, args: [Constant32(0x00000000=0)], resolved: None }
ff 00 00 00 00 
# :getchar
# Ret Some(U8)
# Var t0 (t0 Arithmetic(And, Ident("tty"), Number(U8, 128))) U8 Some([16])
# Var t2 (t2 Number(U8, 128)) U8 Some([16])
# Var t3 (t3 Number(U8, 0)) U8 Some([17])
# Var t4 (t4 Arithmetic(And, Ident("tty"), Number(U8, 127))) U8 Some([16])
# Var t6 (t6 Number(U8, 127)) U8 Some([16])
# Var tty (Local tty Number(U8) U8) U8 Some([18])
# 81422 Instruction { source: "tty <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x12), Constant8(0x00=0)], resolved: None }
00 12 00 
# getchar_while_predicate_0
# 81425 Instruction { source: "t2 <- 0n128/0x80u8 ", opcode: LoadImm8, args: [Register(0x10), Constant8(0x80=128)], resolved: None }
00 10 80 
# 81428 Instruction { source: "t0 <- tty BitwiseAnd t2", opcode: And8, args: [Register(0x12), Register(0x10), Register(0x10)], resolved: None }
33 12 10 10 
# 8142c Instruction { source: "t3 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x11), Constant8(0x00=0)], resolved: None }
00 11 00 
# 8142f Instruction { source: "if t0 == t3 then 'getchar_while_body_1' else 'getchar_while_end_2'", opcode: Cmp8, args: [Register(0x10), Register(0x11)], resolved: None }
25 10 11 
# 81432 Instruction { source: "if t0 == t3 then 'getchar_while_body_1' else 'getchar_while_end_2'", opcode: JzImm, args: [Label24(getchar_while_body_1)], resolved: None }
42 3a 14 08 
# 81436 Instruction { source: "if t0 == t3 then 'getchar_while_body_1' else 'getchar_while_end_2'", opcode: JmpImm, args: [Label24(getchar_while_end_2)], resolved: None }
40 40 14 08 
# getchar_while_body_1
# 8143a Instruction { source: "tty <- ttyin", opcode: TtyIn, args: [Register(0x12)], resolved: None }
12 12 
# 8143c Instruction { source: "goto getchar_while_predicate_0", opcode: JmpImm, args: [Label24(getchar_while_predicate_0)], resolved: None }
40 25 14 08 
# getchar_while_end_2
# 81440 Instruction { source: "t6 <- 0n127/0x7fu8 ", opcode: LoadImm8, args: [Register(0x10), Constant8(0x7f=127)], resolved: None }
00 10 7f 
# 81443 Instruction { source: "t4 <- tty BitwiseAnd t6", opcode: And8, args: [Register(0x12), Register(0x10), Register(0x10)], resolved: None }
33 12 10 10 
# 81447 Instruction { source: "return Some(t4)", opcode: Copy8, args: [Register(0x10), Register(0x00)], resolved: None }
16 10 00 
# 8144a Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 8144c Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :main
# Ret Some(U8)
# Var __frame_pointer (__frame_pointer) U32 Some([12, 13, 14, 15])
# Var a (Local a Number(U8) U8) U8 Some([19])
# Var b (Local b Number(U8) U8) U8 Some([20])
# Var ch (Local ch Number(U8) U8) U8 Some([21])
# Var diff (Local diff Number(U8) U8) U8 Some([21])
# Var have_num (Local have_num Number(U8) U8) U8 Some([22])
# Var i (Local i Number(U8) U8) U8 Some([21])
# Var num (Local num Number(U8) U8) U8 Some([23])
# Var product (Local product Number(U8) U8) U8 Some([21])
# Var quotient (Local quotient Number(U8) U8) U8 Some([21])
# Var s (Local s Struct("Stack") FrameOffset(0)) FrameOffset(0) None
# Var stack_count (Local stack_count Number(U8) U8) U8 Some([24])
# Var stack_count_usize (Local stack_count_usize Number(USIZE) U32) U32 Some([28, 29, 30, 31])
# Var stack_needed (Local stack_needed Number(U8) U8) U8 Some([32])
# Var sum (Local sum Number(U8) U8) U8 Some([21])
# Var t0 (t0 Call(Call { function: "stack_init", parameters: [AddressOf(Ident("s"))] })) U8 Some([33])
# Var t10 (t10 Number(U8, 45)) U8 Some([24])
# Var t101 (t101 Number(U8, 115)) U8 Some([32])
# Var t102 (t102 Call(Call { function: "stack_push", parameters: [AddressOf(Ident("s")), Ident("a")] })) U8 Some([33])
# Var t104 (t104 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([36, 37, 38, 39])
# Var t106 (t106 Number(USIZE, 0)) U32 Some([36, 37, 38, 39])
# Var t108 (t108 Call(Call { function: "stack_push", parameters: [AddressOf(Ident("s")), Ident("b")] })) U8 Some([33])
# Var t110 (t110 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([36, 37, 38, 39])
# Var t112 (t112 Number(USIZE, 0)) U32 Some([36, 37, 38, 39])
# Var t115 (t115 Number(U8, 113)) U8 Some([32])
# Var t116 (t116 Number(U8, 0)) U8 Some([33])
# Var t118 (t118 Number(U8, 10)) U8 Some([32])
# Var t12 (t12 Number(U8, 42)) U8 Some([24])
# Var t120 (t120 Number(U8, 0)) U8 Some([21])
# Var t121 (t121 Call(Call { function: "stack_push", parameters: [AddressOf(Ident("s")), Ident("num")] })) U8 Some([33])
# Var t123 (t123 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([36, 37, 38, 39])
# Var t125 (t125 Number(USIZE, 0)) U32 Some([36, 37, 38, 39])
# Var t128 (t128 Number(U8, 32)) U8 Some([32])
# Var t130 (t130 Number(U8, 0)) U8 Some([21])
# Var t131 (t131 Call(Call { function: "stack_push", parameters: [AddressOf(Ident("s")), Ident("num")] })) U8 Some([33])
# Var t133 (t133 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([36, 37, 38, 39])
# Var t135 (t135 Number(USIZE, 0)) U32 Some([36, 37, 38, 39])
# Var t138 (t138 Number(U8, 99)) U8 Some([32])
# Var t139 (t139 Call(Call { function: "stack_init", parameters: [AddressOf(Ident("s"))] })) U8 Some([33])
# Var t14 (t14 Number(U8, 47)) U8 Some([24])
# Var t141 (t141 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([36, 37, 38, 39])
# Var t143 (t143 Number(USIZE, 0)) U32 Some([36, 37, 38, 39])
# Var t145 (t145 Number(U8, 100)) U8 Some([32])
# Var t148 (t148 Call(Call { function: "print_dec", parameters: [Ident("i")] })) U8 Some([33])
# Var t150 (t150 Number(U8, 58)) U8 Some([32])
# Var t151 (t151 Call(Call { function: "print_dec", parameters: [Call(Call { function: "stack_get", parameters: [AddressOf(Ident("s")), Cast { old_type: None, new_type: Number(USIZE), value: Ident("i") }] })] })) U8 Some([33])
# Var t152 (t152 Call(Call { function: "stack_get", parameters: [AddressOf(Ident("s")), Cast { old_type: None, new_type: Number(USIZE), value: Ident("i") }] })) U8 Some([32])
# Var t154 (t154 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([40, 41, 42, 43])
# Var t156 (t156 Number(USIZE, 0)) U32 Some([40, 41, 42, 43])
# Var t157 (t157 Cast { old_type: None, new_type: Number(USIZE), value: Ident("i") }) U32 Some([44, 45, 46, 47])
# Var t159 (t159 Number(U8, 10)) U8 Some([32])
# Var t16 (t16 Number(U8, 115)) U8 Some([24])
# Var t161 (t161 Number(U8, 1)) U8 Some([32])
# Var t163 (t163 Number(U8, 57)) U8 Some([24])
# Var t165 (t165 Number(U8, 48)) U8 Some([24])
# Var t167 (t167 Number(U8, 10)) U8 Some([24])
# Var t169 (t169 Arithmetic(Subtract, Ident("ch"), Number(U8, 48))) U8 Some([21])
# Var t171 (t171 Number(U8, 48)) U8 Some([24])
# Var t18 (t18 Number(U8, 0)) U8 Some([24])
# Var t2 (t2 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([48, 49, 50, 51])
# Var t20 (t20 Number(U8, 0)) U8 Some([24])
# Var t21 (t21 Call(Call { function: "stack_push", parameters: [AddressOf(Ident("s")), Ident("num")] })) U8 Some([33])
# Var t23 (t23 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([52, 53, 54, 55])
# Var t25 (t25 Number(USIZE, 0)) U32 Some([52, 53, 54, 55])
# Var t27 (t27 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 4)) }) U32 Some([28, 29, 30, 31])
# Var t29 (t29 Number(USIZE, 4)) U32 Some([28, 29, 30, 31])
# Var t32 (t32 Number(U8, 69)) U8 Some([21])
# Var t33 (t33 Number(U8, 82)) U8 Some([21])
# Var t34 (t34 Number(U8, 82)) U8 Some([21])
# Var t35 (t35 Number(U8, 10)) U8 Some([21])
# Var t37 (t37 Number(U8, 0)) U8 Some([56])
# Var t39 (t39 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([48, 49, 50, 51])
# Var t4 (t4 Number(USIZE, 0)) U32 Some([48, 49, 50, 51])
# Var t41 (t41 Number(USIZE, 0)) U32 Some([48, 49, 50, 51])
# Var t43 (t43 Number(U8, 1)) U8 Some([56])
# Var t45 (t45 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([60, 61, 62, 63])
# Var t47 (t47 Number(USIZE, 0)) U32 Some([60, 61, 62, 63])
# Var t49 (t49 Number(U8, 43)) U8 Some([32])
# Var t5 (t5 Number(U8, 0)) U8 Some([21])
# Var t52 (t52 Call(Call { function: "print_dec", parameters: [Ident("sum")] })) U8 Some([33])
# Var t54 (t54 Number(U8, 10)) U8 Some([24])
# Var t55 (t55 Call(Call { function: "stack_push", parameters: [AddressOf(Ident("s")), Ident("sum")] })) U8 Some([33])
# Var t57 (t57 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([28, 29, 30, 31])
# Var t59 (t59 Number(USIZE, 0)) U32 Some([28, 29, 30, 31])
# Var t6 (t6 Number(U8, 0)) U8 Some([24])
# Var t62 (t62 Number(U8, 45)) U8 Some([32])
# Var t65 (t65 Call(Call { function: "print_dec", parameters: [Ident("diff")] })) U8 Some([33])
# Var t67 (t67 Number(U8, 10)) U8 Some([24])
# Var t68 (t68 Call(Call { function: "stack_push", parameters: [AddressOf(Ident("s")), Ident("diff")] })) U8 Some([33])
# Var t70 (t70 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([28, 29, 30, 31])
# Var t72 (t72 Number(USIZE, 0)) U32 Some([28, 29, 30, 31])
# Var t75 (t75 Number(U8, 42)) U8 Some([32])
# Var t78 (t78 Call(Call { function: "print_dec", parameters: [Ident("product")] })) U8 Some([33])
# Var t8 (t8 Number(U8, 43)) U8 Some([24])
# Var t80 (t80 Number(U8, 10)) U8 Some([24])
# Var t81 (t81 Call(Call { function: "stack_push", parameters: [AddressOf(Ident("s")), Ident("product")] })) U8 Some([33])
# Var t83 (t83 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([28, 29, 30, 31])
# Var t85 (t85 Number(USIZE, 0)) U32 Some([28, 29, 30, 31])
# Var t88 (t88 Number(U8, 47)) U8 Some([32])
# Var t91 (t91 Call(Call { function: "print_dec", parameters: [Ident("quotient")] })) U8 Some([33])
# Var t93 (t93 Number(U8, 10)) U8 Some([24])
# Var t94 (t94 Call(Call { function: "stack_push", parameters: [AddressOf(Ident("s")), Ident("quotient")] })) U8 Some([33])
# Var t96 (t96 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([28, 29, 30, 31])
# Var t98 (t98 Number(USIZE, 0)) U32 Some([28, 29, 30, 31])
# 81451 Instruction { source: "reserve 104 bytes of stack space for locals", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xffffff98=4294967192)], resolved: None }
a3 0c 98 ff ff ff 
# 81457 Instruction { source: "t4 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x30), Constant32(0x00000000=0)], resolved: None }
80 30 00 00 00 00 
# 8145d Instruction { source: "t2 <- __frame_pointer Add t4", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x30), Register(0x30)], resolved: None }
a0 0c 30 30 
# 81461 Instruction { source: "Arg0[s]=t2 None <= call stack_init(t2,)", opcode: Copy32, args: [Register(0x30), Register(0x00)], resolved: None }
81 30 00 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {108, 109, 110, 111, 112, 113, 114, 115}
# Registers to save: []
# 81464 Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8146a Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 74 14 08 00 
# 81470 Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: JmpImm, args: [Label24(:stack_init)], resolved: None }
40 50 1b 08 
# 81474 Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8147a Instruction { source: "num <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x17), Constant8(0x00=0)], resolved: None }
00 17 00 
# 8147d Instruction { source: "a <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x13), Constant8(0x00=0)], resolved: None }
00 13 00 
# 81480 Instruction { source: "b <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x14), Constant8(0x00=0)], resolved: None }
00 14 00 
# 81483 Instruction { source: "have_num <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x16), Constant8(0x00=0)], resolved: None }
00 16 00 
# main_while_predicate_0
# 81486 Instruction { source: "t5 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x15), Constant8(0x00=0)], resolved: None }
00 15 00 
# 81489 Instruction { source: "t6 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x00=0)], resolved: None }
00 18 00 
# 8148c Instruction { source: "if t5 == t6 then 'main_while_body_1' else 'main_while_end_2'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 8148f Instruction { source: "if t5 == t6 then 'main_while_body_1' else 'main_while_end_2'", opcode: JzImm, args: [Label24(main_while_body_1)], resolved: None }
42 97 14 08 
# 81493 Instruction { source: "if t5 == t6 then 'main_while_body_1' else 'main_while_end_2'", opcode: JmpImm, args: [Label24(main_while_end_2)], resolved: None }
40 94 19 08 
# main_while_body_1
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {16, 17, 18}
# Registers to save: []
# 81497 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8149d Instruction { source: "PseudoCall(Label24(:getchar))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c a7 14 08 00 
# 814a3 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: JmpImm, args: [Label24(:getchar)], resolved: None }
40 22 14 08 
# 814a7 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 814ad Instruction { source: "Some(ch) <= call getchar()", opcode: Copy8, args: [Register(0x00), Register(0x15)], resolved: None }
16 00 15 
# 814b0 Instruction { source: "t8 <- 0n43/0x2bu8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x2b=43)], resolved: None }
00 18 2b 
# 814b3 Instruction { source: "if ch == t8 then 'main_if_true_0_4' else 'main_if_else_0_5'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 814b6 Instruction { source: "if ch == t8 then 'main_if_true_0_4' else 'main_if_else_0_5'", opcode: JzImm, args: [Label24(main_if_true_0_4)], resolved: None }
42 be 14 08 
# 814ba Instruction { source: "if ch == t8 then 'main_if_true_0_4' else 'main_if_else_0_5'", opcode: JmpImm, args: [Label24(main_if_else_0_5)], resolved: None }
40 c5 14 08 
# main_if_true_0_4
# 814be Instruction { source: "stack_needed <- 0n2/0x02u8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x02=2)], resolved: None }
00 20 02 
# 814c1 Instruction { source: "goto main_if_end_3", opcode: JmpImm, args: [Label24(main_if_end_3)], resolved: None }
40 1c 15 08 
# main_if_else_0_5
# 814c5 Instruction { source: "t10 <- 0n45/0x2du8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x2d=45)], resolved: None }
00 18 2d 
# 814c8 Instruction { source: "if ch == t10 then 'main_if_true_1_6' else 'main_if_else_1_7'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 814cb Instruction { source: "if ch == t10 then 'main_if_true_1_6' else 'main_if_else_1_7'", opcode: JzImm, args: [Label24(main_if_true_1_6)], resolved: None }
42 d3 14 08 
# 814cf Instruction { source: "if ch == t10 then 'main_if_true_1_6' else 'main_if_else_1_7'", opcode: JmpImm, args: [Label24(main_if_else_1_7)], resolved: None }
40 da 14 08 
# main_if_true_1_6
# 814d3 Instruction { source: "stack_needed <- 0n2/0x02u8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x02=2)], resolved: None }
00 20 02 
# 814d6 Instruction { source: "goto main_if_end_3", opcode: JmpImm, args: [Label24(main_if_end_3)], resolved: None }
40 1c 15 08 
# main_if_else_1_7
# 814da Instruction { source: "t12 <- 0n42/0x2au8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x2a=42)], resolved: None }
00 18 2a 
# 814dd Instruction { source: "if ch == t12 then 'main_if_true_2_8' else 'main_if_else_2_9'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 814e0 Instruction { source: "if ch == t12 then 'main_if_true_2_8' else 'main_if_else_2_9'", opcode: JzImm, args: [Label24(main_if_true_2_8)], resolved: None }
42 e8 14 08 
# 814e4 Instruction { source: "if ch == t12 then 'main_if_true_2_8' else 'main_if_else_2_9'", opcode: JmpImm, args: [Label24(main_if_else_2_9)], resolved: None }
40 ef 14 08 
# main_if_true_2_8
# 814e8 Instruction { source: "stack_needed <- 0n2/0x02u8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x02=2)], resolved: None }
00 20 02 
# 814eb Instruction { source: "goto main_if_end_3", opcode: JmpImm, args: [Label24(main_if_end_3)], resolved: None }
40 1c 15 08 
# main_if_else_2_9
# 814ef Instruction { source: "t14 <- 0n47/0x2fu8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x2f=47)], resolved: None }
00 18 2f 
# 814f2 Instruction { source: "if ch == t14 then 'main_if_true_3_10' else 'main_if_else_3_11'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 814f5 Instruction { source: "if ch == t14 then 'main_if_true_3_10' else 'main_if_else_3_11'", opcode: JzImm, args: [Label24(main_if_true_3_10)], resolved: None }
42 fd 14 08 
# 814f9 Instruction { source: "if ch == t14 then 'main_if_true_3_10' else 'main_if_else_3_11'", opcode: JmpImm, args: [Label24(main_if_else_3_11)], resolved: None }
40 04 15 08 
# main_if_true_3_10
# 814fd Instruction { source: "stack_needed <- 0n2/0x02u8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x02=2)], resolved: None }
00 20 02 
# 81500 Instruction { source: "goto main_if_end_3", opcode: JmpImm, args: [Label24(main_if_end_3)], resolved: None }
40 1c 15 08 
# main_if_else_3_11
# 81504 Instruction { source: "t16 <- 0n115/0x73u8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x73=115)], resolved: None }
00 18 73 
# 81507 Instruction { source: "if ch == t16 then 'main_if_true_4_12' else 'main_if_else_4_13'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 8150a Instruction { source: "if ch == t16 then 'main_if_true_4_12' else 'main_if_else_4_13'", opcode: JzImm, args: [Label24(main_if_true_4_12)], resolved: None }
42 12 15 08 
# 8150e Instruction { source: "if ch == t16 then 'main_if_true_4_12' else 'main_if_else_4_13'", opcode: JmpImm, args: [Label24(main_if_else_4_13)], resolved: None }
40 19 15 08 
# main_if_true_4_12
# 81512 Instruction { source: "stack_needed <- 0n2/0x02u8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x02=2)], resolved: None }
00 20 02 
# 81515 Instruction { source: "goto main_if_end_3", opcode: JmpImm, args: [Label24(main_if_end_3)], resolved: None }
40 1c 15 08 
# main_if_else_4_13
# 81519 Instruction { source: "stack_needed <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x00=0)], resolved: None }
00 20 00 
# main_if_end_3
# 8151c Instruction { source: "t18 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x00=0)], resolved: None }
00 18 00 
# 8151f Instruction { source: "if stack_needed > t18 then 'main_if_true_0_15' else 'main_if_else_0_16'", opcode: Cmp8, args: [Register(0x20), Register(0x18)], resolved: None }
25 20 18 
# 81522 Instruction { source: "if stack_needed > t18 then 'main_if_true_0_15' else 'main_if_else_0_16'", opcode: JcImm, args: [Label24(main_if_else_0_16)], resolved: None }
41 64 15 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if stack_needed > t18 then 'main_if_true_0_15' else 'main_if_else_0_16'", opcode: JmpImm, args: [Label24(main_if_true_0_15)], resolved: None }
# main_if_true_0_15
# 81526 Instruction { source: "t20 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x00=0)], resolved: None }
00 18 00 
# 81529 Instruction { source: "if have_num != t20 then 'main_if_true_0_18' else 'main_if_else_0_19'", opcode: Cmp8, args: [Register(0x16), Register(0x18)], resolved: None }
25 16 18 
# 8152c Instruction { source: "if have_num != t20 then 'main_if_true_0_18' else 'main_if_else_0_19'", opcode: JzImm, args: [Label24(main_if_else_0_19)], resolved: None }
42 60 15 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if have_num != t20 then 'main_if_true_0_18' else 'main_if_else_0_19'", opcode: JmpImm, args: [Label24(main_if_true_0_18)], resolved: None }
# main_if_true_0_18
# 81530 Instruction { source: "t25 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x34), Constant32(0x00000000=0)], resolved: None }
80 34 00 00 00 00 
# 81536 Instruction { source: "t23 <- __frame_pointer Add t25", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x34), Register(0x34)], resolved: None }
a0 0c 34 34 
# 8153a Instruction { source: "Arg0[s]=t23 None <= call stack_push(t23,num,)", opcode: Copy32, args: [Register(0x34), Register(0x00)], resolved: None }
81 34 00 
# 8153d Instruction { source: "Arg1[n]=num None <= call stack_push(t23,num,)", opcode: Copy8, args: [Register(0x17), Register(0x04)], resolved: None }
16 17 04 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {136, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151}
# Registers to save: []
# 81540 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81546 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 50 15 08 00 
# 8154c Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 c5 1b 08 
# 81550 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81556 Instruction { source: "num <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x17), Constant8(0x00=0)], resolved: None }
00 17 00 
# 81559 Instruction { source: "have_num <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x16), Constant8(0x00=0)], resolved: None }
00 16 00 
# 8155c Instruction { source: "goto main_if_end_17", opcode: JmpImm, args: [Label24(main_if_end_17)], resolved: None }
40 60 15 08 
# main_if_else_0_19
# main_if_end_17
# 81560 Instruction { source: "goto main_if_end_14", opcode: JmpImm, args: [Label24(main_if_end_14)], resolved: None }
40 64 15 08 
# main_if_else_0_16
# main_if_end_14
# 81564 Instruction { source: "t29 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x1c), Constant32(0x00000004=4)], resolved: None }
80 1c 04 00 00 00 
# 8156a Instruction { source: "t27 <- __frame_pointer Add t29", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x1c), Register(0x1c)], resolved: None }
a0 0c 1c 1c 
# 8156e Instruction { source: "stack_count_usize <- mem[t27] U32", opcode: Load32, args: [Register(0x1c), Register(0x1c)], resolved: None }
90 1c 1c 
# 81571 Instruction { source: "stack_count <- stack_count_usize[0x00..0x01] U8", opcode: Copy8, args: [Register(0x1c), Register(0x18)], resolved: None }
16 1c 18 
# 81574 Instruction { source: "if stack_needed > stack_count then 'main_if_true_0_21' else 'main_if_else_0_22'", opcode: Cmp8, args: [Register(0x20), Register(0x18)], resolved: None }
25 20 18 
# 81577 Instruction { source: "if stack_needed > stack_count then 'main_if_true_0_21' else 'main_if_else_0_22'", opcode: JcImm, args: [Label24(main_if_else_0_22)], resolved: None }
41 97 15 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if stack_needed > stack_count then 'main_if_true_0_21' else 'main_if_else_0_22'", opcode: JmpImm, args: [Label24(main_if_true_0_21)], resolved: None }
# main_if_true_0_21
# 8157b Instruction { source: "t32 <- 0n69/0x45u8 ", opcode: LoadImm8, args: [Register(0x15), Constant8(0x45=69)], resolved: None }
00 15 45 
# 8157e Instruction { source: "ttyout <- t32", opcode: TtyOut, args: [Register(0x15)], resolved: None }
13 15 
# 81580 Instruction { source: "t33 <- 0n82/0x52u8 ", opcode: LoadImm8, args: [Register(0x15), Constant8(0x52=82)], resolved: None }
00 15 52 
# 81583 Instruction { source: "ttyout <- t33", opcode: TtyOut, args: [Register(0x15)], resolved: None }
13 15 
# 81585 Instruction { source: "t34 <- 0n82/0x52u8 ", opcode: LoadImm8, args: [Register(0x15), Constant8(0x52=82)], resolved: None }
00 15 52 
# 81588 Instruction { source: "ttyout <- t34", opcode: TtyOut, args: [Register(0x15)], resolved: None }
13 15 
# 8158a Instruction { source: "t35 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x15), Constant8(0x0a=10)], resolved: None }
00 15 0a 
# 8158d Instruction { source: "ttyout <- t35", opcode: TtyOut, args: [Register(0x15)], resolved: None }
13 15 
# 8158f Instruction { source: "goto main_while_predicate_0", opcode: JmpImm, args: [Label24(main_while_predicate_0)], resolved: None }
40 86 14 08 
# 81593 Instruction { source: "goto main_if_end_20", opcode: JmpImm, args: [Label24(main_if_end_20)], resolved: None }
40 97 15 08 
# main_if_else_0_22
# main_if_end_20
# 81597 Instruction { source: "t37 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x38), Constant8(0x00=0)], resolved: None }
00 38 00 
# 8159a Instruction { source: "if stack_needed > t37 then 'main_if_true_0_24' else 'main_if_else_0_25'", opcode: Cmp8, args: [Register(0x20), Register(0x38)], resolved: None }
25 20 38 
# 8159d Instruction { source: "if stack_needed > t37 then 'main_if_true_0_24' else 'main_if_else_0_25'", opcode: JcImm, args: [Label24(main_if_else_0_25)], resolved: None }
41 cb 15 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if stack_needed > t37 then 'main_if_true_0_24' else 'main_if_else_0_25'", opcode: JmpImm, args: [Label24(main_if_true_0_24)], resolved: None }
# main_if_true_0_24
# 815a1 Instruction { source: "t41 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x30), Constant32(0x00000000=0)], resolved: None }
80 30 00 00 00 00 
# 815a7 Instruction { source: "t39 <- __frame_pointer Add t41", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x30), Register(0x30)], resolved: None }
a0 0c 30 30 
# 815ab Instruction { source: "Arg0[s]=t39 Some(a) <= call stack_pop(t39,)", opcode: Copy32, args: [Register(0x30), Register(0x00)], resolved: None }
81 30 00 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {116, 117, 118, 119, 120, 121, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135}
# Registers to save: []
# 815ae Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 815b4 Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c be 15 08 00 
# 815ba Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: JmpImm, args: [Label24(:stack_pop)], resolved: None }
40 6e 1b 08 
# 815be Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 815c4 Instruction { source: "Some(a) <= call stack_pop(t39,)", opcode: Copy8, args: [Register(0x00), Register(0x13)], resolved: None }
16 00 13 
# 815c7 Instruction { source: "goto main_if_end_23", opcode: JmpImm, args: [Label24(main_if_end_23)], resolved: None }
40 cb 15 08 
# main_if_else_0_25
# main_if_end_23
# 815cb Instruction { source: "t43 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x38), Constant8(0x01=1)], resolved: None }
00 38 01 
# 815ce Instruction { source: "if stack_needed > t43 then 'main_if_true_0_27' else 'main_if_else_0_28'", opcode: Cmp8, args: [Register(0x20), Register(0x38)], resolved: None }
25 20 38 
# 815d1 Instruction { source: "if stack_needed > t43 then 'main_if_true_0_27' else 'main_if_else_0_28'", opcode: JcImm, args: [Label24(main_if_else_0_28)], resolved: None }
41 ff 15 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if stack_needed > t43 then 'main_if_true_0_27' else 'main_if_else_0_28'", opcode: JmpImm, args: [Label24(main_if_true_0_27)], resolved: None }
# main_if_true_0_27
# 815d5 Instruction { source: "t47 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x3c), Constant32(0x00000000=0)], resolved: None }
80 3c 00 00 00 00 
# 815db Instruction { source: "t45 <- __frame_pointer Add t47", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x3c), Register(0x3c)], resolved: None }
a0 0c 3c 3c 
# 815df Instruction { source: "Arg0[s]=t45 Some(b) <= call stack_pop(t45,)", opcode: Copy32, args: [Register(0x3c), Register(0x00)], resolved: None }
81 3c 00 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {116, 117, 118, 119, 120, 121, 122, 123, 124, 128, 129, 130, 131, 132, 133, 134, 135}
# Registers to save: []
# 815e2 Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 815e8 Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c f2 15 08 00 
# 815ee Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: JmpImm, args: [Label24(:stack_pop)], resolved: None }
40 6e 1b 08 
# 815f2 Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 815f8 Instruction { source: "Some(b) <= call stack_pop(t45,)", opcode: Copy8, args: [Register(0x00), Register(0x14)], resolved: None }
16 00 14 
# 815fb Instruction { source: "goto main_if_end_26", opcode: JmpImm, args: [Label24(main_if_end_26)], resolved: None }
40 ff 15 08 
# main_if_else_0_28
# main_if_end_26
# 815ff Instruction { source: "t49 <- 0n43/0x2bu8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x2b=43)], resolved: None }
00 20 2b 
# 81602 Instruction { source: "if ch == t49 then 'main_if_true_0_30' else 'main_if_else_0_31'", opcode: Cmp8, args: [Register(0x15), Register(0x20)], resolved: None }
25 15 20 
# 81605 Instruction { source: "if ch == t49 then 'main_if_true_0_30' else 'main_if_else_0_31'", opcode: JzImm, args: [Label24(main_if_true_0_30)], resolved: None }
42 0d 16 08 
# 81609 Instruction { source: "if ch == t49 then 'main_if_true_0_30' else 'main_if_else_0_31'", opcode: JmpImm, args: [Label24(main_if_else_0_31)], resolved: None }
40 59 16 08 
# main_if_true_0_30
# 8160d Instruction { source: "sum <- b Add a", opcode: Add8NoCarryIn, args: [Register(0x14), Register(0x13), Register(0x15)], resolved: None }
24 14 13 15 
# 81611 Instruction { source: "Arg0[a]=sum None <= call print_dec(sum,)", opcode: Copy8, args: [Register(0x15), Register(0x00)], resolved: None }
16 15 00 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {64, 65, 66}
# Registers to save: []
# 81614 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8161a Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 24 16 08 00 
# 81620 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: JmpImm, args: [Label24(:print_dec)], resolved: None }
40 99 19 08 
# 81624 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8162a Instruction { source: "t54 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x0a=10)], resolved: None }
00 18 0a 
# 8162d Instruction { source: "ttyout <- t54", opcode: TtyOut, args: [Register(0x18)], resolved: None }
13 18 
# 8162f Instruction { source: "t59 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x1c), Constant32(0x00000000=0)], resolved: None }
80 1c 00 00 00 00 
# 81635 Instruction { source: "t57 <- __frame_pointer Add t59", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x1c), Register(0x1c)], resolved: None }
a0 0c 1c 1c 
# 81639 Instruction { source: "Arg0[s]=t57 None <= call stack_push(t57,sum,)", opcode: Copy32, args: [Register(0x1c), Register(0x00)], resolved: None }
81 1c 00 
# 8163c Instruction { source: "Arg1[n]=sum None <= call stack_push(t57,sum,)", opcode: Copy8, args: [Register(0x15), Register(0x04)], resolved: None }
16 15 04 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {136, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151}
# Registers to save: []
# 8163f Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81645 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 4f 16 08 00 
# 8164b Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 c5 1b 08 
# 8164f Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81655 Instruction { source: "goto main_if_end_29", opcode: JmpImm, args: [Label24(main_if_end_29)], resolved: None }
40 90 19 08 
# main_if_else_0_31
# 81659 Instruction { source: "t62 <- 0n45/0x2du8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x2d=45)], resolved: None }
00 20 2d 
# 8165c Instruction { source: "if ch == t62 then 'main_if_true_1_32' else 'main_if_else_1_33'", opcode: Cmp8, args: [Register(0x15), Register(0x20)], resolved: None }
25 15 20 
# 8165f Instruction { source: "if ch == t62 then 'main_if_true_1_32' else 'main_if_else_1_33'", opcode: JzImm, args: [Label24(main_if_true_1_32)], resolved: None }
42 67 16 08 
# 81663 Instruction { source: "if ch == t62 then 'main_if_true_1_32' else 'main_if_else_1_33'", opcode: JmpImm, args: [Label24(main_if_else_1_33)], resolved: None }
40 b8 16 08 
# main_if_true_1_32
# 81667 Instruction { source: "diff <- b Subtract a", opcode: Copy8, args: [Register(0x13), Register(0x00)], resolved: None }
16 13 00 
# 8166a Instruction { source: "diff <- b Subtract a", opcode: Negate8, args: [Register(0x00)], resolved: None }
04 00 
# 8166c Instruction { source: "diff <- b Subtract a", opcode: Add8NoCarryIn, args: [Register(0x14), Register(0x00), Register(0x15)], resolved: None }
24 14 00 15 
# 81670 Instruction { source: "Arg0[a]=diff None <= call print_dec(diff,)", opcode: Copy8, args: [Register(0x15), Register(0x00)], resolved: None }
16 15 00 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {64, 65, 66}
# Registers to save: []
# 81673 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81679 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 83 16 08 00 
# 8167f Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: JmpImm, args: [Label24(:print_dec)], resolved: None }
40 99 19 08 
# 81683 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81689 Instruction { source: "t67 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x0a=10)], resolved: None }
00 18 0a 
# 8168c Instruction { source: "ttyout <- t67", opcode: TtyOut, args: [Register(0x18)], resolved: None }
13 18 
# 8168e Instruction { source: "t72 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x1c), Constant32(0x00000000=0)], resolved: None }
80 1c 00 00 00 00 
# 81694 Instruction { source: "t70 <- __frame_pointer Add t72", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x1c), Register(0x1c)], resolved: None }
a0 0c 1c 1c 
# 81698 Instruction { source: "Arg0[s]=t70 None <= call stack_push(t70,diff,)", opcode: Copy32, args: [Register(0x1c), Register(0x00)], resolved: None }
81 1c 00 
# 8169b Instruction { source: "Arg1[n]=diff None <= call stack_push(t70,diff,)", opcode: Copy8, args: [Register(0x15), Register(0x04)], resolved: None }
16 15 04 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {136, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151}
# Registers to save: []
# 8169e Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 816a4 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c ae 16 08 00 
# 816aa Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 c5 1b 08 
# 816ae Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 816b4 Instruction { source: "goto main_if_end_29", opcode: JmpImm, args: [Label24(main_if_end_29)], resolved: None }
40 90 19 08 
# main_if_else_1_33
# 816b8 Instruction { source: "t75 <- 0n42/0x2au8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x2a=42)], resolved: None }
00 20 2a 
# 816bb Instruction { source: "if ch == t75 then 'main_if_true_2_34' else 'main_if_else_2_35'", opcode: Cmp8, args: [Register(0x15), Register(0x20)], resolved: None }
25 15 20 
# 816be Instruction { source: "if ch == t75 then 'main_if_true_2_34' else 'main_if_else_2_35'", opcode: JzImm, args: [Label24(main_if_true_2_34)], resolved: None }
42 c6 16 08 
# 816c2 Instruction { source: "if ch == t75 then 'main_if_true_2_34' else 'main_if_else_2_35'", opcode: JmpImm, args: [Label24(main_if_else_2_35)], resolved: None }
40 15 17 08 
# main_if_true_2_34
# 816c6 Instruction { source: "product <- b Multiply a", opcode: Mul8_1, args: [Register(0x14), Register(0x13)], resolved: None }
20 14 13 
# 816c9 Instruction { source: "product <- b Multiply a", opcode: Mul8_2, args: [], resolved: None }
21 
# 816ca Instruction { source: "product <- b Multiply a", opcode: Copy8, args: [Register(0x00), Register(0x15)], resolved: None }
16 00 15 
# 816cd Instruction { source: "Arg0[a]=product None <= call print_dec(product,)", opcode: Copy8, args: [Register(0x15), Register(0x00)], resolved: None }
16 15 00 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {64, 65, 66}
# Registers to save: []
# 816d0 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 816d6 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c e0 16 08 00 
# 816dc Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: JmpImm, args: [Label24(:print_dec)], resolved: None }
40 99 19 08 
# 816e0 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 816e6 Instruction { source: "t80 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x0a=10)], resolved: None }
00 18 0a 
# 816e9 Instruction { source: "ttyout <- t80", opcode: TtyOut, args: [Register(0x18)], resolved: None }
13 18 
# 816eb Instruction { source: "t85 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x1c), Constant32(0x00000000=0)], resolved: None }
80 1c 00 00 00 00 
# 816f1 Instruction { source: "t83 <- __frame_pointer Add t85", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x1c), Register(0x1c)], resolved: None }
a0 0c 1c 1c 
# 816f5 Instruction { source: "Arg0[s]=t83 None <= call stack_push(t83,product,)", opcode: Copy32, args: [Register(0x1c), Register(0x00)], resolved: None }
81 1c 00 
# 816f8 Instruction { source: "Arg1[n]=product None <= call stack_push(t83,product,)", opcode: Copy8, args: [Register(0x15), Register(0x04)], resolved: None }
16 15 04 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {136, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151}
# Registers to save: []
# 816fb Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81701 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 0b 17 08 00 
# 81707 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 c5 1b 08 
# 8170b Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81711 Instruction { source: "goto main_if_end_29", opcode: JmpImm, args: [Label24(main_if_end_29)], resolved: None }
40 90 19 08 
# main_if_else_2_35
# 81715 Instruction { source: "t88 <- 0n47/0x2fu8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x2f=47)], resolved: None }
00 20 2f 
# 81718 Instruction { source: "if ch == t88 then 'main_if_true_3_36' else 'main_if_else_3_37'", opcode: Cmp8, args: [Register(0x15), Register(0x20)], resolved: None }
25 15 20 
# 8171b Instruction { source: "if ch == t88 then 'main_if_true_3_36' else 'main_if_else_3_37'", opcode: JzImm, args: [Label24(main_if_true_3_36)], resolved: None }
42 23 17 08 
# 8171f Instruction { source: "if ch == t88 then 'main_if_true_3_36' else 'main_if_else_3_37'", opcode: JmpImm, args: [Label24(main_if_else_3_37)], resolved: None }
40 6f 17 08 
# main_if_true_3_36
# 81723 Instruction { source: "quotient <- b Divide a", opcode: Divide8, args: [Register(0x14), Register(0x13), Register(0x15)], resolved: None }
27 14 13 15 
# 81727 Instruction { source: "Arg0[a]=quotient None <= call print_dec(quotient,)", opcode: Copy8, args: [Register(0x15), Register(0x00)], resolved: None }
16 15 00 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {64, 65, 66}
# Registers to save: []
# 8172a Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81730 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 3a 17 08 00 
# 81736 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: JmpImm, args: [Label24(:print_dec)], resolved: None }
40 99 19 08 
# 8173a Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81740 Instruction { source: "t93 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x0a=10)], resolved: None }
00 18 0a 
# 81743 Instruction { source: "ttyout <- t93", opcode: TtyOut, args: [Register(0x18)], resolved: None }
13 18 
# 81745 Instruction { source: "t98 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x1c), Constant32(0x00000000=0)], resolved: None }
80 1c 00 00 00 00 
# 8174b Instruction { source: "t96 <- __frame_pointer Add t98", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x1c), Register(0x1c)], resolved: None }
a0 0c 1c 1c 
# 8174f Instruction { source: "Arg0[s]=t96 None <= call stack_push(t96,quotient,)", opcode: Copy32, args: [Register(0x1c), Register(0x00)], resolved: None }
81 1c 00 
# 81752 Instruction { source: "Arg1[n]=quotient None <= call stack_push(t96,quotient,)", opcode: Copy8, args: [Register(0x15), Register(0x04)], resolved: None }
16 15 04 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {136, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151}
# Registers to save: []
# 81755 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8175b Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 65 17 08 00 
# 81761 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 c5 1b 08 
# 81765 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8176b Instruction { source: "goto main_if_end_29", opcode: JmpImm, args: [Label24(main_if_end_29)], resolved: None }
40 90 19 08 
# main_if_else_3_37
# 8176f Instruction { source: "t101 <- 0n115/0x73u8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x73=115)], resolved: None }
00 20 73 
# 81772 Instruction { source: "if ch == t101 then 'main_if_true_4_38' else 'main_if_else_4_39'", opcode: Cmp8, args: [Register(0x15), Register(0x20)], resolved: None }
25 15 20 
# 81775 Instruction { source: "if ch == t101 then 'main_if_true_4_38' else 'main_if_else_4_39'", opcode: JzImm, args: [Label24(main_if_true_4_38)], resolved: None }
42 7d 17 08 
# 81779 Instruction { source: "if ch == t101 then 'main_if_true_4_38' else 'main_if_else_4_39'", opcode: JmpImm, args: [Label24(main_if_else_4_39)], resolved: None }
40 cd 17 08 
# main_if_true_4_38
# 8177d Instruction { source: "t106 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x24), Constant32(0x00000000=0)], resolved: None }
80 24 00 00 00 00 
# 81783 Instruction { source: "t104 <- __frame_pointer Add t106", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x24), Register(0x24)], resolved: None }
a0 0c 24 24 
# 81787 Instruction { source: "Arg0[s]=t104 None <= call stack_push(t104,a,)", opcode: Copy32, args: [Register(0x24), Register(0x00)], resolved: None }
81 24 00 
# 8178a Instruction { source: "Arg1[n]=a None <= call stack_push(t104,a,)", opcode: Copy8, args: [Register(0x13), Register(0x04)], resolved: None }
16 13 04 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {136, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151}
# Registers to save: []
# 8178d Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81793 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 9d 17 08 00 
# 81799 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 c5 1b 08 
# 8179d Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 817a3 Instruction { source: "t112 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x24), Constant32(0x00000000=0)], resolved: None }
80 24 00 00 00 00 
# 817a9 Instruction { source: "t110 <- __frame_pointer Add t112", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x24), Register(0x24)], resolved: None }
a0 0c 24 24 
# 817ad Instruction { source: "Arg0[s]=t110 None <= call stack_push(t110,b,)", opcode: Copy32, args: [Register(0x24), Register(0x00)], resolved: None }
81 24 00 
# 817b0 Instruction { source: "Arg1[n]=b None <= call stack_push(t110,b,)", opcode: Copy8, args: [Register(0x14), Register(0x04)], resolved: None }
16 14 04 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {136, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151}
# Registers to save: []
# 817b3 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 817b9 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c c3 17 08 00 
# 817bf Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 c5 1b 08 
# 817c3 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 817c9 Instruction { source: "goto main_if_end_29", opcode: JmpImm, args: [Label24(main_if_end_29)], resolved: None }
40 90 19 08 
# main_if_else_4_39
# 817cd Instruction { source: "t115 <- 0n113/0x71u8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x71=113)], resolved: None }
00 20 71 
# 817d0 Instruction { source: "if ch == t115 then 'main_if_true_5_40' else 'main_if_else_5_41'", opcode: Cmp8, args: [Register(0x15), Register(0x20)], resolved: None }
25 15 20 
# 817d3 Instruction { source: "if ch == t115 then 'main_if_true_5_40' else 'main_if_else_5_41'", opcode: JzImm, args: [Label24(main_if_true_5_40)], resolved: None }
42 db 17 08 
# 817d7 Instruction { source: "if ch == t115 then 'main_if_true_5_40' else 'main_if_else_5_41'", opcode: JmpImm, args: [Label24(main_if_else_5_41)], resolved: None }
40 ed 17 08 
# main_if_true_5_40
# 817db Instruction { source: "t116 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x21), Constant8(0x00=0)], resolved: None }
00 21 00 
# 817de Instruction { source: "return Some(t116)", opcode: Copy8, args: [Register(0x21), Register(0x00)], resolved: None }
16 21 00 
# 817e1 Instruction { source: "Dealloc 104 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000068=104)], resolved: None }
a3 0c 68 00 00 00 
# 817e7 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 817e9 Instruction { source: "goto main_if_end_29", opcode: JmpImm, args: [Label24(main_if_end_29)], resolved: None }
40 90 19 08 
# main_if_else_5_41
# 817ed Instruction { source: "t118 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x0a=10)], resolved: None }
00 20 0a 
# 817f0 Instruction { source: "if ch == t118 then 'main_if_true_6_42' else 'main_if_else_6_43'", opcode: Cmp8, args: [Register(0x15), Register(0x20)], resolved: None }
25 15 20 
# 817f3 Instruction { source: "if ch == t118 then 'main_if_true_6_42' else 'main_if_else_6_43'", opcode: JzImm, args: [Label24(main_if_true_6_42)], resolved: None }
42 fb 17 08 
# 817f7 Instruction { source: "if ch == t118 then 'main_if_true_6_42' else 'main_if_else_6_43'", opcode: JmpImm, args: [Label24(main_if_else_6_43)], resolved: None }
40 39 18 08 
# main_if_true_6_42
# 817fb Instruction { source: "t120 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x15), Constant8(0x00=0)], resolved: None }
00 15 00 
# 817fe Instruction { source: "if have_num != t120 then 'main_if_true_0_45' else 'main_if_else_0_46'", opcode: Cmp8, args: [Register(0x16), Register(0x15)], resolved: None }
25 16 15 
# 81801 Instruction { source: "if have_num != t120 then 'main_if_true_0_45' else 'main_if_else_0_46'", opcode: JzImm, args: [Label24(main_if_else_0_46)], resolved: None }
42 35 18 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if have_num != t120 then 'main_if_true_0_45' else 'main_if_else_0_46'", opcode: JmpImm, args: [Label24(main_if_true_0_45)], resolved: None }
# main_if_true_0_45
# 81805 Instruction { source: "t125 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x24), Constant32(0x00000000=0)], resolved: None }
80 24 00 00 00 00 
# 8180b Instruction { source: "t123 <- __frame_pointer Add t125", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x24), Register(0x24)], resolved: None }
a0 0c 24 24 
# 8180f Instruction { source: "Arg0[s]=t123 None <= call stack_push(t123,num,)", opcode: Copy32, args: [Register(0x24), Register(0x00)], resolved: None }
81 24 00 
# 81812 Instruction { source: "Arg1[n]=num None <= call stack_push(t123,num,)", opcode: Copy8, args: [Register(0x17), Register(0x04)], resolved: None }
16 17 04 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {136, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151}
# Registers to save: []
# 81815 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8181b Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 25 18 08 00 
# 81821 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 c5 1b 08 
# 81825 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8182b Instruction { source: "num <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x17), Constant8(0x00=0)], resolved: None }
00 17 00 
# 8182e Instruction { source: "have_num <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x16), Constant8(0x00=0)], resolved: None }
00 16 00 
# 81831 Instruction { source: "goto main_if_end_44", opcode: JmpImm, args: [Label24(main_if_end_44)], resolved: None }
40 35 18 08 
# main_if_else_0_46
# main_if_end_44
# 81835 Instruction { source: "goto main_if_end_29", opcode: JmpImm, args: [Label24(main_if_end_29)], resolved: None }
40 90 19 08 
# main_if_else_6_43
# 81839 Instruction { source: "t128 <- 0n32/0x20u8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x20=32)], resolved: None }
00 20 20 
# 8183c Instruction { source: "if ch == t128 then 'main_if_true_7_47' else 'main_if_else_7_48'", opcode: Cmp8, args: [Register(0x15), Register(0x20)], resolved: None }
25 15 20 
# 8183f Instruction { source: "if ch == t128 then 'main_if_true_7_47' else 'main_if_else_7_48'", opcode: JzImm, args: [Label24(main_if_true_7_47)], resolved: None }
42 47 18 08 
# 81843 Instruction { source: "if ch == t128 then 'main_if_true_7_47' else 'main_if_else_7_48'", opcode: JmpImm, args: [Label24(main_if_else_7_48)], resolved: None }
40 85 18 08 
# main_if_true_7_47
# 81847 Instruction { source: "t130 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x15), Constant8(0x00=0)], resolved: None }
00 15 00 
# 8184a Instruction { source: "if have_num != t130 then 'main_if_true_0_50' else 'main_if_else_0_51'", opcode: Cmp8, args: [Register(0x16), Register(0x15)], resolved: None }
25 16 15 
# 8184d Instruction { source: "if have_num != t130 then 'main_if_true_0_50' else 'main_if_else_0_51'", opcode: JzImm, args: [Label24(main_if_else_0_51)], resolved: None }
42 81 18 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if have_num != t130 then 'main_if_true_0_50' else 'main_if_else_0_51'", opcode: JmpImm, args: [Label24(main_if_true_0_50)], resolved: None }
# main_if_true_0_50
# 81851 Instruction { source: "t135 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x24), Constant32(0x00000000=0)], resolved: None }
80 24 00 00 00 00 
# 81857 Instruction { source: "t133 <- __frame_pointer Add t135", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x24), Register(0x24)], resolved: None }
a0 0c 24 24 
# 8185b Instruction { source: "Arg0[s]=t133 None <= call stack_push(t133,num,)", opcode: Copy32, args: [Register(0x24), Register(0x00)], resolved: None }
81 24 00 
# 8185e Instruction { source: "Arg1[n]=num None <= call stack_push(t133,num,)", opcode: Copy8, args: [Register(0x17), Register(0x04)], resolved: None }
16 17 04 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {136, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151}
# Registers to save: []
# 81861 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81867 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 71 18 08 00 
# 8186d Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 c5 1b 08 
# 81871 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81877 Instruction { source: "num <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x17), Constant8(0x00=0)], resolved: None }
00 17 00 
# 8187a Instruction { source: "have_num <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x16), Constant8(0x00=0)], resolved: None }
00 16 00 
# 8187d Instruction { source: "goto main_if_end_49", opcode: JmpImm, args: [Label24(main_if_end_49)], resolved: None }
40 81 18 08 
# main_if_else_0_51
# main_if_end_49
# 81881 Instruction { source: "goto main_if_end_29", opcode: JmpImm, args: [Label24(main_if_end_29)], resolved: None }
40 90 19 08 
# main_if_else_7_48
# 81885 Instruction { source: "t138 <- 0n99/0x63u8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x63=99)], resolved: None }
00 20 63 
# 81888 Instruction { source: "if ch == t138 then 'main_if_true_8_52' else 'main_if_else_8_53'", opcode: Cmp8, args: [Register(0x15), Register(0x20)], resolved: None }
25 15 20 
# 8188b Instruction { source: "if ch == t138 then 'main_if_true_8_52' else 'main_if_else_8_53'", opcode: JzImm, args: [Label24(main_if_true_8_52)], resolved: None }
42 93 18 08 
# 8188f Instruction { source: "if ch == t138 then 'main_if_true_8_52' else 'main_if_else_8_53'", opcode: JmpImm, args: [Label24(main_if_else_8_53)], resolved: None }
40 ba 18 08 
# main_if_true_8_52
# 81893 Instruction { source: "t143 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x24), Constant32(0x00000000=0)], resolved: None }
80 24 00 00 00 00 
# 81899 Instruction { source: "t141 <- __frame_pointer Add t143", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x24), Register(0x24)], resolved: None }
a0 0c 24 24 
# 8189d Instruction { source: "Arg0[s]=t141 None <= call stack_init(t141,)", opcode: Copy32, args: [Register(0x24), Register(0x00)], resolved: None }
81 24 00 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {108, 109, 110, 111, 112, 113, 114, 115}
# Registers to save: []
# 818a0 Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 818a6 Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c b0 18 08 00 
# 818ac Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: JmpImm, args: [Label24(:stack_init)], resolved: None }
40 50 1b 08 
# 818b0 Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 818b6 Instruction { source: "goto main_if_end_29", opcode: JmpImm, args: [Label24(main_if_end_29)], resolved: None }
40 90 19 08 
# main_if_else_8_53
# 818ba Instruction { source: "t145 <- 0n100/0x64u8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x64=100)], resolved: None }
00 20 64 
# 818bd Instruction { source: "if ch == t145 then 'main_if_true_9_54' else 'main_if_else_9_55'", opcode: Cmp8, args: [Register(0x15), Register(0x20)], resolved: None }
25 15 20 
# 818c0 Instruction { source: "if ch == t145 then 'main_if_true_9_54' else 'main_if_else_9_55'", opcode: JzImm, args: [Label24(main_if_true_9_54)], resolved: None }
42 c8 18 08 
# 818c4 Instruction { source: "if ch == t145 then 'main_if_true_9_54' else 'main_if_else_9_55'", opcode: JmpImm, args: [Label24(main_if_else_9_55)], resolved: None }
40 4f 19 08 
# main_if_true_9_54
# 818c8 Instruction { source: "i <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x15), Constant8(0x00=0)], resolved: None }
00 15 00 
# main_while_predicate_56
# 818cb Instruction { source: "if i < stack_count then 'main_while_body_57' else 'main_while_end_58'", opcode: Cmp8, args: [Register(0x18), Register(0x15)], resolved: None }
25 18 15 
# 818ce Instruction { source: "if i < stack_count then 'main_while_body_57' else 'main_while_end_58'", opcode: JcImm, args: [Label24(main_while_end_58)], resolved: None }
41 4b 19 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if i < stack_count then 'main_while_body_57' else 'main_while_end_58'", opcode: JmpImm, args: [Label24(main_while_body_57)], resolved: None }
# main_while_body_57
# 818d2 Instruction { source: "Arg0[a]=i None <= call print_dec(i,)", opcode: Copy8, args: [Register(0x15), Register(0x00)], resolved: None }
16 15 00 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {64, 65, 66}
# Registers to save: []
# 818d5 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 818db Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c e5 18 08 00 
# 818e1 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: JmpImm, args: [Label24(:print_dec)], resolved: None }
40 99 19 08 
# 818e5 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 818eb Instruction { source: "t150 <- 0n58/0x3au8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x3a=58)], resolved: None }
00 20 3a 
# 818ee Instruction { source: "ttyout <- t150", opcode: TtyOut, args: [Register(0x20)], resolved: None }
13 20 
# 818f0 Instruction { source: "t156 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x28), Constant32(0x00000000=0)], resolved: None }
80 28 00 00 00 00 
# 818f6 Instruction { source: "t154 <- __frame_pointer Add t156", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x28), Register(0x28)], resolved: None }
a0 0c 28 28 
# 818fa Instruction { source: "Zero-pad for t157 U32 <- i U8", opcode: LoadImm32, args: [Register(0x2c), Constant32(0x00000000=0)], resolved: None }
80 2c 00 00 00 00 
# 81900 Instruction { source: "t157 U32 <- i U8", opcode: Copy8, args: [Register(0x15), Register(0x2c)], resolved: None }
16 15 2c 
# 81903 Instruction { source: "Arg0[s]=t154 Some(t152) <= call stack_get(t154,t157,)", opcode: Copy32, args: [Register(0x28), Register(0x00)], resolved: None }
81 28 00 
# 81906 Instruction { source: "Arg1[n]=t157 Some(t152) <= call stack_get(t154,t157,)", opcode: Copy32, args: [Register(0x2c), Register(0x04)], resolved: None }
81 2c 04 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {96, 97, 98, 99, 100, 101, 102, 103, 104}
# Registers to save: []
# 81909 Instruction { source: "PseudoCall(Label24(:stack_get))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8190f Instruction { source: "PseudoCall(Label24(:stack_get))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 19 19 08 00 
# 81915 Instruction { source: "PseudoCall(Label24(:stack_get))", opcode: JmpImm, args: [Label24(:stack_get)], resolved: None }
40 39 1b 08 
# 81919 Instruction { source: "PseudoCall(Label24(:stack_get))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8191f Instruction { source: "Some(t152) <= call stack_get(t154,t157,)", opcode: Copy8, args: [Register(0x00), Register(0x20)], resolved: None }
16 00 20 
# 81922 Instruction { source: "Arg0[a]=t152 None <= call print_dec(t152,)", opcode: Copy8, args: [Register(0x20), Register(0x00)], resolved: None }
16 20 00 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63}
# Registers used by callee tree: {64, 65, 66}
# Registers to save: []
# 81925 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8192b Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 35 19 08 00 
# 81931 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: JmpImm, args: [Label24(:print_dec)], resolved: None }
40 99 19 08 
# 81935 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8193b Instruction { source: "t159 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x0a=10)], resolved: None }
00 20 0a 
# 8193e Instruction { source: "ttyout <- t159", opcode: TtyOut, args: [Register(0x20)], resolved: None }
13 20 
# 81940 Instruction { source: "t161 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x01=1)], resolved: None }
00 20 01 
# 81943 Instruction { source: "i <- i Add t161", opcode: Add8NoCarryIn, args: [Register(0x15), Register(0x20), Register(0x15)], resolved: None }
24 15 20 15 
# 81947 Instruction { source: "goto main_while_predicate_56", opcode: JmpImm, args: [Label24(main_while_predicate_56)], resolved: None }
40 cb 18 08 
# main_while_end_58
# 8194b Instruction { source: "goto main_if_end_29", opcode: JmpImm, args: [Label24(main_if_end_29)], resolved: None }
40 90 19 08 
# main_if_else_9_55
# 8194f Instruction { source: "t163 <- 0n57/0x39u8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x39=57)], resolved: None }
00 18 39 
# 81952 Instruction { source: "if ch <= t163 then 'main_if_true_10_59' else 'main_if_else_10_60'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 81955 Instruction { source: "if ch <= t163 then 'main_if_true_10_59' else 'main_if_else_10_60'", opcode: JcImm, args: [Label24(main_if_true_10_59)], resolved: None }
41 5d 19 08 
# 81959 Instruction { source: "if ch <= t163 then 'main_if_true_10_59' else 'main_if_else_10_60'", opcode: JmpImm, args: [Label24(main_if_else_10_60)], resolved: None }
40 90 19 08 
# main_if_true_10_59
# 8195d Instruction { source: "t165 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x30=48)], resolved: None }
00 18 30 
# 81960 Instruction { source: "if ch >= t165 then 'main_if_true_0_62' else 'main_if_else_0_63'", opcode: Cmp8, args: [Register(0x18), Register(0x15)], resolved: None }
25 18 15 
# 81963 Instruction { source: "if ch >= t165 then 'main_if_true_0_62' else 'main_if_else_0_63'", opcode: JcImm, args: [Label24(main_if_true_0_62)], resolved: None }
41 6b 19 08 
# 81967 Instruction { source: "if ch >= t165 then 'main_if_true_0_62' else 'main_if_else_0_63'", opcode: JmpImm, args: [Label24(main_if_else_0_63)], resolved: None }
40 8c 19 08 
# main_if_true_0_62
# 8196b Instruction { source: "have_num <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x16), Constant8(0x01=1)], resolved: None }
00 16 01 
# 8196e Instruction { source: "t167 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x0a=10)], resolved: None }
00 18 0a 
# 81971 Instruction { source: "num <- num Multiply t167", opcode: Mul8_1, args: [Register(0x17), Register(0x18)], resolved: None }
20 17 18 
# 81974 Instruction { source: "num <- num Multiply t167", opcode: Mul8_2, args: [], resolved: None }
21 
# 81975 Instruction { source: "num <- num Multiply t167", opcode: Copy8, args: [Register(0x00), Register(0x17)], resolved: None }
16 00 17 
# 81978 Instruction { source: "t171 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x30=48)], resolved: None }
00 18 30 
# 8197b Instruction { source: "t169 <- ch Subtract t171", opcode: Copy8, args: [Register(0x18), Register(0x00)], resolved: None }
16 18 00 
# 8197e Instruction { source: "t169 <- ch Subtract t171", opcode: Negate8, args: [Register(0x00)], resolved: None }
04 00 
# 81980 Instruction { source: "t169 <- ch Subtract t171", opcode: Add8NoCarryIn, args: [Register(0x15), Register(0x00), Register(0x15)], resolved: None }
24 15 00 15 
# 81984 Instruction { source: "num <- num Add t169", opcode: Add8NoCarryIn, args: [Register(0x17), Register(0x15), Register(0x17)], resolved: None }
24 17 15 17 
# 81988 Instruction { source: "goto main_if_end_61", opcode: JmpImm, args: [Label24(main_if_end_61)], resolved: None }
40 8c 19 08 
# main_if_else_0_63
# main_if_end_61
# 8198c Instruction { source: "goto main_if_end_29", opcode: JmpImm, args: [Label24(main_if_end_29)], resolved: None }
40 90 19 08 
# main_if_else_10_60
# main_if_end_29
# 81990 Instruction { source: "goto main_while_predicate_0", opcode: JmpImm, args: [Label24(main_while_predicate_0)], resolved: None }
40 86 14 08 
# main_while_end_2
# 81994 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :print_dec
# Ret None
# Arg0=a
# Var a (Arg0 a Number(U8)) U8 Some([64])
# Var b (Local b Number(U8) U8) U8 Some([65])
# Var t1 (t1 Number(U8, 100)) U8 Some([65])
# Var t10 (t10 Number(U8, 100)) U8 Some([66])
# Var t12 (t12 Number(U8, 10)) U8 Some([65])
# Var t13 (t13 Arithmetic(Add, Ident("b"), Number(U8, 48))) U8 Some([66])
# Var t15 (t15 Number(U8, 48)) U8 Some([66])
# Var t17 (t17 Arithmetic(Multiply, Ident("b"), Number(U8, 10))) U8 Some([65])
# Var t19 (t19 Number(U8, 10)) U8 Some([66])
# Var t21 (t21 Number(U8, 10)) U8 Some([65])
# Var t23 (t23 Number(U8, 10)) U8 Some([65])
# Var t24 (t24 Arithmetic(Add, Ident("b"), Number(U8, 48))) U8 Some([66])
# Var t26 (t26 Number(U8, 48)) U8 Some([66])
# Var t28 (t28 Arithmetic(Multiply, Ident("b"), Number(U8, 10))) U8 Some([65])
# Var t3 (t3 Number(U8, 100)) U8 Some([65])
# Var t30 (t30 Number(U8, 10)) U8 Some([66])
# Var t31 (t31 Arithmetic(Add, Ident("a"), Number(U8, 48))) U8 Some([64])
# Var t33 (t33 Number(U8, 48)) U8 Some([65])
# Var t4 (t4 Arithmetic(Add, Ident("b"), Number(U8, 48))) U8 Some([66])
# Var t6 (t6 Number(U8, 48)) U8 Some([66])
# Var t8 (t8 Arithmetic(Multiply, Ident("b"), Number(U8, 100))) U8 Some([65])
# 81999 Instruction { source: "Save function parameter 'a' registers [0] to locals [64].", opcode: Copy8, args: [Register(0x00), Register(0x40)], resolved: None }
16 00 40 
# 8199c Instruction { source: "t1 <- 0n100/0x64u8 ", opcode: LoadImm8, args: [Register(0x41), Constant8(0x64=100)], resolved: None }
00 41 64 
# 8199f Instruction { source: "if a >= t1 then 'print_dec_if_true_0_1' else 'print_dec_if_else_0_2'", opcode: Cmp8, args: [Register(0x41), Register(0x40)], resolved: None }
25 41 40 
# 819a2 Instruction { source: "if a >= t1 then 'print_dec_if_true_0_1' else 'print_dec_if_else_0_2'", opcode: JcImm, args: [Label24(print_dec_if_true_0_1)], resolved: None }
41 aa 19 08 
# 819a6 Instruction { source: "if a >= t1 then 'print_dec_if_true_0_1' else 'print_dec_if_else_0_2'", opcode: JmpImm, args: [Label24(print_dec_if_else_0_2)], resolved: None }
40 f4 19 08 
# print_dec_if_true_0_1
# 819aa Instruction { source: "t3 <- 0n100/0x64u8 ", opcode: LoadImm8, args: [Register(0x41), Constant8(0x64=100)], resolved: None }
00 41 64 
# 819ad Instruction { source: "b <- a Divide t3", opcode: Divide8, args: [Register(0x40), Register(0x41), Register(0x41)], resolved: None }
27 40 41 41 
# 819b1 Instruction { source: "t6 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x42), Constant8(0x30=48)], resolved: None }
00 42 30 
# 819b4 Instruction { source: "t4 <- b Add t6", opcode: Add8NoCarryIn, args: [Register(0x41), Register(0x42), Register(0x42)], resolved: None }
24 41 42 42 
# 819b8 Instruction { source: "ttyout <- t4", opcode: TtyOut, args: [Register(0x42)], resolved: None }
13 42 
# 819ba Instruction { source: "t10 <- 0n100/0x64u8 ", opcode: LoadImm8, args: [Register(0x42), Constant8(0x64=100)], resolved: None }
00 42 64 
# 819bd Instruction { source: "t8 <- b Multiply t10", opcode: Mul8_1, args: [Register(0x41), Register(0x42)], resolved: None }
20 41 42 
# 819c0 Instruction { source: "t8 <- b Multiply t10", opcode: Mul8_2, args: [], resolved: None }
21 
# 819c1 Instruction { source: "t8 <- b Multiply t10", opcode: Copy8, args: [Register(0x00), Register(0x41)], resolved: None }
16 00 41 
# 819c4 Instruction { source: "a <- a Subtract t8", opcode: Copy8, args: [Register(0x41), Register(0x00)], resolved: None }
16 41 00 
# 819c7 Instruction { source: "a <- a Subtract t8", opcode: Negate8, args: [Register(0x00)], resolved: None }
04 00 
# 819c9 Instruction { source: "a <- a Subtract t8", opcode: Add8NoCarryIn, args: [Register(0x40), Register(0x00), Register(0x40)], resolved: None }
24 40 00 40 
# 819cd Instruction { source: "t12 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x41), Constant8(0x0a=10)], resolved: None }
00 41 0a 
# 819d0 Instruction { source: "b <- a Divide t12", opcode: Divide8, args: [Register(0x40), Register(0x41), Register(0x41)], resolved: None }
27 40 41 41 
# 819d4 Instruction { source: "t15 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x42), Constant8(0x30=48)], resolved: None }
00 42 30 
# 819d7 Instruction { source: "t13 <- b Add t15", opcode: Add8NoCarryIn, args: [Register(0x41), Register(0x42), Register(0x42)], resolved: None }
24 41 42 42 
# 819db Instruction { source: "ttyout <- t13", opcode: TtyOut, args: [Register(0x42)], resolved: None }
13 42 
# 819dd Instruction { source: "t19 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x42), Constant8(0x0a=10)], resolved: None }
00 42 0a 
# 819e0 Instruction { source: "t17 <- b Multiply t19", opcode: Mul8_1, args: [Register(0x41), Register(0x42)], resolved: None }
20 41 42 
# 819e3 Instruction { source: "t17 <- b Multiply t19", opcode: Mul8_2, args: [], resolved: None }
21 
# 819e4 Instruction { source: "t17 <- b Multiply t19", opcode: Copy8, args: [Register(0x00), Register(0x41)], resolved: None }
16 00 41 
# 819e7 Instruction { source: "a <- a Subtract t17", opcode: Copy8, args: [Register(0x41), Register(0x00)], resolved: None }
16 41 00 
# 819ea Instruction { source: "a <- a Subtract t17", opcode: Negate8, args: [Register(0x00)], resolved: None }
04 00 
# 819ec Instruction { source: "a <- a Subtract t17", opcode: Add8NoCarryIn, args: [Register(0x40), Register(0x00), Register(0x40)], resolved: None }
24 40 00 40 
# 819f0 Instruction { source: "goto print_dec_if_end_0", opcode: JmpImm, args: [Label24(print_dec_if_end_0)], resolved: None }
40 29 1a 08 
# print_dec_if_else_0_2
# 819f4 Instruction { source: "t21 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x41), Constant8(0x0a=10)], resolved: None }
00 41 0a 
# 819f7 Instruction { source: "if a >= t21 then 'print_dec_if_true_1_3' else 'print_dec_if_else_1_4'", opcode: Cmp8, args: [Register(0x41), Register(0x40)], resolved: None }
25 41 40 
# 819fa Instruction { source: "if a >= t21 then 'print_dec_if_true_1_3' else 'print_dec_if_else_1_4'", opcode: JcImm, args: [Label24(print_dec_if_true_1_3)], resolved: None }
41 02 1a 08 
# 819fe Instruction { source: "if a >= t21 then 'print_dec_if_true_1_3' else 'print_dec_if_else_1_4'", opcode: JmpImm, args: [Label24(print_dec_if_else_1_4)], resolved: None }
40 29 1a 08 
# print_dec_if_true_1_3
# 81a02 Instruction { source: "t23 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x41), Constant8(0x0a=10)], resolved: None }
00 41 0a 
# 81a05 Instruction { source: "b <- a Divide t23", opcode: Divide8, args: [Register(0x40), Register(0x41), Register(0x41)], resolved: None }
27 40 41 41 
# 81a09 Instruction { source: "t26 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x42), Constant8(0x30=48)], resolved: None }
00 42 30 
# 81a0c Instruction { source: "t24 <- b Add t26", opcode: Add8NoCarryIn, args: [Register(0x41), Register(0x42), Register(0x42)], resolved: None }
24 41 42 42 
# 81a10 Instruction { source: "ttyout <- t24", opcode: TtyOut, args: [Register(0x42)], resolved: None }
13 42 
# 81a12 Instruction { source: "t30 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x42), Constant8(0x0a=10)], resolved: None }
00 42 0a 
# 81a15 Instruction { source: "t28 <- b Multiply t30", opcode: Mul8_1, args: [Register(0x41), Register(0x42)], resolved: None }
20 41 42 
# 81a18 Instruction { source: "t28 <- b Multiply t30", opcode: Mul8_2, args: [], resolved: None }
21 
# 81a19 Instruction { source: "t28 <- b Multiply t30", opcode: Copy8, args: [Register(0x00), Register(0x41)], resolved: None }
16 00 41 
# 81a1c Instruction { source: "a <- a Subtract t28", opcode: Copy8, args: [Register(0x41), Register(0x00)], resolved: None }
16 41 00 
# 81a1f Instruction { source: "a <- a Subtract t28", opcode: Negate8, args: [Register(0x00)], resolved: None }
04 00 
# 81a21 Instruction { source: "a <- a Subtract t28", opcode: Add8NoCarryIn, args: [Register(0x40), Register(0x00), Register(0x40)], resolved: None }
24 40 00 40 
# 81a25 Instruction { source: "goto print_dec_if_end_0", opcode: JmpImm, args: [Label24(print_dec_if_end_0)], resolved: None }
40 29 1a 08 
# print_dec_if_else_1_4
# print_dec_if_end_0
# 81a29 Instruction { source: "t33 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x41), Constant8(0x30=48)], resolved: None }
00 41 30 
# 81a2c Instruction { source: "t31 <- a Add t33", opcode: Add8NoCarryIn, args: [Register(0x40), Register(0x41), Register(0x40)], resolved: None }
24 40 41 40 
# 81a30 Instruction { source: "ttyout <- t31", opcode: TtyOut, args: [Register(0x40)], resolved: None }
13 40 
# 81a32 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81a34 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :print_dec_test
# Ret Some(U8)
# Arg0=a
# Arg1=b
# Var a (Arg0 a Number(U8)) U8 Some([67])
# Var b (Arg1 b Number(U8)) U8 Some([68])
# Var t0 (t0 Call(Call { function: "print_dec", parameters: [Ident("a")] })) U8 Some([67])
# Var t2 (t2 Number(U8, 0)) U8 Some([67])
# 81a39 Instruction { source: "Save function parameter 'a' registers [0] to locals [67].", opcode: Copy8, args: [Register(0x00), Register(0x43)], resolved: None }
16 00 43 
# 81a3c Instruction { source: "Save function parameter 'b' registers [4] to locals [68].", opcode: Copy8, args: [Register(0x04), Register(0x44)], resolved: None }
16 04 44 
# 81a3f Instruction { source: "Arg0[a]=a None <= call print_dec(a,)", opcode: Copy8, args: [Register(0x43), Register(0x00)], resolved: None }
16 43 00 
# Registers used by this function: {67, 68}
# Registers used by callee tree: {64, 65, 66}
# Registers to save: []
# 81a42 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81a48 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 52 1a 08 00 
# 81a4e Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: JmpImm, args: [Label24(:print_dec)], resolved: None }
40 99 19 08 
# 81a52 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81a58 Instruction { source: "t2 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x43), Constant8(0x00=0)], resolved: None }
00 43 00 
# 81a5b Instruction { source: "return Some(t2)", opcode: Copy8, args: [Register(0x43), Register(0x00)], resolved: None }
16 43 00 
# 81a5e Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81a60 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :print_digit
# Ret None
# Arg0=a
# Var a (Arg0 a Number(U8)) U8 Some([69])
# Var t1 (t1 Number(U8, 10)) U8 Some([70])
# Var t2 (t2 Arithmetic(Add, Ident("a"), Number(U8, 48))) U8 Some([69])
# Var t4 (t4 Number(U8, 48)) U8 Some([70])
# Var t6 (t6 Number(U8, 10)) U8 Some([70])
# Var t8 (t8 Number(U8, 65)) U8 Some([70])
# 81a65 Instruction { source: "Save function parameter 'a' registers [0] to locals [69].", opcode: Copy8, args: [Register(0x00), Register(0x45)], resolved: None }
16 00 45 
# 81a68 Instruction { source: "t1 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x46), Constant8(0x0a=10)], resolved: None }
00 46 0a 
# 81a6b Instruction { source: "if a < t1 then 'print_digit_if_true_0_1' else 'print_digit_if_else_0_2'", opcode: Cmp8, args: [Register(0x46), Register(0x45)], resolved: None }
25 46 45 
# 81a6e Instruction { source: "if a < t1 then 'print_digit_if_true_0_1' else 'print_digit_if_else_0_2'", opcode: JcImm, args: [Label24(print_digit_if_else_0_2)], resolved: None }
41 7f 1a 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if a < t1 then 'print_digit_if_true_0_1' else 'print_digit_if_else_0_2'", opcode: JmpImm, args: [Label24(print_digit_if_true_0_1)], resolved: None }
# print_digit_if_true_0_1
# 81a72 Instruction { source: "t4 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x46), Constant8(0x30=48)], resolved: None }
00 46 30 
# 81a75 Instruction { source: "t2 <- a Add t4", opcode: Add8NoCarryIn, args: [Register(0x45), Register(0x46), Register(0x45)], resolved: None }
24 45 46 45 
# 81a79 Instruction { source: "ttyout <- t2", opcode: TtyOut, args: [Register(0x45)], resolved: None }
13 45 
# 81a7b Instruction { source: "goto print_digit_if_end_0", opcode: JmpImm, args: [Label24(print_digit_if_end_0)], resolved: None }
40 94 1a 08 
# print_digit_if_else_0_2
# 81a7f Instruction { source: "t6 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x46), Constant8(0x0a=10)], resolved: None }
00 46 0a 
# 81a82 Instruction { source: "a <- a Subtract t6", opcode: Copy8, args: [Register(0x46), Register(0x00)], resolved: None }
16 46 00 
# 81a85 Instruction { source: "a <- a Subtract t6", opcode: Negate8, args: [Register(0x00)], resolved: None }
04 00 
# 81a87 Instruction { source: "a <- a Subtract t6", opcode: Add8NoCarryIn, args: [Register(0x45), Register(0x00), Register(0x45)], resolved: None }
24 45 00 45 
# 81a8b Instruction { source: "t8 <- 0n65/0x41u8 ", opcode: LoadImm8, args: [Register(0x46), Constant8(0x41=65)], resolved: None }
00 46 41 
# 81a8e Instruction { source: "a <- a Add t8", opcode: Add8NoCarryIn, args: [Register(0x45), Register(0x46), Register(0x45)], resolved: None }
24 45 46 45 
# 81a92 Instruction { source: "ttyout <- a", opcode: TtyOut, args: [Register(0x45)], resolved: None }
13 45 
# print_digit_if_end_0
# 81a94 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81a96 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :println
# Ret None
# Arg0=buf
# Var buf (Arg0 buf Ptr(Number(U8))) U32 Some([72, 73, 74, 75])
# Var ch (Local ch Number(U8) U8) U8 Some([76])
# Var t2 (t2 Number(U8, 0)) U8 Some([77])
# Var t5 (t5 Number(USIZE, 1)) U32 Some([80, 81, 82, 83])
# 81a9b Instruction { source: "Save function parameter 'buf' registers [0, 1, 2, 3] to locals [72, 73, 74, 75].", opcode: Copy32, args: [Register(0x00), Register(0x48)], resolved: None }
81 00 48 
# 81a9e Instruction { source: "ch <- mem[buf] U8", opcode: Load8, args: [Register(0x48), Register(0x4c)], resolved: None }
10 48 4c 
# println_while_predicate_0
# 81aa1 Instruction { source: "t2 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x4d), Constant8(0x00=0)], resolved: None }
00 4d 00 
# 81aa4 Instruction { source: "if ch != t2 then 'println_while_body_1' else 'println_while_end_2'", opcode: Cmp8, args: [Register(0x4c), Register(0x4d)], resolved: None }
25 4c 4d 
# 81aa7 Instruction { source: "if ch != t2 then 'println_while_body_1' else 'println_while_end_2'", opcode: JzImm, args: [Label24(println_while_end_2)], resolved: None }
42 be 1a 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if ch != t2 then 'println_while_body_1' else 'println_while_end_2'", opcode: JmpImm, args: [Label24(println_while_body_1)], resolved: None }
# println_while_body_1
# 81aab Instruction { source: "ttyout <- ch", opcode: TtyOut, args: [Register(0x4c)], resolved: None }
13 4c 
# 81aad Instruction { source: "t5 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x50), Constant32(0x00000001=1)], resolved: None }
80 50 01 00 00 00 
# 81ab3 Instruction { source: "buf <- buf Add t5", opcode: Add32NoCarryIn, args: [Register(0x48), Register(0x50), Register(0x48)], resolved: None }
a0 48 50 48 
# 81ab7 Instruction { source: "ch <- mem[buf] U8", opcode: Load8, args: [Register(0x48), Register(0x4c)], resolved: None }
10 48 4c 
# 81aba Instruction { source: "goto println_while_predicate_0", opcode: JmpImm, args: [Label24(println_while_predicate_0)], resolved: None }
40 a1 1a 08 
# println_while_end_2
# 81abe Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81ac0 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :readline
# Ret None
# Arg0=buf
# Var buf (Arg0 buf Ptr(Number(U8))) U32 Some([84, 85, 86, 87])
# Var ch (Local ch Number(U8) U8) U8 Some([88])
# Var t0 (t0 Number(U8, 0)) U8 Some([88])
# Var t1 (t1 Number(U8, 0)) U8 Some([89])
# Var t10 (t10 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Number(U8))), new_type: Number(USIZE), value: Ident("buf") }, Number(USIZE, 1)) }) U32 Some([84, 85, 86, 87])
# Var t12 (t12 Number(USIZE, 1)) U32 Some([92, 93, 94, 95])
# Var t3 (t3 Number(U8, 13)) U8 Some([89])
# Var t5 (t5 Number(U8, 10)) U8 Some([89])
# Var t7 (t7 Number(U8, 0)) U8 Some([88])
# 81ac5 Instruction { source: "Save function parameter 'buf' registers [0, 1, 2, 3] to locals [84, 85, 86, 87].", opcode: Copy32, args: [Register(0x00), Register(0x54)], resolved: None }
81 00 54 
# readline_while_predicate_0
# 81ac8 Instruction { source: "t0 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x58), Constant8(0x00=0)], resolved: None }
00 58 00 
# 81acb Instruction { source: "t1 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x59), Constant8(0x00=0)], resolved: None }
00 59 00 
# 81ace Instruction { source: "if t0 == t1 then 'readline_while_body_1' else 'readline_while_end_2'", opcode: Cmp8, args: [Register(0x58), Register(0x59)], resolved: None }
25 58 59 
# 81ad1 Instruction { source: "if t0 == t1 then 'readline_while_body_1' else 'readline_while_end_2'", opcode: JzImm, args: [Label24(readline_while_body_1)], resolved: None }
42 d9 1a 08 
# 81ad5 Instruction { source: "if t0 == t1 then 'readline_while_body_1' else 'readline_while_end_2'", opcode: JmpImm, args: [Label24(readline_while_end_2)], resolved: None }
40 32 1b 08 
# readline_while_body_1
# Registers used by this function: {84, 85, 86, 87, 88, 89, 92, 93, 94, 95}
# Registers used by callee tree: {16, 17, 18}
# Registers to save: []
# 81ad9 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81adf Instruction { source: "PseudoCall(Label24(:getchar))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c e9 1a 08 00 
# 81ae5 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: JmpImm, args: [Label24(:getchar)], resolved: None }
40 22 14 08 
# 81ae9 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81aef Instruction { source: "Some(ch) <= call getchar()", opcode: Copy8, args: [Register(0x00), Register(0x58)], resolved: None }
16 00 58 
# 81af2 Instruction { source: "t3 <- 0n13/0x0du8 ", opcode: LoadImm8, args: [Register(0x59), Constant8(0x0d=13)], resolved: None }
00 59 0d 
# 81af5 Instruction { source: "if ch == t3 then 'readline_if_true_0_4' else 'readline_if_else_0_5'", opcode: Cmp8, args: [Register(0x58), Register(0x59)], resolved: None }
25 58 59 
# 81af8 Instruction { source: "if ch == t3 then 'readline_if_true_0_4' else 'readline_if_else_0_5'", opcode: JzImm, args: [Label24(readline_if_true_0_4)], resolved: None }
42 00 1b 08 
# 81afc Instruction { source: "if ch == t3 then 'readline_if_true_0_4' else 'readline_if_else_0_5'", opcode: JmpImm, args: [Label24(readline_if_else_0_5)], resolved: None }
40 04 1b 08 
# readline_if_true_0_4
# 81b00 Instruction { source: "goto readline_if_end_3", opcode: JmpImm, args: [Label24(readline_if_end_3)], resolved: None }
40 2e 1b 08 
# readline_if_else_0_5
# 81b04 Instruction { source: "t5 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x59), Constant8(0x0a=10)], resolved: None }
00 59 0a 
# 81b07 Instruction { source: "if ch == t5 then 'readline_if_true_1_6' else 'readline_if_else_1_7'", opcode: Cmp8, args: [Register(0x58), Register(0x59)], resolved: None }
25 58 59 
# 81b0a Instruction { source: "if ch == t5 then 'readline_if_true_1_6' else 'readline_if_else_1_7'", opcode: JzImm, args: [Label24(readline_if_true_1_6)], resolved: None }
42 12 1b 08 
# 81b0e Instruction { source: "if ch == t5 then 'readline_if_true_1_6' else 'readline_if_else_1_7'", opcode: JmpImm, args: [Label24(readline_if_else_1_7)], resolved: None }
40 1e 1b 08 
# readline_if_true_1_6
# 81b12 Instruction { source: "t7 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x58), Constant8(0x00=0)], resolved: None }
00 58 00 
# 81b15 Instruction { source: "mem[buf] <- t7 U8", opcode: Store8, args: [Register(0x58), Register(0x54)], resolved: None }
11 58 54 
# 81b18 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81b1a Instruction { source: "goto readline_if_end_3", opcode: JmpImm, args: [Label24(readline_if_end_3)], resolved: None }
40 2e 1b 08 
# readline_if_else_1_7
# 81b1e Instruction { source: "mem[buf] <- ch U8", opcode: Store8, args: [Register(0x58), Register(0x54)], resolved: None }
11 58 54 
# 81b21 Instruction { source: "t12 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x5c), Constant32(0x00000001=1)], resolved: None }
80 5c 01 00 00 00 
# 81b27 Instruction { source: "t10 <- buf Add t12", opcode: Add32NoCarryIn, args: [Register(0x54), Register(0x5c), Register(0x54)], resolved: None }
a0 54 5c 54 
# 81b2b Instruction { source: "buf <- t10 U32", opcode: Copy32, args: [Register(0x54), Register(0x54)], resolved: None }
81 54 54 
# readline_if_end_3
# 81b2e Instruction { source: "goto readline_while_predicate_0", opcode: JmpImm, args: [Label24(readline_while_predicate_0)], resolved: None }
40 c8 1a 08 
# readline_while_end_2
# 81b32 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81b34 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :stack_get
# Ret Some(U8)
# Arg0=s
# Arg1=n
# Var n (Arg1 n Number(USIZE)) U32 Some([96, 97, 98, 99])
# Var s (Arg0 s Ptr(Struct("Stack"))) U32 Some([100, 101, 102, 103])
# Var t1 (t1 Index("values", Ident("n"))) U8 Some([104])
# Var t2 (t2 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Number(U8))), new_type: Number(USIZE), value: Ident("values") }, Ident("n")) }) U32 Some([96, 97, 98, 99])
# 81b39 Instruction { source: "Save function parameter 's' registers [0, 1, 2, 3] to locals [100, 101, 102, 103].", opcode: Copy32, args: [Register(0x00), Register(0x64)], resolved: None }
81 00 64 
# 81b3c Instruction { source: "Save function parameter 'n' registers [4, 5, 6, 7] to locals [96, 97, 98, 99].", opcode: Copy32, args: [Register(0x04), Register(0x60)], resolved: None }
81 04 60 
# 81b3f Instruction { source: "t2 <- s Add n", opcode: Add32NoCarryIn, args: [Register(0x64), Register(0x60), Register(0x60)], resolved: None }
a0 64 60 60 
# 81b43 Instruction { source: "t1 <- mem[t2] U8", opcode: Load8, args: [Register(0x60), Register(0x68)], resolved: None }
10 60 68 
# 81b46 Instruction { source: "return Some(t1)", opcode: Copy8, args: [Register(0x68), Register(0x00)], resolved: None }
16 68 00 
# 81b49 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81b4b Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :stack_init
# Ret None
# Arg0=s
# Var s (Arg0 s Ptr(Struct("Stack"))) U32 Some([108, 109, 110, 111])
# Var t0 (t0 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 4)) }) U32 Some([108, 109, 110, 111])
# Var t2 (t2 Number(USIZE, 4)) U32 Some([112, 113, 114, 115])
# Var t3 (t3 Number(USIZE, 0)) U32 Some([112, 113, 114, 115])
# 81b50 Instruction { source: "Save function parameter 's' registers [0, 1, 2, 3] to locals [108, 109, 110, 111].", opcode: Copy32, args: [Register(0x00), Register(0x6c)], resolved: None }
81 00 6c 
# 81b53 Instruction { source: "t2 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x70), Constant32(0x00000004=4)], resolved: None }
80 70 04 00 00 00 
# 81b59 Instruction { source: "t0 <- s Add t2", opcode: Add32NoCarryIn, args: [Register(0x6c), Register(0x70), Register(0x6c)], resolved: None }
a0 6c 70 6c 
# 81b5d Instruction { source: "t3 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x70), Constant32(0x00000000=0)], resolved: None }
80 70 00 00 00 00 
# 81b63 Instruction { source: "mem[t0] <- t3 U32", opcode: Store32_1, args: [Register(0x70), Register(0x6c)], resolved: None }
92 70 6c 
# 81b66 Instruction { source: "mem[t0] <- t3 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 81b67 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81b69 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :stack_pop
# Ret Some(U8)
# Arg0=s
# Var s (Arg0 s Ptr(Struct("Stack"))) U32 Some([116, 117, 118, 119])
# Var t0 (t0 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 4)) }) U32 Some([120, 121, 122, 123])
# Var t10 (t10 Index("values", PtrFieldDeref("s", "first_free"))) U8 Some([124])
# Var t11 (t11 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Number(U8))), new_type: Number(USIZE), value: Ident("values") }, PtrFieldDeref("s", "first_free")) }) U32 Some([116, 117, 118, 119])
# Var t13 (t13 PtrFieldDeref("s", "first_free")) U32 Some([120, 121, 122, 123])
# Var t14 (t14 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 4)) }) U32 Some([120, 121, 122, 123])
# Var t16 (t16 Number(USIZE, 4)) U32 Some([120, 121, 122, 123])
# Var t2 (t2 Number(USIZE, 4)) U32 Some([120, 121, 122, 123])
# Var t3 (t3 Arithmetic(Subtract, PtrFieldDeref("s", "first_free"), Number(U8, 1))) U32 Some([128, 129, 130, 131])
# Var t4 (t4 PtrFieldDeref("s", "first_free")) U32 Some([128, 129, 130, 131])
# Var t5 (t5 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 4)) }) U32 Some([128, 129, 130, 131])
# Var t7 (t7 Number(USIZE, 4)) U32 Some([128, 129, 130, 131])
# Var t8 (t8 Number(USIZE, 1)) U32 Some([132, 133, 134, 135])
# 81b6e Instruction { source: "Save function parameter 's' registers [0, 1, 2, 3] to locals [116, 117, 118, 119].", opcode: Copy32, args: [Register(0x00), Register(0x74)], resolved: None }
81 00 74 
# 81b71 Instruction { source: "t2 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x78), Constant32(0x00000004=4)], resolved: None }
80 78 04 00 00 00 
# 81b77 Instruction { source: "t0 <- s Add t2", opcode: Add32NoCarryIn, args: [Register(0x74), Register(0x78), Register(0x78)], resolved: None }
a0 74 78 78 
# 81b7b Instruction { source: "t7 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x80), Constant32(0x00000004=4)], resolved: None }
80 80 04 00 00 00 
# 81b81 Instruction { source: "t5 <- s Add t7", opcode: Add32NoCarryIn, args: [Register(0x74), Register(0x80), Register(0x80)], resolved: None }
a0 74 80 80 
# 81b85 Instruction { source: "t4 <- mem[t5] U32", opcode: Load32, args: [Register(0x80), Register(0x80)], resolved: None }
90 80 80 
# 81b88 Instruction { source: "t8 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x84), Constant32(0x00000001=1)], resolved: None }
80 84 01 00 00 00 
# 81b8e Instruction { source: "t3 <- t4 Subtract t8", opcode: Copy32, args: [Register(0x84), Register(0x00)], resolved: None }
81 84 00 
# 81b91 Instruction { source: "t3 <- t4 Subtract t8", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 81b93 Instruction { source: "t3 <- t4 Subtract t8", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 81b95 Instruction { source: "t3 <- t4 Subtract t8", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 81b97 Instruction { source: "t3 <- t4 Subtract t8", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 81b99 Instruction { source: "t3 <- t4 Subtract t8", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 81b9f Instruction { source: "t3 <- t4 Subtract t8", opcode: Add32NoCarryIn, args: [Register(0x80), Register(0x00), Register(0x80)], resolved: None }
a0 80 00 80 
# 81ba3 Instruction { source: "mem[t0] <- t3 U32", opcode: Store32_1, args: [Register(0x80), Register(0x78)], resolved: None }
92 80 78 
# 81ba6 Instruction { source: "mem[t0] <- t3 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 81ba7 Instruction { source: "t16 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x78), Constant32(0x00000004=4)], resolved: None }
80 78 04 00 00 00 
# 81bad Instruction { source: "t14 <- s Add t16", opcode: Add32NoCarryIn, args: [Register(0x74), Register(0x78), Register(0x78)], resolved: None }
a0 74 78 78 
# 81bb1 Instruction { source: "t13 <- mem[t14] U32", opcode: Load32, args: [Register(0x78), Register(0x78)], resolved: None }
90 78 78 
# 81bb4 Instruction { source: "t11 <- s Add t13", opcode: Add32NoCarryIn, args: [Register(0x74), Register(0x78), Register(0x74)], resolved: None }
a0 74 78 74 
# 81bb8 Instruction { source: "t10 <- mem[t11] U8", opcode: Load8, args: [Register(0x74), Register(0x7c)], resolved: None }
10 74 7c 
# 81bbb Instruction { source: "return Some(t10)", opcode: Copy8, args: [Register(0x7c), Register(0x00)], resolved: None }
16 7c 00 
# 81bbe Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81bc0 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :stack_push
# Ret None
# Arg0=s
# Arg1=n
# Var n (Arg1 n Number(U8)) U8 Some([136])
# Var s (Arg0 s Ptr(Struct("Stack"))) U32 Some([140, 141, 142, 143])
# Var t1 (t1 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Number(U8))), new_type: Number(USIZE), value: Ident("values") }, PtrFieldDeref("s", "first_free")) }) U32 Some([144, 145, 146, 147])
# Var t10 (t10 Number(USIZE, 4)) U32 Some([148, 149, 150, 151])
# Var t11 (t11 Arithmetic(Add, PtrFieldDeref("s", "first_free"), Number(U8, 1))) U32 Some([148, 149, 150, 151])
# Var t12 (t12 PtrFieldDeref("s", "first_free")) U32 Some([148, 149, 150, 151])
# Var t13 (t13 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 4)) }) U32 Some([148, 149, 150, 151])
# Var t15 (t15 Number(USIZE, 4)) U32 Some([148, 149, 150, 151])
# Var t16 (t16 Number(USIZE, 1)) U32 Some([140, 141, 142, 143])
# Var t3 (t3 PtrFieldDeref("s", "first_free")) U32 Some([144, 145, 146, 147])
# Var t4 (t4 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 4)) }) U32 Some([144, 145, 146, 147])
# Var t6 (t6 Number(USIZE, 4)) U32 Some([144, 145, 146, 147])
# Var t8 (t8 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 4)) }) U32 Some([144, 145, 146, 147])
# 81bc5 Instruction { source: "Save function parameter 's' registers [0, 1, 2, 3] to locals [140, 141, 142, 143].", opcode: Copy32, args: [Register(0x00), Register(0x8c)], resolved: None }
81 00 8c 
# 81bc8 Instruction { source: "Save function parameter 'n' registers [4] to locals [136].", opcode: Copy8, args: [Register(0x04), Register(0x88)], resolved: None }
16 04 88 
# 81bcb Instruction { source: "t6 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x90), Constant32(0x00000004=4)], resolved: None }
80 90 04 00 00 00 
# 81bd1 Instruction { source: "t4 <- s Add t6", opcode: Add32NoCarryIn, args: [Register(0x8c), Register(0x90), Register(0x90)], resolved: None }
a0 8c 90 90 
# 81bd5 Instruction { source: "t3 <- mem[t4] U32", opcode: Load32, args: [Register(0x90), Register(0x90)], resolved: None }
90 90 90 
# 81bd8 Instruction { source: "t1 <- s Add t3", opcode: Add32NoCarryIn, args: [Register(0x8c), Register(0x90), Register(0x90)], resolved: None }
a0 8c 90 90 
# 81bdc Instruction { source: "mem[t1] <- n U8", opcode: Store8, args: [Register(0x88), Register(0x90)], resolved: None }
11 88 90 
# 81bdf Instruction { source: "t10 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x94), Constant32(0x00000004=4)], resolved: None }
80 94 04 00 00 00 
# 81be5 Instruction { source: "t8 <- s Add t10", opcode: Add32NoCarryIn, args: [Register(0x8c), Register(0x94), Register(0x90)], resolved: None }
a0 8c 94 90 
# 81be9 Instruction { source: "t15 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x94), Constant32(0x00000004=4)], resolved: None }
80 94 04 00 00 00 
# 81bef Instruction { source: "t13 <- s Add t15", opcode: Add32NoCarryIn, args: [Register(0x8c), Register(0x94), Register(0x94)], resolved: None }
a0 8c 94 94 
# 81bf3 Instruction { source: "t12 <- mem[t13] U32", opcode: Load32, args: [Register(0x94), Register(0x94)], resolved: None }
90 94 94 
# 81bf6 Instruction { source: "t16 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x8c), Constant32(0x00000001=1)], resolved: None }
80 8c 01 00 00 00 
# 81bfc Instruction { source: "t11 <- t12 Add t16", opcode: Add32NoCarryIn, args: [Register(0x94), Register(0x8c), Register(0x94)], resolved: None }
a0 94 8c 94 
# 81c00 Instruction { source: "mem[t8] <- t11 U32", opcode: Store32_1, args: [Register(0x94), Register(0x90)], resolved: None }
92 94 90 
# 81c03 Instruction { source: "mem[t8] <- t11 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 81c04 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81c06 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :test_echoline
# Ret Some(U8)
# Var __frame_pointer (__frame_pointer) U32 Some([12, 13, 14, 15])
# Var buf (Local buf Array(Number(U8), 20) FrameOffset(0)) FrameOffset(0) None
# Var t0 (t0 Call(Call { function: "readline", parameters: [AddressOf(Index("buf", Number(U8, 0)))] })) U8 Some([152])
# Var t10 (t10 Cast { old_type: Some(Number(U8)), new_type: Number(USIZE), value: Number(U8, 0) }) U32 Some([156, 157, 158, 159])
# Var t11 (t11 Number(U8, 0)) U8 Some([160])
# Var t12 (t12 Number(U8, 0)) U8 Some([152])
# Var t2 (t2 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Ident("__frame_pointer"), Cast { old_type: Some(Number(U8)), new_type: Number(USIZE), value: Number(U8, 0) }) }) U32 Some([156, 157, 158, 159])
# Var t4 (t4 Cast { old_type: Some(Number(U8)), new_type: Number(USIZE), value: Number(U8, 0) }) U32 Some([156, 157, 158, 159])
# Var t5 (t5 Number(U8, 0)) U8 Some([160])
# Var t6 (t6 Call(Call { function: "println", parameters: [AddressOf(Index("buf", Number(U8, 0)))] })) U8 Some([152])
# Var t8 (t8 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Ident("__frame_pointer"), Cast { old_type: Some(Number(U8)), new_type: Number(USIZE), value: Number(U8, 0) }) }) U32 Some([164, 165, 166, 167])
# 81c0b Instruction { source: "reserve 20 bytes of stack space for locals", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xffffffec=4294967276)], resolved: None }
a3 0c ec ff ff ff 
# 81c11 Instruction { source: "t5 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xa0), Constant8(0x00=0)], resolved: None }
00 a0 00 
# 81c14 Instruction { source: "Zero-pad for t4 U32 <- t5 U8", opcode: LoadImm32, args: [Register(0x9c), Constant32(0x00000000=0)], resolved: None }
80 9c 00 00 00 00 
# 81c1a Instruction { source: "t4 U32 <- t5 U8", opcode: Copy8, args: [Register(0xa0), Register(0x9c)], resolved: None }
16 a0 9c 
# 81c1d Instruction { source: "t2 <- __frame_pointer Add t4", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x9c), Register(0x9c)], resolved: None }
a0 0c 9c 9c 
# 81c21 Instruction { source: "Arg0[buf]=t2 None <= call readline(t2,)", opcode: Copy32, args: [Register(0x9c), Register(0x00)], resolved: None }
81 9c 00 
# Registers used by this function: {152, 156, 157, 158, 159, 160, 164, 165, 166, 167}
# Registers used by callee tree: {16, 17, 18, 84, 85, 86, 87, 88, 89, 92, 93, 94, 95}
# Registers to save: []
# 81c24 Instruction { source: "PseudoCall(Label24(:readline))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81c2a Instruction { source: "PseudoCall(Label24(:readline))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 34 1c 08 00 
# 81c30 Instruction { source: "PseudoCall(Label24(:readline))", opcode: JmpImm, args: [Label24(:readline)], resolved: None }
40 c5 1a 08 
# 81c34 Instruction { source: "PseudoCall(Label24(:readline))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81c3a Instruction { source: "t11 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xa0), Constant8(0x00=0)], resolved: None }
00 a0 00 
# 81c3d Instruction { source: "Zero-pad for t10 U32 <- t11 U8", opcode: LoadImm32, args: [Register(0x9c), Constant32(0x00000000=0)], resolved: None }
80 9c 00 00 00 00 
# 81c43 Instruction { source: "t10 U32 <- t11 U8", opcode: Copy8, args: [Register(0xa0), Register(0x9c)], resolved: None }
16 a0 9c 
# 81c46 Instruction { source: "t8 <- __frame_pointer Add t10", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x9c), Register(0xa4)], resolved: None }
a0 0c 9c a4 
# 81c4a Instruction { source: "Arg0[buf]=t8 None <= call println(t8,)", opcode: Copy32, args: [Register(0xa4), Register(0x00)], resolved: None }
81 a4 00 
# Registers used by this function: {152, 156, 157, 158, 159, 160, 164, 165, 166, 167}
# Registers used by callee tree: {72, 73, 74, 75, 76, 77, 80, 81, 82, 83}
# Registers to save: []
# 81c4d Instruction { source: "PseudoCall(Label24(:println))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81c53 Instruction { source: "PseudoCall(Label24(:println))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 5d 1c 08 00 
# 81c59 Instruction { source: "PseudoCall(Label24(:println))", opcode: JmpImm, args: [Label24(:println)], resolved: None }
40 9b 1a 08 
# 81c5d Instruction { source: "PseudoCall(Label24(:println))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81c63 Instruction { source: "t12 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x98), Constant8(0x00=0)], resolved: None }
00 98 00 
# 81c66 Instruction { source: "return Some(t12)", opcode: Copy8, args: [Register(0x98), Register(0x00)], resolved: None }
16 98 00 
# 81c69 Instruction { source: "Dealloc 20 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000014=20)], resolved: None }
a3 0c 14 00 00 00 
# 81c6f Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81c71 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
