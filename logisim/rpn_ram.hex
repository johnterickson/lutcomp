v2.0 raw
# ImageBaseAddress=0x00081400
# entry
# 81400 Instruction { source: "Initialzing flags and internal regs.", opcode: Init, args: [], resolved: None }
0f 
# 81401 Instruction { source: "Initialzing stack register to 0x000ffffc.", opcode: LoadImm32, args: [Register(0x0c), Constant32(0x000ffffc=1048572)], resolved: None }
80 0c fc ff 0f 00 
# 81407 Instruction { source: "PseudoCall(Label24(:main))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8140d Instruction { source: "PseudoCall(Label24(:main))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 17 14 08 00 
# 81413 Instruction { source: "PseudoCall(Label24(:main))", opcode: JmpImm, args: [Label24(:main)], resolved: None }
40 2e 23 08 
# 81417 Instruction { source: "PseudoCall(Label24(:main))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8141d Instruction { source: "Halting after return from entry function.", opcode: Halt, args: [Constant32(0x00000000=0)], resolved: None }
ff 00 00 00 00 
# :RpnCalc_handle
# Ret Some(U8)
# Arg0=c
# Arg1=ch
# Var a (Local a Number(USIZE) U32) U32 Some([16, 17, 18, 19])
# Var b (Local b Number(USIZE) U32) U32 Some([20, 21, 22, 23])
# Var c (Arg0 c Ptr(Struct("RpnCalc"))) U32 Some([24, 25, 26, 27])
# Var ch (Arg1 ch Number(U8)) U8 Some([28])
# Var diff (Local diff Number(USIZE) U32) U32 Some([16, 17, 18, 19])
# Var i (Local i Number(U8) U8) U8 Some([29])
# Var product (Local product Number(USIZE) U32) U32 Some([16, 17, 18, 19])
# Var quotient (Local quotient Number(USIZE) U32) U32 Some([16, 17, 18, 19])
# Var stack (Local stack Ptr(Struct("Stack")) U32) U32 Some([32, 33, 34, 35])
# Var stack_count (Local stack_count Number(U8) U8) U8 Some([36])
# Var stack_count_usize (Local stack_count_usize Number(USIZE) U32) U32 Some([40, 41, 42, 43])
# Var stack_needed (Local stack_needed Number(U8) U8) U8 Some([44])
# Var sum (Local sum Number(USIZE) U32) U32 Some([16, 17, 18, 19])
# Var t0 (t0 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Struct("Stack")), value: Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") } }) U32 Some([16, 17, 18, 19])
# Var t1 (t1 Ident("ch")) U8 Some([28])
# Var t10 (t10 Number(U8, 115)) U8 Some([36])
# Var t100 (t100 Number(U8, 58)) U8 Some([45])
# Var t101 (t101 Call(Call { function: "print_dec32", parameters: [Call(Call { function: "stack_get", parameters: [Ident("stack"), Cast { old_type: None, new_type: Number(USIZE), value: Ident("i") }] })] })) U8 Some([29])
# Var t102 (t102 Call(Call { function: "stack_get", parameters: [Ident("stack"), Cast { old_type: None, new_type: Number(USIZE), value: Ident("i") }] })) U32 Some([20, 21, 22, 23])
# Var t103 (t103 Ident("stack")) U32 Some([20, 21, 22, 23])
# Var t104 (t104 Cast { old_type: None, new_type: Number(USIZE), value: Ident("i") }) U32 Some([24, 25, 26, 27])
# Var t105 (t105 Ident("i")) U8 Some([29])
# Var t106 (t106 Number(U8, 10)) U8 Some([45])
# Var t107 (t107 Ident("i")) U8 Some([29])
# Var t108 (t108 Number(U8, 1)) U8 Some([45])
# Var t109 (t109 Ident("ch")) U8 Some([29])
# Var t11 (t11 Ident("stack_needed")) U8 Some([36])
# Var t110 (t110 Number(U8, 57)) U8 Some([45])
# Var t111 (t111 Ident("ch")) U8 Some([29])
# Var t112 (t112 Number(U8, 48)) U8 Some([45])
# Var t113 (t113 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 72)) }) U32 Some([16, 17, 18, 19])
# Var t114 (t114 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([16, 17, 18, 19])
# Var t115 (t115 Number(USIZE, 72)) U32 Some([20, 21, 22, 23])
# Var t116 (t116 Number(U8, 1)) U8 Some([45])
# Var t117 (t117 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 68)) }) U32 Some([16, 17, 18, 19])
# Var t118 (t118 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([16, 17, 18, 19])
# Var t119 (t119 Number(USIZE, 68)) U32 Some([20, 21, 22, 23])
# Var t12 (t12 Number(U8, 0)) U8 Some([46])
# Var t120 (t120 Call(Call { function: "mul32_32", parameters: [PtrFieldDeref("c", "num"), Number(USIZE, 10)] })) U32 Some([20, 21, 22, 23])
# Var t121 (t121 PtrFieldDeref("c", "num")) U32 Some([20, 21, 22, 23])
# Var t122 (t122 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 68)) }) U32 Some([20, 21, 22, 23])
# Var t123 (t123 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([20, 21, 22, 23])
# Var t124 (t124 Number(USIZE, 68)) U32 Some([32, 33, 34, 35])
# Var t125 (t125 Number(USIZE, 10)) U32 Some([32, 33, 34, 35])
# Var t126 (t126 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 68)) }) U32 Some([16, 17, 18, 19])
# Var t127 (t127 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([16, 17, 18, 19])
# Var t128 (t128 Number(USIZE, 68)) U32 Some([20, 21, 22, 23])
# Var t129 (t129 Arithmetic(Add, PtrFieldDeref("c", "num"), Cast { old_type: None, new_type: Number(USIZE), value: Arithmetic(Subtract, Ident("ch"), Number(U8, 48)) })) U32 Some([20, 21, 22, 23])
# Var t13 (t13 Call(Call { function: "RpnCalc_push_pending", parameters: [Ident("c")] })) U8 Some([29])
# Var t130 (t130 PtrFieldDeref("c", "num")) U32 Some([20, 21, 22, 23])
# Var t131 (t131 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 68)) }) U32 Some([20, 21, 22, 23])
# Var t132 (t132 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([20, 21, 22, 23])
# Var t133 (t133 Number(USIZE, 68)) U32 Some([24, 25, 26, 27])
# Var t134 (t134 Cast { old_type: None, new_type: Number(USIZE), value: Arithmetic(Subtract, Ident("ch"), Number(U8, 48)) }) U32 Some([24, 25, 26, 27])
# Var t135 (t135 Arithmetic(Subtract, Ident("ch"), Number(U8, 48))) U8 Some([47])
# Var t136 (t136 Ident("ch")) U8 Some([47])
# Var t137 (t137 Number(U8, 48)) U8 Some([28])
# Var t138 (t138 Number(U8, 1)) U8 Some([29])
# Var t14 (t14 Ident("c")) U32 Some([24, 25, 26, 27])
# Var t15 (t15 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("stack") }, Number(USIZE, 64)) }) U32 Some([40, 41, 42, 43])
# Var t16 (t16 Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("stack") }) U32 Some([32, 33, 34, 35])
# Var t17 (t17 Number(USIZE, 64)) U32 Some([40, 41, 42, 43])
# Var t18 (t18 Ident("stack_needed")) U8 Some([44])
# Var t19 (t19 Ident("stack_count")) U8 Some([36])
# Var t2 (t2 Number(U8, 43)) U8 Some([36])
# Var t20 (t20 Number(U8, 69)) U8 Some([29])
# Var t21 (t21 Number(U8, 82)) U8 Some([29])
# Var t22 (t22 Number(U8, 82)) U8 Some([29])
# Var t23 (t23 Number(U8, 10)) U8 Some([29])
# Var t24 (t24 Number(U8, 1)) U8 Some([29])
# Var t25 (t25 Ident("stack_needed")) U8 Some([44])
# Var t26 (t26 Number(U8, 0)) U8 Some([46])
# Var t27 (t27 Ident("stack")) U32 Some([16, 17, 18, 19])
# Var t28 (t28 Ident("stack_needed")) U8 Some([44])
# Var t29 (t29 Number(U8, 1)) U8 Some([46])
# Var t3 (t3 Ident("ch")) U8 Some([28])
# Var t30 (t30 Ident("stack")) U32 Some([20, 21, 22, 23])
# Var t31 (t31 Ident("ch")) U8 Some([28])
# Var t32 (t32 Number(U8, 43)) U8 Some([44])
# Var t33 (t33 Ident("b")) U32 Some([20, 21, 22, 23])
# Var t34 (t34 Ident("a")) U32 Some([16, 17, 18, 19])
# Var t35 (t35 Call(Call { function: "print_dec32", parameters: [Ident("sum")] })) U8 Some([29])
# Var t36 (t36 Ident("sum")) U32 Some([16, 17, 18, 19])
# Var t37 (t37 Number(U8, 10)) U8 Some([45])
# Var t38 (t38 Call(Call { function: "stack_push", parameters: [Ident("stack"), Ident("sum")] })) U8 Some([29])
# Var t39 (t39 Ident("stack")) U32 Some([20, 21, 22, 23])
# Var t4 (t4 Number(U8, 45)) U8 Some([36])
# Var t40 (t40 Ident("sum")) U32 Some([16, 17, 18, 19])
# Var t41 (t41 Ident("ch")) U8 Some([28])
# Var t42 (t42 Number(U8, 45)) U8 Some([44])
# Var t43 (t43 Ident("b")) U32 Some([20, 21, 22, 23])
# Var t44 (t44 Ident("a")) U32 Some([16, 17, 18, 19])
# Var t45 (t45 Call(Call { function: "print_dec32", parameters: [Ident("diff")] })) U8 Some([29])
# Var t46 (t46 Ident("diff")) U32 Some([16, 17, 18, 19])
# Var t47 (t47 Number(U8, 10)) U8 Some([45])
# Var t48 (t48 Call(Call { function: "stack_push", parameters: [Ident("stack"), Ident("diff")] })) U8 Some([29])
# Var t49 (t49 Ident("stack")) U32 Some([20, 21, 22, 23])
# Var t5 (t5 Ident("ch")) U8 Some([28])
# Var t50 (t50 Ident("diff")) U32 Some([16, 17, 18, 19])
# Var t51 (t51 Ident("ch")) U8 Some([28])
# Var t52 (t52 Number(U8, 42)) U8 Some([44])
# Var t53 (t53 Ident("b")) U32 Some([20, 21, 22, 23])
# Var t54 (t54 Ident("a")) U32 Some([16, 17, 18, 19])
# Var t55 (t55 Call(Call { function: "print_dec32", parameters: [Ident("product")] })) U8 Some([29])
# Var t56 (t56 Ident("product")) U32 Some([16, 17, 18, 19])
# Var t57 (t57 Number(U8, 10)) U8 Some([45])
# Var t58 (t58 Call(Call { function: "stack_push", parameters: [Ident("stack"), Ident("product")] })) U8 Some([29])
# Var t59 (t59 Ident("stack")) U32 Some([20, 21, 22, 23])
# Var t6 (t6 Number(U8, 42)) U8 Some([36])
# Var t60 (t60 Ident("product")) U32 Some([16, 17, 18, 19])
# Var t61 (t61 Ident("ch")) U8 Some([28])
# Var t62 (t62 Number(U8, 47)) U8 Some([44])
# Var t63 (t63 Ident("b")) U32 Some([20, 21, 22, 23])
# Var t64 (t64 Ident("a")) U32 Some([16, 17, 18, 19])
# Var t65 (t65 Call(Call { function: "print_dec32", parameters: [Ident("quotient")] })) U8 Some([29])
# Var t66 (t66 Ident("quotient")) U32 Some([16, 17, 18, 19])
# Var t67 (t67 Number(U8, 10)) U8 Some([45])
# Var t68 (t68 Call(Call { function: "stack_push", parameters: [Ident("stack"), Ident("quotient")] })) U8 Some([29])
# Var t69 (t69 Ident("stack")) U32 Some([20, 21, 22, 23])
# Var t7 (t7 Ident("ch")) U8 Some([28])
# Var t70 (t70 Ident("quotient")) U32 Some([16, 17, 18, 19])
# Var t71 (t71 Ident("ch")) U8 Some([28])
# Var t72 (t72 Number(U8, 115)) U8 Some([44])
# Var t73 (t73 Call(Call { function: "stack_push", parameters: [Ident("stack"), Ident("a")] })) U8 Some([29])
# Var t74 (t74 Ident("stack")) U32 Some([24, 25, 26, 27])
# Var t75 (t75 Ident("a")) U32 Some([16, 17, 18, 19])
# Var t76 (t76 Call(Call { function: "stack_push", parameters: [Ident("stack"), Ident("b")] })) U8 Some([29])
# Var t77 (t77 Ident("stack")) U32 Some([16, 17, 18, 19])
# Var t78 (t78 Ident("b")) U32 Some([20, 21, 22, 23])
# Var t79 (t79 Ident("ch")) U8 Some([29])
# Var t8 (t8 Number(U8, 47)) U8 Some([36])
# Var t80 (t80 Number(U8, 113)) U8 Some([45])
# Var t81 (t81 Number(U8, 0)) U8 Some([29])
# Var t82 (t82 Ident("ch")) U8 Some([29])
# Var t83 (t83 Number(U8, 10)) U8 Some([45])
# Var t84 (t84 Call(Call { function: "RpnCalc_push_pending", parameters: [Ident("c")] })) U8 Some([29])
# Var t85 (t85 Ident("c")) U32 Some([16, 17, 18, 19])
# Var t86 (t86 Ident("ch")) U8 Some([29])
# Var t87 (t87 Number(U8, 32)) U8 Some([45])
# Var t88 (t88 Call(Call { function: "RpnCalc_push_pending", parameters: [Ident("c")] })) U8 Some([29])
# Var t89 (t89 Ident("c")) U32 Some([16, 17, 18, 19])
# Var t9 (t9 Ident("ch")) U8 Some([28])
# Var t90 (t90 Ident("ch")) U8 Some([29])
# Var t91 (t91 Number(U8, 99)) U8 Some([45])
# Var t92 (t92 Call(Call { function: "RpnCalc_init", parameters: [Ident("c")] })) U8 Some([29])
# Var t93 (t93 Ident("c")) U32 Some([16, 17, 18, 19])
# Var t94 (t94 Ident("ch")) U8 Some([29])
# Var t95 (t95 Number(U8, 100)) U8 Some([45])
# Var t96 (t96 Ident("i")) U8 Some([29])
# Var t97 (t97 Ident("stack_count")) U8 Some([45])
# Var t98 (t98 Call(Call { function: "print_dec8", parameters: [Ident("i")] })) U8 Some([29])
# Var t99 (t99 Ident("i")) U8 Some([29])
# 81422 Instruction { source: "Save function parameter 'c' registers [0, 1, 2, 3] to locals [24, 25, 26, 27].", opcode: Copy32, args: [Register(0x00), Register(0x18)], resolved: None }
81 00 18 
# 81425 Instruction { source: "Save function parameter 'ch' registers [4] to locals [28].", opcode: Copy8, args: [Register(0x04), Register(0x1c)], resolved: None }
16 04 1c 
# 81428 Instruction { source: "t0 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x10)], resolved: None }
81 18 10 
# 8142b Instruction { source: "stack <- t0 U32", opcode: Copy32, args: [Register(0x10), Register(0x20)], resolved: None }
81 10 20 
# 8142e Instruction { source: "a <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x10), Constant8(0x00=0)], resolved: None }
00 10 00 
# 81431 Instruction { source: "b <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x14), Constant8(0x00=0)], resolved: None }
00 14 00 
# 81434 Instruction { source: "t1 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 81437 Instruction { source: "t2 <- 0n43/0x2bu8 ", opcode: LoadImm8, args: [Register(0x24), Constant8(0x2b=43)], resolved: None }
00 24 2b 
# 8143a Instruction { source: "if t1 == t2 then 'RpnCalc_handle_if_true_0_1' else 'RpnCalc_handle_if_else_0_2'", opcode: Cmp8, args: [Register(0x1c), Register(0x24)], resolved: None }
25 1c 24 
# 8143d Instruction { source: "if t1 == t2 then 'RpnCalc_handle_if_true_0_1' else 'RpnCalc_handle_if_else_0_2'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_0_1)], resolved: None }
42 45 14 08 
# 81441 Instruction { source: "if t1 == t2 then 'RpnCalc_handle_if_true_0_1' else 'RpnCalc_handle_if_else_0_2'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_0_2)], resolved: None }
40 4c 14 08 
# RpnCalc_handle_if_true_0_1
# 81445 Instruction { source: "stack_needed <- 0n2/0x02u8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x02=2)], resolved: None }
00 2c 02 
# 81448 Instruction { source: "goto RpnCalc_handle_if_end_0", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_0)], resolved: None }
40 af 14 08 
# RpnCalc_handle_if_else_0_2
# 8144c Instruction { source: "t3 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 8144f Instruction { source: "t4 <- 0n45/0x2du8 ", opcode: LoadImm8, args: [Register(0x24), Constant8(0x2d=45)], resolved: None }
00 24 2d 
# 81452 Instruction { source: "if t3 == t4 then 'RpnCalc_handle_if_true_1_3' else 'RpnCalc_handle_if_else_1_4'", opcode: Cmp8, args: [Register(0x1c), Register(0x24)], resolved: None }
25 1c 24 
# 81455 Instruction { source: "if t3 == t4 then 'RpnCalc_handle_if_true_1_3' else 'RpnCalc_handle_if_else_1_4'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_1_3)], resolved: None }
42 5d 14 08 
# 81459 Instruction { source: "if t3 == t4 then 'RpnCalc_handle_if_true_1_3' else 'RpnCalc_handle_if_else_1_4'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_1_4)], resolved: None }
40 64 14 08 
# RpnCalc_handle_if_true_1_3
# 8145d Instruction { source: "stack_needed <- 0n2/0x02u8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x02=2)], resolved: None }
00 2c 02 
# 81460 Instruction { source: "goto RpnCalc_handle_if_end_0", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_0)], resolved: None }
40 af 14 08 
# RpnCalc_handle_if_else_1_4
# 81464 Instruction { source: "t5 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 81467 Instruction { source: "t6 <- 0n42/0x2au8 ", opcode: LoadImm8, args: [Register(0x24), Constant8(0x2a=42)], resolved: None }
00 24 2a 
# 8146a Instruction { source: "if t5 == t6 then 'RpnCalc_handle_if_true_2_5' else 'RpnCalc_handle_if_else_2_6'", opcode: Cmp8, args: [Register(0x1c), Register(0x24)], resolved: None }
25 1c 24 
# 8146d Instruction { source: "if t5 == t6 then 'RpnCalc_handle_if_true_2_5' else 'RpnCalc_handle_if_else_2_6'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_2_5)], resolved: None }
42 75 14 08 
# 81471 Instruction { source: "if t5 == t6 then 'RpnCalc_handle_if_true_2_5' else 'RpnCalc_handle_if_else_2_6'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_2_6)], resolved: None }
40 7c 14 08 
# RpnCalc_handle_if_true_2_5
# 81475 Instruction { source: "stack_needed <- 0n2/0x02u8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x02=2)], resolved: None }
00 2c 02 
# 81478 Instruction { source: "goto RpnCalc_handle_if_end_0", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_0)], resolved: None }
40 af 14 08 
# RpnCalc_handle_if_else_2_6
# 8147c Instruction { source: "t7 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 8147f Instruction { source: "t8 <- 0n47/0x2fu8 ", opcode: LoadImm8, args: [Register(0x24), Constant8(0x2f=47)], resolved: None }
00 24 2f 
# 81482 Instruction { source: "if t7 == t8 then 'RpnCalc_handle_if_true_3_7' else 'RpnCalc_handle_if_else_3_8'", opcode: Cmp8, args: [Register(0x1c), Register(0x24)], resolved: None }
25 1c 24 
# 81485 Instruction { source: "if t7 == t8 then 'RpnCalc_handle_if_true_3_7' else 'RpnCalc_handle_if_else_3_8'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_3_7)], resolved: None }
42 8d 14 08 
# 81489 Instruction { source: "if t7 == t8 then 'RpnCalc_handle_if_true_3_7' else 'RpnCalc_handle_if_else_3_8'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_3_8)], resolved: None }
40 94 14 08 
# RpnCalc_handle_if_true_3_7
# 8148d Instruction { source: "stack_needed <- 0n2/0x02u8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x02=2)], resolved: None }
00 2c 02 
# 81490 Instruction { source: "goto RpnCalc_handle_if_end_0", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_0)], resolved: None }
40 af 14 08 
# RpnCalc_handle_if_else_3_8
# 81494 Instruction { source: "t9 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 81497 Instruction { source: "t10 <- 0n115/0x73u8 ", opcode: LoadImm8, args: [Register(0x24), Constant8(0x73=115)], resolved: None }
00 24 73 
# 8149a Instruction { source: "if t9 == t10 then 'RpnCalc_handle_if_true_4_9' else 'RpnCalc_handle_if_else_4_10'", opcode: Cmp8, args: [Register(0x1c), Register(0x24)], resolved: None }
25 1c 24 
# 8149d Instruction { source: "if t9 == t10 then 'RpnCalc_handle_if_true_4_9' else 'RpnCalc_handle_if_else_4_10'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_4_9)], resolved: None }
42 a5 14 08 
# 814a1 Instruction { source: "if t9 == t10 then 'RpnCalc_handle_if_true_4_9' else 'RpnCalc_handle_if_else_4_10'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_4_10)], resolved: None }
40 ac 14 08 
# RpnCalc_handle_if_true_4_9
# 814a5 Instruction { source: "stack_needed <- 0n2/0x02u8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x02=2)], resolved: None }
00 2c 02 
# 814a8 Instruction { source: "goto RpnCalc_handle_if_end_0", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_0)], resolved: None }
40 af 14 08 
# RpnCalc_handle_if_else_4_10
# 814ac Instruction { source: "stack_needed <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x00=0)], resolved: None }
00 2c 00 
# RpnCalc_handle_if_end_0
# 814af Instruction { source: "t11 <- stack_needed U8", opcode: Copy8, args: [Register(0x2c), Register(0x24)], resolved: None }
16 2c 24 
# 814b2 Instruction { source: "t12 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x2e), Constant8(0x00=0)], resolved: None }
00 2e 00 
# 814b5 Instruction { source: "if t11 > t12 then 'RpnCalc_handle_if_true_0_12' else 'RpnCalc_handle_if_else_0_13'", opcode: Cmp8, args: [Register(0x24), Register(0x2e)], resolved: None }
25 24 2e 
# 814b8 Instruction { source: "if t11 > t12 then 'RpnCalc_handle_if_true_0_12' else 'RpnCalc_handle_if_else_0_13'", opcode: JcImm, args: [Label24(RpnCalc_handle_if_else_0_13)], resolved: None }
41 dc 14 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t11 > t12 then 'RpnCalc_handle_if_true_0_12' else 'RpnCalc_handle_if_else_0_13'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_true_0_12)], resolved: None }
# RpnCalc_handle_if_true_0_12
# 814bc Instruction { source: "t14 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x18)], resolved: None }
81 18 18 
# 814bf Instruction { source: "Arg0[c]=t14 None <= call RpnCalc_push_pending(t14,)", opcode: Copy32, args: [Register(0x18), Register(0x00)], resolved: None }
81 18 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {60, 61, 62, 63, 64, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219}
# Registers to save: []
# 814c2 Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 814c8 Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c d2 14 08 00 
# 814ce Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: JmpImm, args: [Label24(:RpnCalc_push_pending)], resolved: None }
40 a0 1c 08 
# 814d2 Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 814d8 Instruction { source: "goto RpnCalc_handle_if_end_11", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_11)], resolved: None }
40 dc 14 08 
# RpnCalc_handle_if_else_0_13
# RpnCalc_handle_if_end_11
# 814dc Instruction { source: "t16 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x20)], resolved: None }
81 20 20 
# 814df Instruction { source: "t17 <- 0n64/0x00000040u32 ", opcode: LoadImm32, args: [Register(0x28), Constant32(0x00000040=64)], resolved: None }
80 28 40 00 00 00 
# 814e5 Instruction { source: "t15 <- t16 Add t17", opcode: Add32NoCarryIn, args: [Register(0x20), Register(0x28), Register(0x28)], resolved: None }
a0 20 28 28 
# 814e9 Instruction { source: "stack_count_usize <- mem[t15] U32", opcode: Load32, args: [Register(0x28), Register(0x28)], resolved: None }
90 28 28 
# 814ec Instruction { source: "stack_count <- stack_count_usize[0x00..0x01] U8", opcode: Copy8, args: [Register(0x28), Register(0x24)], resolved: None }
16 28 24 
# 814ef Instruction { source: "t18 <- stack_needed U8", opcode: Copy8, args: [Register(0x2c), Register(0x2c)], resolved: None }
16 2c 2c 
# 814f2 Instruction { source: "t19 <- stack_count U8", opcode: Copy8, args: [Register(0x24), Register(0x24)], resolved: None }
16 24 24 
# 814f5 Instruction { source: "if t18 > t19 then 'RpnCalc_handle_if_true_0_15' else 'RpnCalc_handle_if_else_0_16'", opcode: Cmp8, args: [Register(0x2c), Register(0x24)], resolved: None }
25 2c 24 
# 814f8 Instruction { source: "if t18 > t19 then 'RpnCalc_handle_if_true_0_15' else 'RpnCalc_handle_if_else_0_16'", opcode: JcImm, args: [Label24(RpnCalc_handle_if_else_0_16)], resolved: None }
41 1c 15 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t18 > t19 then 'RpnCalc_handle_if_true_0_15' else 'RpnCalc_handle_if_else_0_16'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_true_0_15)], resolved: None }
# RpnCalc_handle_if_true_0_15
# 814fc Instruction { source: "t20 <- 0n69/0x45u8 ", opcode: LoadImm8, args: [Register(0x1d), Constant8(0x45=69)], resolved: None }
00 1d 45 
# 814ff Instruction { source: "ttyout <- t20", opcode: TtyOut, args: [Register(0x1d)], resolved: None }
13 1d 
# 81501 Instruction { source: "t21 <- 0n82/0x52u8 ", opcode: LoadImm8, args: [Register(0x1d), Constant8(0x52=82)], resolved: None }
00 1d 52 
# 81504 Instruction { source: "ttyout <- t21", opcode: TtyOut, args: [Register(0x1d)], resolved: None }
13 1d 
# 81506 Instruction { source: "t22 <- 0n82/0x52u8 ", opcode: LoadImm8, args: [Register(0x1d), Constant8(0x52=82)], resolved: None }
00 1d 52 
# 81509 Instruction { source: "ttyout <- t22", opcode: TtyOut, args: [Register(0x1d)], resolved: None }
13 1d 
# 8150b Instruction { source: "t23 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x1d), Constant8(0x0a=10)], resolved: None }
00 1d 0a 
# 8150e Instruction { source: "ttyout <- t23", opcode: TtyOut, args: [Register(0x1d)], resolved: None }
13 1d 
# 81510 Instruction { source: "t24 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x1d), Constant8(0x01=1)], resolved: None }
00 1d 01 
# 81513 Instruction { source: "return Some(t24)", opcode: Copy8, args: [Register(0x1d), Register(0x00)], resolved: None }
16 1d 00 
# 81516 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81518 Instruction { source: "goto RpnCalc_handle_if_end_14", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_14)], resolved: None }
40 1c 15 08 
# RpnCalc_handle_if_else_0_16
# RpnCalc_handle_if_end_14
# 8151c Instruction { source: "t25 <- stack_needed U8", opcode: Copy8, args: [Register(0x2c), Register(0x2c)], resolved: None }
16 2c 2c 
# 8151f Instruction { source: "t26 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x2e), Constant8(0x00=0)], resolved: None }
00 2e 00 
# 81522 Instruction { source: "if t25 > t26 then 'RpnCalc_handle_if_true_0_18' else 'RpnCalc_handle_if_else_0_19'", opcode: Cmp8, args: [Register(0x2c), Register(0x2e)], resolved: None }
25 2c 2e 
# 81525 Instruction { source: "if t25 > t26 then 'RpnCalc_handle_if_true_0_18' else 'RpnCalc_handle_if_else_0_19'", opcode: JcImm, args: [Label24(RpnCalc_handle_if_else_0_19)], resolved: None }
41 4c 15 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t25 > t26 then 'RpnCalc_handle_if_true_0_18' else 'RpnCalc_handle_if_else_0_19'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_true_0_18)], resolved: None }
# RpnCalc_handle_if_true_0_18
# 81529 Instruction { source: "t27 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x10)], resolved: None }
81 20 10 
# 8152c Instruction { source: "Arg0[s]=t27 Some(a) <= call stack_pop(t27,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199}
# Registers to save: []
# 8152f Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81535 Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 3f 15 08 00 
# 8153b Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: JmpImm, args: [Label24(:stack_pop)], resolved: None }
40 ce 2c 08 
# 8153f Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81545 Instruction { source: "Some(a) <= call stack_pop(t27,)", opcode: Copy32, args: [Register(0x00), Register(0x10)], resolved: None }
81 00 10 
# 81548 Instruction { source: "goto RpnCalc_handle_if_end_17", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_17)], resolved: None }
40 4c 15 08 
# RpnCalc_handle_if_else_0_19
# RpnCalc_handle_if_end_17
# 8154c Instruction { source: "t28 <- stack_needed U8", opcode: Copy8, args: [Register(0x2c), Register(0x2c)], resolved: None }
16 2c 2c 
# 8154f Instruction { source: "t29 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x2e), Constant8(0x01=1)], resolved: None }
00 2e 01 
# 81552 Instruction { source: "if t28 > t29 then 'RpnCalc_handle_if_true_0_21' else 'RpnCalc_handle_if_else_0_22'", opcode: Cmp8, args: [Register(0x2c), Register(0x2e)], resolved: None }
25 2c 2e 
# 81555 Instruction { source: "if t28 > t29 then 'RpnCalc_handle_if_true_0_21' else 'RpnCalc_handle_if_else_0_22'", opcode: JcImm, args: [Label24(RpnCalc_handle_if_else_0_22)], resolved: None }
41 7c 15 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t28 > t29 then 'RpnCalc_handle_if_true_0_21' else 'RpnCalc_handle_if_else_0_22'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_true_0_21)], resolved: None }
# RpnCalc_handle_if_true_0_21
# 81559 Instruction { source: "t30 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x14)], resolved: None }
81 20 14 
# 8155c Instruction { source: "Arg0[s]=t30 Some(b) <= call stack_pop(t30,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199}
# Registers to save: []
# 8155f Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81565 Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 6f 15 08 00 
# 8156b Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: JmpImm, args: [Label24(:stack_pop)], resolved: None }
40 ce 2c 08 
# 8156f Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81575 Instruction { source: "Some(b) <= call stack_pop(t30,)", opcode: Copy32, args: [Register(0x00), Register(0x14)], resolved: None }
81 00 14 
# 81578 Instruction { source: "goto RpnCalc_handle_if_end_20", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_20)], resolved: None }
40 7c 15 08 
# RpnCalc_handle_if_else_0_22
# RpnCalc_handle_if_end_20
# 8157c Instruction { source: "t31 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 8157f Instruction { source: "t32 <- 0n43/0x2bu8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x2b=43)], resolved: None }
00 2c 2b 
# 81582 Instruction { source: "if t31 == t32 then 'RpnCalc_handle_if_true_0_24' else 'RpnCalc_handle_if_else_0_25'", opcode: Cmp8, args: [Register(0x1c), Register(0x2c)], resolved: None }
25 1c 2c 
# 81585 Instruction { source: "if t31 == t32 then 'RpnCalc_handle_if_true_0_24' else 'RpnCalc_handle_if_else_0_25'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_0_24)], resolved: None }
42 8d 15 08 
# 81589 Instruction { source: "if t31 == t32 then 'RpnCalc_handle_if_true_0_24' else 'RpnCalc_handle_if_else_0_25'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_0_25)], resolved: None }
40 46 16 08 
# RpnCalc_handle_if_true_0_24
# 8158d Instruction { source: "t33 <- b U32", opcode: Copy32, args: [Register(0x14), Register(0x14)], resolved: None }
81 14 14 
# 81590 Instruction { source: "t34 <- a U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 81593 Instruction { source: "sum <- t33 Add t34", opcode: Add32NoCarryIn, args: [Register(0x14), Register(0x10), Register(0x10)], resolved: None }
a0 14 10 10 
# 81597 Instruction { source: "t36 <- sum U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 8159a Instruction { source: "Arg0[a]=t36 None <= call print_dec32(t36,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 156, 157, 158, 159, 160, 161, 162, 176, 177, 178, 179, 180, 184, 185, 186, 187, 188, 189, 190, 191, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255}
# Registers to save: [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47]
# 8159d Instruction { source: "Saving reg0x2f before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x2f)], resolved: None }
14 2f 
# 8159f Instruction { source: "Saving reg0x2e before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x2e)], resolved: None }
14 2e 
# 815a1 Instruction { source: "Saving reg0x2d before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x2d)], resolved: None }
14 2d 
# 815a3 Instruction { source: "Saving reg0x2c before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x2c)], resolved: None }
14 2c 
# 815a5 Instruction { source: "Saving reg0x2b before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x2b)], resolved: None }
14 2b 
# 815a7 Instruction { source: "Saving reg0x2a before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x2a)], resolved: None }
14 2a 
# 815a9 Instruction { source: "Saving reg0x29 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x29)], resolved: None }
14 29 
# 815ab Instruction { source: "Saving reg0x28 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x28)], resolved: None }
14 28 
# 815ad Instruction { source: "Saving reg0x24 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x24)], resolved: None }
14 24 
# 815af Instruction { source: "Saving reg0x23 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x23)], resolved: None }
14 23 
# 815b1 Instruction { source: "Saving reg0x22 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x22)], resolved: None }
14 22 
# 815b3 Instruction { source: "Saving reg0x21 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x21)], resolved: None }
14 21 
# 815b5 Instruction { source: "Saving reg0x20 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x20)], resolved: None }
14 20 
# 815b7 Instruction { source: "Saving reg0x1d before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x1d)], resolved: None }
14 1d 
# 815b9 Instruction { source: "Saving reg0x1c before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x1c)], resolved: None }
14 1c 
# 815bb Instruction { source: "Saving reg0x1a before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x1a)], resolved: None }
14 1a 
# 815bd Instruction { source: "Saving reg0x19 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x19)], resolved: None }
14 19 
# 815bf Instruction { source: "Saving reg0x18 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x18)], resolved: None }
14 18 
# 815c1 Instruction { source: "Saving reg0x17 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x17)], resolved: None }
14 17 
# 815c3 Instruction { source: "Saving reg0x16 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x16)], resolved: None }
14 16 
# 815c5 Instruction { source: "Saving reg0x15 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x15)], resolved: None }
14 15 
# 815c7 Instruction { source: "Saving reg0x14 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x14)], resolved: None }
14 14 
# 815c9 Instruction { source: "Saving reg0x13 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x13)], resolved: None }
14 13 
# 815cb Instruction { source: "Saving reg0x12 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x12)], resolved: None }
14 12 
# 815cd Instruction { source: "Saving reg0x11 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x11)], resolved: None }
14 11 
# 815cf Instruction { source: "Saving reg0x10 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x10)], resolved: None }
14 10 
# 815d1 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 815d7 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c e1 15 08 00 
# 815dd Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: JmpImm, args: [Label24(:print_dec32)], resolved: None }
40 0d 28 08 
# 815e1 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 815e7 Instruction { source: "Restoring reg0x10 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x10)], resolved: None }
15 10 
# 815e9 Instruction { source: "Restoring reg0x11 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x11)], resolved: None }
15 11 
# 815eb Instruction { source: "Restoring reg0x12 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x12)], resolved: None }
15 12 
# 815ed Instruction { source: "Restoring reg0x13 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x13)], resolved: None }
15 13 
# 815ef Instruction { source: "Restoring reg0x14 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x14)], resolved: None }
15 14 
# 815f1 Instruction { source: "Restoring reg0x15 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x15)], resolved: None }
15 15 
# 815f3 Instruction { source: "Restoring reg0x16 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x16)], resolved: None }
15 16 
# 815f5 Instruction { source: "Restoring reg0x17 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x17)], resolved: None }
15 17 
# 815f7 Instruction { source: "Restoring reg0x18 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x18)], resolved: None }
15 18 
# 815f9 Instruction { source: "Restoring reg0x19 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x19)], resolved: None }
15 19 
# 815fb Instruction { source: "Restoring reg0x1a after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x1a)], resolved: None }
15 1a 
# 815fd Instruction { source: "Restoring reg0x1c after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x1c)], resolved: None }
15 1c 
# 815ff Instruction { source: "Restoring reg0x1d after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x1d)], resolved: None }
15 1d 
# 81601 Instruction { source: "Restoring reg0x20 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x20)], resolved: None }
15 20 
# 81603 Instruction { source: "Restoring reg0x21 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x21)], resolved: None }
15 21 
# 81605 Instruction { source: "Restoring reg0x22 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x22)], resolved: None }
15 22 
# 81607 Instruction { source: "Restoring reg0x23 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x23)], resolved: None }
15 23 
# 81609 Instruction { source: "Restoring reg0x24 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x24)], resolved: None }
15 24 
# 8160b Instruction { source: "Restoring reg0x28 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x28)], resolved: None }
15 28 
# 8160d Instruction { source: "Restoring reg0x29 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x29)], resolved: None }
15 29 
# 8160f Instruction { source: "Restoring reg0x2a after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x2a)], resolved: None }
15 2a 
# 81611 Instruction { source: "Restoring reg0x2b after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x2b)], resolved: None }
15 2b 
# 81613 Instruction { source: "Restoring reg0x2c after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x2c)], resolved: None }
15 2c 
# 81615 Instruction { source: "Restoring reg0x2d after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x2d)], resolved: None }
15 2d 
# 81617 Instruction { source: "Restoring reg0x2e after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x2e)], resolved: None }
15 2e 
# 81619 Instruction { source: "Restoring reg0x2f after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x2f)], resolved: None }
15 2f 
# 8161b Instruction { source: "t37 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x0a=10)], resolved: None }
00 2d 0a 
# 8161e Instruction { source: "ttyout <- t37", opcode: TtyOut, args: [Register(0x2d)], resolved: None }
13 2d 
# 81620 Instruction { source: "t39 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x14)], resolved: None }
81 20 14 
# 81623 Instruction { source: "t40 <- sum U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 81626 Instruction { source: "Arg0[s]=t39 None <= call stack_push(t39,t40,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# 81629 Instruction { source: "Arg1[n]=t40 None <= call stack_push(t39,t40,)", opcode: Copy32, args: [Register(0x10), Register(0x04)], resolved: None }
81 10 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219}
# Registers to save: []
# 8162c Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81632 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 3c 16 08 00 
# 81638 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 4a 2d 08 
# 8163c Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81642 Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 50 1c 08 
# RpnCalc_handle_if_else_0_25
# 81646 Instruction { source: "t41 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 81649 Instruction { source: "t42 <- 0n45/0x2du8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x2d=45)], resolved: None }
00 2c 2d 
# 8164c Instruction { source: "if t41 == t42 then 'RpnCalc_handle_if_true_1_26' else 'RpnCalc_handle_if_else_1_27'", opcode: Cmp8, args: [Register(0x1c), Register(0x2c)], resolved: None }
25 1c 2c 
# 8164f Instruction { source: "if t41 == t42 then 'RpnCalc_handle_if_true_1_26' else 'RpnCalc_handle_if_else_1_27'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_1_26)], resolved: None }
42 57 16 08 
# 81653 Instruction { source: "if t41 == t42 then 'RpnCalc_handle_if_true_1_26' else 'RpnCalc_handle_if_else_1_27'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_1_27)], resolved: None }
40 21 17 08 
# RpnCalc_handle_if_true_1_26
# 81657 Instruction { source: "t43 <- b U32", opcode: Copy32, args: [Register(0x14), Register(0x14)], resolved: None }
81 14 14 
# 8165a Instruction { source: "t44 <- a U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 8165d Instruction { source: "diff <- t43 Subtract t44", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# 81660 Instruction { source: "diff <- t43 Subtract t44", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 81662 Instruction { source: "diff <- t43 Subtract t44", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 81664 Instruction { source: "diff <- t43 Subtract t44", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 81666 Instruction { source: "diff <- t43 Subtract t44", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 81668 Instruction { source: "diff <- t43 Subtract t44", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 8166e Instruction { source: "diff <- t43 Subtract t44", opcode: Add32NoCarryIn, args: [Register(0x14), Register(0x00), Register(0x10)], resolved: None }
a0 14 00 10 
# 81672 Instruction { source: "t46 <- diff U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 81675 Instruction { source: "Arg0[a]=t46 None <= call print_dec32(t46,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 156, 157, 158, 159, 160, 161, 162, 176, 177, 178, 179, 180, 184, 185, 186, 187, 188, 189, 190, 191, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255}
# Registers to save: [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47]
# 81678 Instruction { source: "Saving reg0x2f before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x2f)], resolved: None }
14 2f 
# 8167a Instruction { source: "Saving reg0x2e before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x2e)], resolved: None }
14 2e 
# 8167c Instruction { source: "Saving reg0x2d before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x2d)], resolved: None }
14 2d 
# 8167e Instruction { source: "Saving reg0x2c before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x2c)], resolved: None }
14 2c 
# 81680 Instruction { source: "Saving reg0x2b before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x2b)], resolved: None }
14 2b 
# 81682 Instruction { source: "Saving reg0x2a before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x2a)], resolved: None }
14 2a 
# 81684 Instruction { source: "Saving reg0x29 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x29)], resolved: None }
14 29 
# 81686 Instruction { source: "Saving reg0x28 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x28)], resolved: None }
14 28 
# 81688 Instruction { source: "Saving reg0x24 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x24)], resolved: None }
14 24 
# 8168a Instruction { source: "Saving reg0x23 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x23)], resolved: None }
14 23 
# 8168c Instruction { source: "Saving reg0x22 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x22)], resolved: None }
14 22 
# 8168e Instruction { source: "Saving reg0x21 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x21)], resolved: None }
14 21 
# 81690 Instruction { source: "Saving reg0x20 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x20)], resolved: None }
14 20 
# 81692 Instruction { source: "Saving reg0x1d before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x1d)], resolved: None }
14 1d 
# 81694 Instruction { source: "Saving reg0x1c before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x1c)], resolved: None }
14 1c 
# 81696 Instruction { source: "Saving reg0x1a before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x1a)], resolved: None }
14 1a 
# 81698 Instruction { source: "Saving reg0x19 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x19)], resolved: None }
14 19 
# 8169a Instruction { source: "Saving reg0x18 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x18)], resolved: None }
14 18 
# 8169c Instruction { source: "Saving reg0x17 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x17)], resolved: None }
14 17 
# 8169e Instruction { source: "Saving reg0x16 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x16)], resolved: None }
14 16 
# 816a0 Instruction { source: "Saving reg0x15 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x15)], resolved: None }
14 15 
# 816a2 Instruction { source: "Saving reg0x14 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x14)], resolved: None }
14 14 
# 816a4 Instruction { source: "Saving reg0x13 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x13)], resolved: None }
14 13 
# 816a6 Instruction { source: "Saving reg0x12 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x12)], resolved: None }
14 12 
# 816a8 Instruction { source: "Saving reg0x11 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x11)], resolved: None }
14 11 
# 816aa Instruction { source: "Saving reg0x10 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x10)], resolved: None }
14 10 
# 816ac Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 816b2 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c bc 16 08 00 
# 816b8 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: JmpImm, args: [Label24(:print_dec32)], resolved: None }
40 0d 28 08 
# 816bc Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 816c2 Instruction { source: "Restoring reg0x10 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x10)], resolved: None }
15 10 
# 816c4 Instruction { source: "Restoring reg0x11 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x11)], resolved: None }
15 11 
# 816c6 Instruction { source: "Restoring reg0x12 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x12)], resolved: None }
15 12 
# 816c8 Instruction { source: "Restoring reg0x13 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x13)], resolved: None }
15 13 
# 816ca Instruction { source: "Restoring reg0x14 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x14)], resolved: None }
15 14 
# 816cc Instruction { source: "Restoring reg0x15 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x15)], resolved: None }
15 15 
# 816ce Instruction { source: "Restoring reg0x16 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x16)], resolved: None }
15 16 
# 816d0 Instruction { source: "Restoring reg0x17 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x17)], resolved: None }
15 17 
# 816d2 Instruction { source: "Restoring reg0x18 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x18)], resolved: None }
15 18 
# 816d4 Instruction { source: "Restoring reg0x19 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x19)], resolved: None }
15 19 
# 816d6 Instruction { source: "Restoring reg0x1a after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x1a)], resolved: None }
15 1a 
# 816d8 Instruction { source: "Restoring reg0x1c after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x1c)], resolved: None }
15 1c 
# 816da Instruction { source: "Restoring reg0x1d after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x1d)], resolved: None }
15 1d 
# 816dc Instruction { source: "Restoring reg0x20 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x20)], resolved: None }
15 20 
# 816de Instruction { source: "Restoring reg0x21 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x21)], resolved: None }
15 21 
# 816e0 Instruction { source: "Restoring reg0x22 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x22)], resolved: None }
15 22 
# 816e2 Instruction { source: "Restoring reg0x23 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x23)], resolved: None }
15 23 
# 816e4 Instruction { source: "Restoring reg0x24 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x24)], resolved: None }
15 24 
# 816e6 Instruction { source: "Restoring reg0x28 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x28)], resolved: None }
15 28 
# 816e8 Instruction { source: "Restoring reg0x29 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x29)], resolved: None }
15 29 
# 816ea Instruction { source: "Restoring reg0x2a after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x2a)], resolved: None }
15 2a 
# 816ec Instruction { source: "Restoring reg0x2b after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x2b)], resolved: None }
15 2b 
# 816ee Instruction { source: "Restoring reg0x2c after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x2c)], resolved: None }
15 2c 
# 816f0 Instruction { source: "Restoring reg0x2d after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x2d)], resolved: None }
15 2d 
# 816f2 Instruction { source: "Restoring reg0x2e after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x2e)], resolved: None }
15 2e 
# 816f4 Instruction { source: "Restoring reg0x2f after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x2f)], resolved: None }
15 2f 
# 816f6 Instruction { source: "t47 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x0a=10)], resolved: None }
00 2d 0a 
# 816f9 Instruction { source: "ttyout <- t47", opcode: TtyOut, args: [Register(0x2d)], resolved: None }
13 2d 
# 816fb Instruction { source: "t49 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x14)], resolved: None }
81 20 14 
# 816fe Instruction { source: "t50 <- diff U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 81701 Instruction { source: "Arg0[s]=t49 None <= call stack_push(t49,t50,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# 81704 Instruction { source: "Arg1[n]=t50 None <= call stack_push(t49,t50,)", opcode: Copy32, args: [Register(0x10), Register(0x04)], resolved: None }
81 10 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219}
# Registers to save: []
# 81707 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8170d Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 17 17 08 00 
# 81713 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 4a 2d 08 
# 81717 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8171d Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 50 1c 08 
# RpnCalc_handle_if_else_1_27
# 81721 Instruction { source: "t51 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 81724 Instruction { source: "t52 <- 0n42/0x2au8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x2a=42)], resolved: None }
00 2c 2a 
# 81727 Instruction { source: "if t51 == t52 then 'RpnCalc_handle_if_true_2_28' else 'RpnCalc_handle_if_else_2_29'", opcode: Cmp8, args: [Register(0x1c), Register(0x2c)], resolved: None }
25 1c 2c 
# 8172a Instruction { source: "if t51 == t52 then 'RpnCalc_handle_if_true_2_28' else 'RpnCalc_handle_if_else_2_29'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_2_28)], resolved: None }
42 32 17 08 
# 8172e Instruction { source: "if t51 == t52 then 'RpnCalc_handle_if_true_2_28' else 'RpnCalc_handle_if_else_2_29'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_2_29)], resolved: None }
40 32 18 08 
# RpnCalc_handle_if_true_2_28
# 81732 Instruction { source: "t53 <- b U32", opcode: Copy32, args: [Register(0x14), Register(0x14)], resolved: None }
81 14 14 
# 81735 Instruction { source: "t54 <- a U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 81738 Instruction { source: "Arg0[a]=t53 Some(product) <= call mul32_32(t53,t54,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# 8173b Instruction { source: "Arg1[b]=t54 Some(product) <= call mul32_32(t53,t54,)", opcode: Copy32, args: [Register(0x10), Register(0x04)], resolved: None }
81 10 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255}
# Registers to save: [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]
# 8173e Instruction { source: "Saving reg0x1a before Some(product) <= call mul32_32(t53,t54,)", opcode: Push8, args: [Register(0x1a)], resolved: None }
14 1a 
# 81740 Instruction { source: "Saving reg0x19 before Some(product) <= call mul32_32(t53,t54,)", opcode: Push8, args: [Register(0x19)], resolved: None }
14 19 
# 81742 Instruction { source: "Saving reg0x18 before Some(product) <= call mul32_32(t53,t54,)", opcode: Push8, args: [Register(0x18)], resolved: None }
14 18 
# 81744 Instruction { source: "Saving reg0x17 before Some(product) <= call mul32_32(t53,t54,)", opcode: Push8, args: [Register(0x17)], resolved: None }
14 17 
# 81746 Instruction { source: "Saving reg0x16 before Some(product) <= call mul32_32(t53,t54,)", opcode: Push8, args: [Register(0x16)], resolved: None }
14 16 
# 81748 Instruction { source: "Saving reg0x15 before Some(product) <= call mul32_32(t53,t54,)", opcode: Push8, args: [Register(0x15)], resolved: None }
14 15 
# 8174a Instruction { source: "Saving reg0x14 before Some(product) <= call mul32_32(t53,t54,)", opcode: Push8, args: [Register(0x14)], resolved: None }
14 14 
# 8174c Instruction { source: "Saving reg0x13 before Some(product) <= call mul32_32(t53,t54,)", opcode: Push8, args: [Register(0x13)], resolved: None }
14 13 
# 8174e Instruction { source: "Saving reg0x12 before Some(product) <= call mul32_32(t53,t54,)", opcode: Push8, args: [Register(0x12)], resolved: None }
14 12 
# 81750 Instruction { source: "Saving reg0x11 before Some(product) <= call mul32_32(t53,t54,)", opcode: Push8, args: [Register(0x11)], resolved: None }
14 11 
# 81752 Instruction { source: "Saving reg0x10 before Some(product) <= call mul32_32(t53,t54,)", opcode: Push8, args: [Register(0x10)], resolved: None }
14 10 
# 81754 Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8175a Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 64 17 08 00 
# 81760 Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: JmpImm, args: [Label24(:mul32_32)], resolved: None }
40 10 25 08 
# 81764 Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8176a Instruction { source: "Restoring reg0x10 after Some(product) <= call mul32_32(t53,t54,)", opcode: Pop8, args: [Register(0x10)], resolved: None }
15 10 
# 8176c Instruction { source: "Restoring reg0x11 after Some(product) <= call mul32_32(t53,t54,)", opcode: Pop8, args: [Register(0x11)], resolved: None }
15 11 
# 8176e Instruction { source: "Restoring reg0x12 after Some(product) <= call mul32_32(t53,t54,)", opcode: Pop8, args: [Register(0x12)], resolved: None }
15 12 
# 81770 Instruction { source: "Restoring reg0x13 after Some(product) <= call mul32_32(t53,t54,)", opcode: Pop8, args: [Register(0x13)], resolved: None }
15 13 
# 81772 Instruction { source: "Restoring reg0x14 after Some(product) <= call mul32_32(t53,t54,)", opcode: Pop8, args: [Register(0x14)], resolved: None }
15 14 
# 81774 Instruction { source: "Restoring reg0x15 after Some(product) <= call mul32_32(t53,t54,)", opcode: Pop8, args: [Register(0x15)], resolved: None }
15 15 
# 81776 Instruction { source: "Restoring reg0x16 after Some(product) <= call mul32_32(t53,t54,)", opcode: Pop8, args: [Register(0x16)], resolved: None }
15 16 
# 81778 Instruction { source: "Restoring reg0x17 after Some(product) <= call mul32_32(t53,t54,)", opcode: Pop8, args: [Register(0x17)], resolved: None }
15 17 
# 8177a Instruction { source: "Restoring reg0x18 after Some(product) <= call mul32_32(t53,t54,)", opcode: Pop8, args: [Register(0x18)], resolved: None }
15 18 
# 8177c Instruction { source: "Restoring reg0x19 after Some(product) <= call mul32_32(t53,t54,)", opcode: Pop8, args: [Register(0x19)], resolved: None }
15 19 
# 8177e Instruction { source: "Restoring reg0x1a after Some(product) <= call mul32_32(t53,t54,)", opcode: Pop8, args: [Register(0x1a)], resolved: None }
15 1a 
# 81780 Instruction { source: "Some(product) <= call mul32_32(t53,t54,)", opcode: Copy32, args: [Register(0x00), Register(0x10)], resolved: None }
81 00 10 
# 81783 Instruction { source: "t56 <- product U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 81786 Instruction { source: "Arg0[a]=t56 None <= call print_dec32(t56,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 156, 157, 158, 159, 160, 161, 162, 176, 177, 178, 179, 180, 184, 185, 186, 187, 188, 189, 190, 191, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255}
# Registers to save: [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47]
# 81789 Instruction { source: "Saving reg0x2f before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x2f)], resolved: None }
14 2f 
# 8178b Instruction { source: "Saving reg0x2e before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x2e)], resolved: None }
14 2e 
# 8178d Instruction { source: "Saving reg0x2d before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x2d)], resolved: None }
14 2d 
# 8178f Instruction { source: "Saving reg0x2c before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x2c)], resolved: None }
14 2c 
# 81791 Instruction { source: "Saving reg0x2b before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x2b)], resolved: None }
14 2b 
# 81793 Instruction { source: "Saving reg0x2a before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x2a)], resolved: None }
14 2a 
# 81795 Instruction { source: "Saving reg0x29 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x29)], resolved: None }
14 29 
# 81797 Instruction { source: "Saving reg0x28 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x28)], resolved: None }
14 28 
# 81799 Instruction { source: "Saving reg0x24 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x24)], resolved: None }
14 24 
# 8179b Instruction { source: "Saving reg0x23 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x23)], resolved: None }
14 23 
# 8179d Instruction { source: "Saving reg0x22 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x22)], resolved: None }
14 22 
# 8179f Instruction { source: "Saving reg0x21 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x21)], resolved: None }
14 21 
# 817a1 Instruction { source: "Saving reg0x20 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x20)], resolved: None }
14 20 
# 817a3 Instruction { source: "Saving reg0x1d before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x1d)], resolved: None }
14 1d 
# 817a5 Instruction { source: "Saving reg0x1c before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x1c)], resolved: None }
14 1c 
# 817a7 Instruction { source: "Saving reg0x1a before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x1a)], resolved: None }
14 1a 
# 817a9 Instruction { source: "Saving reg0x19 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x19)], resolved: None }
14 19 
# 817ab Instruction { source: "Saving reg0x18 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x18)], resolved: None }
14 18 
# 817ad Instruction { source: "Saving reg0x17 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x17)], resolved: None }
14 17 
# 817af Instruction { source: "Saving reg0x16 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x16)], resolved: None }
14 16 
# 817b1 Instruction { source: "Saving reg0x15 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x15)], resolved: None }
14 15 
# 817b3 Instruction { source: "Saving reg0x14 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x14)], resolved: None }
14 14 
# 817b5 Instruction { source: "Saving reg0x13 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x13)], resolved: None }
14 13 
# 817b7 Instruction { source: "Saving reg0x12 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x12)], resolved: None }
14 12 
# 817b9 Instruction { source: "Saving reg0x11 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x11)], resolved: None }
14 11 
# 817bb Instruction { source: "Saving reg0x10 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x10)], resolved: None }
14 10 
# 817bd Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 817c3 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c cd 17 08 00 
# 817c9 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: JmpImm, args: [Label24(:print_dec32)], resolved: None }
40 0d 28 08 
# 817cd Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 817d3 Instruction { source: "Restoring reg0x10 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x10)], resolved: None }
15 10 
# 817d5 Instruction { source: "Restoring reg0x11 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x11)], resolved: None }
15 11 
# 817d7 Instruction { source: "Restoring reg0x12 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x12)], resolved: None }
15 12 
# 817d9 Instruction { source: "Restoring reg0x13 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x13)], resolved: None }
15 13 
# 817db Instruction { source: "Restoring reg0x14 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x14)], resolved: None }
15 14 
# 817dd Instruction { source: "Restoring reg0x15 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x15)], resolved: None }
15 15 
# 817df Instruction { source: "Restoring reg0x16 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x16)], resolved: None }
15 16 
# 817e1 Instruction { source: "Restoring reg0x17 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x17)], resolved: None }
15 17 
# 817e3 Instruction { source: "Restoring reg0x18 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x18)], resolved: None }
15 18 
# 817e5 Instruction { source: "Restoring reg0x19 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x19)], resolved: None }
15 19 
# 817e7 Instruction { source: "Restoring reg0x1a after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x1a)], resolved: None }
15 1a 
# 817e9 Instruction { source: "Restoring reg0x1c after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x1c)], resolved: None }
15 1c 
# 817eb Instruction { source: "Restoring reg0x1d after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x1d)], resolved: None }
15 1d 
# 817ed Instruction { source: "Restoring reg0x20 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x20)], resolved: None }
15 20 
# 817ef Instruction { source: "Restoring reg0x21 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x21)], resolved: None }
15 21 
# 817f1 Instruction { source: "Restoring reg0x22 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x22)], resolved: None }
15 22 
# 817f3 Instruction { source: "Restoring reg0x23 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x23)], resolved: None }
15 23 
# 817f5 Instruction { source: "Restoring reg0x24 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x24)], resolved: None }
15 24 
# 817f7 Instruction { source: "Restoring reg0x28 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x28)], resolved: None }
15 28 
# 817f9 Instruction { source: "Restoring reg0x29 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x29)], resolved: None }
15 29 
# 817fb Instruction { source: "Restoring reg0x2a after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x2a)], resolved: None }
15 2a 
# 817fd Instruction { source: "Restoring reg0x2b after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x2b)], resolved: None }
15 2b 
# 817ff Instruction { source: "Restoring reg0x2c after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x2c)], resolved: None }
15 2c 
# 81801 Instruction { source: "Restoring reg0x2d after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x2d)], resolved: None }
15 2d 
# 81803 Instruction { source: "Restoring reg0x2e after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x2e)], resolved: None }
15 2e 
# 81805 Instruction { source: "Restoring reg0x2f after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x2f)], resolved: None }
15 2f 
# 81807 Instruction { source: "t57 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x0a=10)], resolved: None }
00 2d 0a 
# 8180a Instruction { source: "ttyout <- t57", opcode: TtyOut, args: [Register(0x2d)], resolved: None }
13 2d 
# 8180c Instruction { source: "t59 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x14)], resolved: None }
81 20 14 
# 8180f Instruction { source: "t60 <- product U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 81812 Instruction { source: "Arg0[s]=t59 None <= call stack_push(t59,t60,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# 81815 Instruction { source: "Arg1[n]=t60 None <= call stack_push(t59,t60,)", opcode: Copy32, args: [Register(0x10), Register(0x04)], resolved: None }
81 10 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219}
# Registers to save: []
# 81818 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8181e Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 28 18 08 00 
# 81824 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 4a 2d 08 
# 81828 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8182e Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 50 1c 08 
# RpnCalc_handle_if_else_2_29
# 81832 Instruction { source: "t61 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 81835 Instruction { source: "t62 <- 0n47/0x2fu8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x2f=47)], resolved: None }
00 2c 2f 
# 81838 Instruction { source: "if t61 == t62 then 'RpnCalc_handle_if_true_3_30' else 'RpnCalc_handle_if_else_3_31'", opcode: Cmp8, args: [Register(0x1c), Register(0x2c)], resolved: None }
25 1c 2c 
# 8183b Instruction { source: "if t61 == t62 then 'RpnCalc_handle_if_true_3_30' else 'RpnCalc_handle_if_else_3_31'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_3_30)], resolved: None }
42 43 18 08 
# 8183f Instruction { source: "if t61 == t62 then 'RpnCalc_handle_if_true_3_30' else 'RpnCalc_handle_if_else_3_31'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_3_31)], resolved: None }
40 53 19 08 
# RpnCalc_handle_if_true_3_30
# 81843 Instruction { source: "t63 <- b U32", opcode: Copy32, args: [Register(0x14), Register(0x14)], resolved: None }
81 14 14 
# 81846 Instruction { source: "t64 <- a U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 81849 Instruction { source: "Arg0[a]=t63 Some(quotient) <= call div32(t63,t64,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# 8184c Instruction { source: "Arg1[b]=t64 Some(quotient) <= call div32(t63,t64,)", opcode: Copy32, args: [Register(0x10), Register(0x04)], resolved: None }
81 10 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 168, 169, 170, 171, 172, 173, 174, 175, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241}
# Registers to save: [28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47]
# 8184f Instruction { source: "Saving reg0x2f before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x2f)], resolved: None }
14 2f 
# 81851 Instruction { source: "Saving reg0x2e before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x2e)], resolved: None }
14 2e 
# 81853 Instruction { source: "Saving reg0x2d before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x2d)], resolved: None }
14 2d 
# 81855 Instruction { source: "Saving reg0x2c before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x2c)], resolved: None }
14 2c 
# 81857 Instruction { source: "Saving reg0x2b before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x2b)], resolved: None }
14 2b 
# 81859 Instruction { source: "Saving reg0x2a before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x2a)], resolved: None }
14 2a 
# 8185b Instruction { source: "Saving reg0x29 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x29)], resolved: None }
14 29 
# 8185d Instruction { source: "Saving reg0x28 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x28)], resolved: None }
14 28 
# 8185f Instruction { source: "Saving reg0x24 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x24)], resolved: None }
14 24 
# 81861 Instruction { source: "Saving reg0x23 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x23)], resolved: None }
14 23 
# 81863 Instruction { source: "Saving reg0x22 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x22)], resolved: None }
14 22 
# 81865 Instruction { source: "Saving reg0x21 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x21)], resolved: None }
14 21 
# 81867 Instruction { source: "Saving reg0x20 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x20)], resolved: None }
14 20 
# 81869 Instruction { source: "Saving reg0x1d before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x1d)], resolved: None }
14 1d 
# 8186b Instruction { source: "Saving reg0x1c before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x1c)], resolved: None }
14 1c 
# 8186d Instruction { source: "PseudoCall(Label24(:div32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81873 Instruction { source: "PseudoCall(Label24(:div32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 7d 18 08 00 
# 81879 Instruction { source: "PseudoCall(Label24(:div32))", opcode: JmpImm, args: [Label24(:div32)], resolved: None }
40 be 1f 08 
# 8187d Instruction { source: "PseudoCall(Label24(:div32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81883 Instruction { source: "Restoring reg0x1c after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x1c)], resolved: None }
15 1c 
# 81885 Instruction { source: "Restoring reg0x1d after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x1d)], resolved: None }
15 1d 
# 81887 Instruction { source: "Restoring reg0x20 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x20)], resolved: None }
15 20 
# 81889 Instruction { source: "Restoring reg0x21 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x21)], resolved: None }
15 21 
# 8188b Instruction { source: "Restoring reg0x22 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x22)], resolved: None }
15 22 
# 8188d Instruction { source: "Restoring reg0x23 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x23)], resolved: None }
15 23 
# 8188f Instruction { source: "Restoring reg0x24 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x24)], resolved: None }
15 24 
# 81891 Instruction { source: "Restoring reg0x28 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x28)], resolved: None }
15 28 
# 81893 Instruction { source: "Restoring reg0x29 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x29)], resolved: None }
15 29 
# 81895 Instruction { source: "Restoring reg0x2a after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x2a)], resolved: None }
15 2a 
# 81897 Instruction { source: "Restoring reg0x2b after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x2b)], resolved: None }
15 2b 
# 81899 Instruction { source: "Restoring reg0x2c after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x2c)], resolved: None }
15 2c 
# 8189b Instruction { source: "Restoring reg0x2d after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x2d)], resolved: None }
15 2d 
# 8189d Instruction { source: "Restoring reg0x2e after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x2e)], resolved: None }
15 2e 
# 8189f Instruction { source: "Restoring reg0x2f after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x2f)], resolved: None }
15 2f 
# 818a1 Instruction { source: "Some(quotient) <= call div32(t63,t64,)", opcode: Copy32, args: [Register(0x00), Register(0x10)], resolved: None }
81 00 10 
# 818a4 Instruction { source: "t66 <- quotient U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 818a7 Instruction { source: "Arg0[a]=t66 None <= call print_dec32(t66,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 156, 157, 158, 159, 160, 161, 162, 176, 177, 178, 179, 180, 184, 185, 186, 187, 188, 189, 190, 191, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255}
# Registers to save: [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47]
# 818aa Instruction { source: "Saving reg0x2f before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x2f)], resolved: None }
14 2f 
# 818ac Instruction { source: "Saving reg0x2e before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x2e)], resolved: None }
14 2e 
# 818ae Instruction { source: "Saving reg0x2d before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x2d)], resolved: None }
14 2d 
# 818b0 Instruction { source: "Saving reg0x2c before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x2c)], resolved: None }
14 2c 
# 818b2 Instruction { source: "Saving reg0x2b before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x2b)], resolved: None }
14 2b 
# 818b4 Instruction { source: "Saving reg0x2a before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x2a)], resolved: None }
14 2a 
# 818b6 Instruction { source: "Saving reg0x29 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x29)], resolved: None }
14 29 
# 818b8 Instruction { source: "Saving reg0x28 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x28)], resolved: None }
14 28 
# 818ba Instruction { source: "Saving reg0x24 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x24)], resolved: None }
14 24 
# 818bc Instruction { source: "Saving reg0x23 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x23)], resolved: None }
14 23 
# 818be Instruction { source: "Saving reg0x22 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x22)], resolved: None }
14 22 
# 818c0 Instruction { source: "Saving reg0x21 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x21)], resolved: None }
14 21 
# 818c2 Instruction { source: "Saving reg0x20 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x20)], resolved: None }
14 20 
# 818c4 Instruction { source: "Saving reg0x1d before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x1d)], resolved: None }
14 1d 
# 818c6 Instruction { source: "Saving reg0x1c before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x1c)], resolved: None }
14 1c 
# 818c8 Instruction { source: "Saving reg0x1a before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x1a)], resolved: None }
14 1a 
# 818ca Instruction { source: "Saving reg0x19 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x19)], resolved: None }
14 19 
# 818cc Instruction { source: "Saving reg0x18 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x18)], resolved: None }
14 18 
# 818ce Instruction { source: "Saving reg0x17 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x17)], resolved: None }
14 17 
# 818d0 Instruction { source: "Saving reg0x16 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x16)], resolved: None }
14 16 
# 818d2 Instruction { source: "Saving reg0x15 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x15)], resolved: None }
14 15 
# 818d4 Instruction { source: "Saving reg0x14 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x14)], resolved: None }
14 14 
# 818d6 Instruction { source: "Saving reg0x13 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x13)], resolved: None }
14 13 
# 818d8 Instruction { source: "Saving reg0x12 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x12)], resolved: None }
14 12 
# 818da Instruction { source: "Saving reg0x11 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x11)], resolved: None }
14 11 
# 818dc Instruction { source: "Saving reg0x10 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x10)], resolved: None }
14 10 
# 818de Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 818e4 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c ee 18 08 00 
# 818ea Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: JmpImm, args: [Label24(:print_dec32)], resolved: None }
40 0d 28 08 
# 818ee Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 818f4 Instruction { source: "Restoring reg0x10 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x10)], resolved: None }
15 10 
# 818f6 Instruction { source: "Restoring reg0x11 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x11)], resolved: None }
15 11 
# 818f8 Instruction { source: "Restoring reg0x12 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x12)], resolved: None }
15 12 
# 818fa Instruction { source: "Restoring reg0x13 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x13)], resolved: None }
15 13 
# 818fc Instruction { source: "Restoring reg0x14 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x14)], resolved: None }
15 14 
# 818fe Instruction { source: "Restoring reg0x15 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x15)], resolved: None }
15 15 
# 81900 Instruction { source: "Restoring reg0x16 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x16)], resolved: None }
15 16 
# 81902 Instruction { source: "Restoring reg0x17 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x17)], resolved: None }
15 17 
# 81904 Instruction { source: "Restoring reg0x18 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x18)], resolved: None }
15 18 
# 81906 Instruction { source: "Restoring reg0x19 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x19)], resolved: None }
15 19 
# 81908 Instruction { source: "Restoring reg0x1a after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x1a)], resolved: None }
15 1a 
# 8190a Instruction { source: "Restoring reg0x1c after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x1c)], resolved: None }
15 1c 
# 8190c Instruction { source: "Restoring reg0x1d after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x1d)], resolved: None }
15 1d 
# 8190e Instruction { source: "Restoring reg0x20 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x20)], resolved: None }
15 20 
# 81910 Instruction { source: "Restoring reg0x21 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x21)], resolved: None }
15 21 
# 81912 Instruction { source: "Restoring reg0x22 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x22)], resolved: None }
15 22 
# 81914 Instruction { source: "Restoring reg0x23 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x23)], resolved: None }
15 23 
# 81916 Instruction { source: "Restoring reg0x24 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x24)], resolved: None }
15 24 
# 81918 Instruction { source: "Restoring reg0x28 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x28)], resolved: None }
15 28 
# 8191a Instruction { source: "Restoring reg0x29 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x29)], resolved: None }
15 29 
# 8191c Instruction { source: "Restoring reg0x2a after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x2a)], resolved: None }
15 2a 
# 8191e Instruction { source: "Restoring reg0x2b after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x2b)], resolved: None }
15 2b 
# 81920 Instruction { source: "Restoring reg0x2c after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x2c)], resolved: None }
15 2c 
# 81922 Instruction { source: "Restoring reg0x2d after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x2d)], resolved: None }
15 2d 
# 81924 Instruction { source: "Restoring reg0x2e after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x2e)], resolved: None }
15 2e 
# 81926 Instruction { source: "Restoring reg0x2f after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x2f)], resolved: None }
15 2f 
# 81928 Instruction { source: "t67 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x0a=10)], resolved: None }
00 2d 0a 
# 8192b Instruction { source: "ttyout <- t67", opcode: TtyOut, args: [Register(0x2d)], resolved: None }
13 2d 
# 8192d Instruction { source: "t69 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x14)], resolved: None }
81 20 14 
# 81930 Instruction { source: "t70 <- quotient U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 81933 Instruction { source: "Arg0[s]=t69 None <= call stack_push(t69,t70,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# 81936 Instruction { source: "Arg1[n]=t70 None <= call stack_push(t69,t70,)", opcode: Copy32, args: [Register(0x10), Register(0x04)], resolved: None }
81 10 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219}
# Registers to save: []
# 81939 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8193f Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 49 19 08 00 
# 81945 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 4a 2d 08 
# 81949 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8194f Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 50 1c 08 
# RpnCalc_handle_if_else_3_31
# 81953 Instruction { source: "t71 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 81956 Instruction { source: "t72 <- 0n115/0x73u8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x73=115)], resolved: None }
00 2c 73 
# 81959 Instruction { source: "if t71 == t72 then 'RpnCalc_handle_if_true_4_32' else 'RpnCalc_handle_if_else_4_33'", opcode: Cmp8, args: [Register(0x1c), Register(0x2c)], resolved: None }
25 1c 2c 
# 8195c Instruction { source: "if t71 == t72 then 'RpnCalc_handle_if_true_4_32' else 'RpnCalc_handle_if_else_4_33'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_4_32)], resolved: None }
42 64 19 08 
# 81960 Instruction { source: "if t71 == t72 then 'RpnCalc_handle_if_true_4_32' else 'RpnCalc_handle_if_else_4_33'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_4_33)], resolved: None }
40 ac 19 08 
# RpnCalc_handle_if_true_4_32
# 81964 Instruction { source: "t74 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x18)], resolved: None }
81 20 18 
# 81967 Instruction { source: "t75 <- a U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 8196a Instruction { source: "Arg0[s]=t74 None <= call stack_push(t74,t75,)", opcode: Copy32, args: [Register(0x18), Register(0x00)], resolved: None }
81 18 00 
# 8196d Instruction { source: "Arg1[n]=t75 None <= call stack_push(t74,t75,)", opcode: Copy32, args: [Register(0x10), Register(0x04)], resolved: None }
81 10 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219}
# Registers to save: []
# 81970 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81976 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 80 19 08 00 
# 8197c Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 4a 2d 08 
# 81980 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81986 Instruction { source: "t77 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x10)], resolved: None }
81 20 10 
# 81989 Instruction { source: "t78 <- b U32", opcode: Copy32, args: [Register(0x14), Register(0x14)], resolved: None }
81 14 14 
# 8198c Instruction { source: "Arg0[s]=t77 None <= call stack_push(t77,t78,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# 8198f Instruction { source: "Arg1[n]=t78 None <= call stack_push(t77,t78,)", opcode: Copy32, args: [Register(0x14), Register(0x04)], resolved: None }
81 14 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219}
# Registers to save: []
# 81992 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81998 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c a2 19 08 00 
# 8199e Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 4a 2d 08 
# 819a2 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 819a8 Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 50 1c 08 
# RpnCalc_handle_if_else_4_33
# 819ac Instruction { source: "t79 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1d)], resolved: None }
16 1c 1d 
# 819af Instruction { source: "t80 <- 0n113/0x71u8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x71=113)], resolved: None }
00 2d 71 
# 819b2 Instruction { source: "if t79 == t80 then 'RpnCalc_handle_if_true_5_34' else 'RpnCalc_handle_if_else_5_35'", opcode: Cmp8, args: [Register(0x1d), Register(0x2d)], resolved: None }
25 1d 2d 
# 819b5 Instruction { source: "if t79 == t80 then 'RpnCalc_handle_if_true_5_34' else 'RpnCalc_handle_if_else_5_35'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_5_34)], resolved: None }
42 bd 19 08 
# 819b9 Instruction { source: "if t79 == t80 then 'RpnCalc_handle_if_true_5_34' else 'RpnCalc_handle_if_else_5_35'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_5_35)], resolved: None }
40 c9 19 08 
# RpnCalc_handle_if_true_5_34
# 819bd Instruction { source: "t81 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x1d), Constant8(0x00=0)], resolved: None }
00 1d 00 
# 819c0 Instruction { source: "return Some(t81)", opcode: Copy8, args: [Register(0x1d), Register(0x00)], resolved: None }
16 1d 00 
# 819c3 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 819c5 Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 50 1c 08 
# RpnCalc_handle_if_else_5_35
# 819c9 Instruction { source: "t82 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1d)], resolved: None }
16 1c 1d 
# 819cc Instruction { source: "t83 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x0a=10)], resolved: None }
00 2d 0a 
# 819cf Instruction { source: "if t82 == t83 then 'RpnCalc_handle_if_true_6_36' else 'RpnCalc_handle_if_else_6_37'", opcode: Cmp8, args: [Register(0x1d), Register(0x2d)], resolved: None }
25 1d 2d 
# 819d2 Instruction { source: "if t82 == t83 then 'RpnCalc_handle_if_true_6_36' else 'RpnCalc_handle_if_else_6_37'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_6_36)], resolved: None }
42 da 19 08 
# 819d6 Instruction { source: "if t82 == t83 then 'RpnCalc_handle_if_true_6_36' else 'RpnCalc_handle_if_else_6_37'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_6_37)], resolved: None }
40 fa 19 08 
# RpnCalc_handle_if_true_6_36
# 819da Instruction { source: "t85 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x10)], resolved: None }
81 18 10 
# 819dd Instruction { source: "Arg0[c]=t85 None <= call RpnCalc_push_pending(t85,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {60, 61, 62, 63, 64, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219}
# Registers to save: []
# 819e0 Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 819e6 Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c f0 19 08 00 
# 819ec Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: JmpImm, args: [Label24(:RpnCalc_push_pending)], resolved: None }
40 a0 1c 08 
# 819f0 Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 819f6 Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 50 1c 08 
# RpnCalc_handle_if_else_6_37
# 819fa Instruction { source: "t86 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1d)], resolved: None }
16 1c 1d 
# 819fd Instruction { source: "t87 <- 0n32/0x20u8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x20=32)], resolved: None }
00 2d 20 
# 81a00 Instruction { source: "if t86 == t87 then 'RpnCalc_handle_if_true_7_38' else 'RpnCalc_handle_if_else_7_39'", opcode: Cmp8, args: [Register(0x1d), Register(0x2d)], resolved: None }
25 1d 2d 
# 81a03 Instruction { source: "if t86 == t87 then 'RpnCalc_handle_if_true_7_38' else 'RpnCalc_handle_if_else_7_39'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_7_38)], resolved: None }
42 0b 1a 08 
# 81a07 Instruction { source: "if t86 == t87 then 'RpnCalc_handle_if_true_7_38' else 'RpnCalc_handle_if_else_7_39'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_7_39)], resolved: None }
40 2b 1a 08 
# RpnCalc_handle_if_true_7_38
# 81a0b Instruction { source: "t89 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x10)], resolved: None }
81 18 10 
# 81a0e Instruction { source: "Arg0[c]=t89 None <= call RpnCalc_push_pending(t89,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {60, 61, 62, 63, 64, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219}
# Registers to save: []
# 81a11 Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81a17 Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 21 1a 08 00 
# 81a1d Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: JmpImm, args: [Label24(:RpnCalc_push_pending)], resolved: None }
40 a0 1c 08 
# 81a21 Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81a27 Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 50 1c 08 
# RpnCalc_handle_if_else_7_39
# 81a2b Instruction { source: "t90 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1d)], resolved: None }
16 1c 1d 
# 81a2e Instruction { source: "t91 <- 0n99/0x63u8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x63=99)], resolved: None }
00 2d 63 
# 81a31 Instruction { source: "if t90 == t91 then 'RpnCalc_handle_if_true_8_40' else 'RpnCalc_handle_if_else_8_41'", opcode: Cmp8, args: [Register(0x1d), Register(0x2d)], resolved: None }
25 1d 2d 
# 81a34 Instruction { source: "if t90 == t91 then 'RpnCalc_handle_if_true_8_40' else 'RpnCalc_handle_if_else_8_41'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_8_40)], resolved: None }
42 3c 1a 08 
# 81a38 Instruction { source: "if t90 == t91 then 'RpnCalc_handle_if_true_8_40' else 'RpnCalc_handle_if_else_8_41'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_8_41)], resolved: None }
40 5c 1a 08 
# RpnCalc_handle_if_true_8_40
# 81a3c Instruction { source: "t93 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x10)], resolved: None }
81 18 10 
# 81a3f Instruction { source: "Arg0[c]=t93 None <= call RpnCalc_init(t93,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {48, 49, 50, 51, 52, 53, 54, 55, 56, 176, 177, 178, 179, 180, 181, 182, 183}
# Registers to save: []
# 81a42 Instruction { source: "PseudoCall(Label24(:RpnCalc_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81a48 Instruction { source: "PseudoCall(Label24(:RpnCalc_init))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 52 1a 08 00 
# 81a4e Instruction { source: "PseudoCall(Label24(:RpnCalc_init))", opcode: JmpImm, args: [Label24(:RpnCalc_init)], resolved: None }
40 5d 1c 08 
# 81a52 Instruction { source: "PseudoCall(Label24(:RpnCalc_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81a58 Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 50 1c 08 
# RpnCalc_handle_if_else_8_41
# 81a5c Instruction { source: "t94 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1d)], resolved: None }
16 1c 1d 
# 81a5f Instruction { source: "t95 <- 0n100/0x64u8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x64=100)], resolved: None }
00 2d 64 
# 81a62 Instruction { source: "if t94 == t95 then 'RpnCalc_handle_if_true_9_42' else 'RpnCalc_handle_if_else_9_43'", opcode: Cmp8, args: [Register(0x1d), Register(0x2d)], resolved: None }
25 1d 2d 
# 81a65 Instruction { source: "if t94 == t95 then 'RpnCalc_handle_if_true_9_42' else 'RpnCalc_handle_if_else_9_43'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_9_42)], resolved: None }
42 6d 1a 08 
# 81a69 Instruction { source: "if t94 == t95 then 'RpnCalc_handle_if_true_9_42' else 'RpnCalc_handle_if_else_9_43'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_9_43)], resolved: None }
40 64 1b 08 
# RpnCalc_handle_if_true_9_42
# 81a6d Instruction { source: "i <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x1d), Constant8(0x00=0)], resolved: None }
00 1d 00 
# RpnCalc_handle_while_predicate_44
# 81a70 Instruction { source: "t96 <- i U8", opcode: Copy8, args: [Register(0x1d), Register(0x1d)], resolved: None }
16 1d 1d 
# 81a73 Instruction { source: "t97 <- stack_count U8", opcode: Copy8, args: [Register(0x24), Register(0x2d)], resolved: None }
16 24 2d 
# 81a76 Instruction { source: "if t96 < t97 then 'RpnCalc_handle_while_body_45' else 'RpnCalc_handle_while_end_46'", opcode: Cmp8, args: [Register(0x2d), Register(0x1d)], resolved: None }
25 2d 1d 
# 81a79 Instruction { source: "if t96 < t97 then 'RpnCalc_handle_while_body_45' else 'RpnCalc_handle_while_end_46'", opcode: JcImm, args: [Label24(RpnCalc_handle_while_end_46)], resolved: None }
41 60 1b 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t96 < t97 then 'RpnCalc_handle_while_body_45' else 'RpnCalc_handle_while_end_46'", opcode: JmpImm, args: [Label24(RpnCalc_handle_while_body_45)], resolved: None }
# RpnCalc_handle_while_body_45
# 81a7d Instruction { source: "t99 <- i U8", opcode: Copy8, args: [Register(0x1d), Register(0x1d)], resolved: None }
16 1d 1d 
# 81a80 Instruction { source: "Arg0[a]=t99 None <= call print_dec8(t99,)", opcode: Copy8, args: [Register(0x1d), Register(0x00)], resolved: None }
16 1d 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {117, 118, 119}
# Registers to save: []
# 81a83 Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81a89 Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 93 1a 08 00 
# 81a8f Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: JmpImm, args: [Label24(:print_dec8)], resolved: None }
40 5e 29 08 
# 81a93 Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81a99 Instruction { source: "t100 <- 0n58/0x3au8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x3a=58)], resolved: None }
00 2d 3a 
# 81a9c Instruction { source: "ttyout <- t100", opcode: TtyOut, args: [Register(0x2d)], resolved: None }
13 2d 
# 81a9e Instruction { source: "t103 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x14)], resolved: None }
81 20 14 
# 81aa1 Instruction { source: "t105 <- i U8", opcode: Copy8, args: [Register(0x1d), Register(0x1d)], resolved: None }
16 1d 1d 
# 81aa4 Instruction { source: "Zero-pad for t104 U32 <- t105 U8", opcode: LoadImm32, args: [Register(0x18), Constant32(0x00000000=0)], resolved: None }
80 18 00 00 00 00 
# 81aaa Instruction { source: "t104 U32 <- t105 U8", opcode: Copy8, args: [Register(0x1d), Register(0x18)], resolved: None }
16 1d 18 
# 81aad Instruction { source: "Arg0[s]=t103 Some(t102) <= call stack_get(t103,t104,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# 81ab0 Instruction { source: "Arg1[n]=t104 Some(t102) <= call stack_get(t103,t104,)", opcode: Copy32, args: [Register(0x18), Register(0x04)], resolved: None }
81 18 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175}
# Registers to save: []
# 81ab3 Instruction { source: "PseudoCall(Label24(:stack_get))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81ab9 Instruction { source: "PseudoCall(Label24(:stack_get))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c c3 1a 08 00 
# 81abf Instruction { source: "PseudoCall(Label24(:stack_get))", opcode: JmpImm, args: [Label24(:stack_get)], resolved: None }
40 77 2c 08 
# 81ac3 Instruction { source: "PseudoCall(Label24(:stack_get))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81ac9 Instruction { source: "Some(t102) <= call stack_get(t103,t104,)", opcode: Copy32, args: [Register(0x00), Register(0x14)], resolved: None }
81 00 14 
# 81acc Instruction { source: "Arg0[a]=t102 None <= call print_dec32(t102,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 156, 157, 158, 159, 160, 161, 162, 176, 177, 178, 179, 180, 184, 185, 186, 187, 188, 189, 190, 191, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255}
# Registers to save: [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47]
# 81acf Instruction { source: "Saving reg0x2f before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x2f)], resolved: None }
14 2f 
# 81ad1 Instruction { source: "Saving reg0x2e before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x2e)], resolved: None }
14 2e 
# 81ad3 Instruction { source: "Saving reg0x2d before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x2d)], resolved: None }
14 2d 
# 81ad5 Instruction { source: "Saving reg0x2c before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x2c)], resolved: None }
14 2c 
# 81ad7 Instruction { source: "Saving reg0x2b before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x2b)], resolved: None }
14 2b 
# 81ad9 Instruction { source: "Saving reg0x2a before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x2a)], resolved: None }
14 2a 
# 81adb Instruction { source: "Saving reg0x29 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x29)], resolved: None }
14 29 
# 81add Instruction { source: "Saving reg0x28 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x28)], resolved: None }
14 28 
# 81adf Instruction { source: "Saving reg0x24 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x24)], resolved: None }
14 24 
# 81ae1 Instruction { source: "Saving reg0x23 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x23)], resolved: None }
14 23 
# 81ae3 Instruction { source: "Saving reg0x22 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x22)], resolved: None }
14 22 
# 81ae5 Instruction { source: "Saving reg0x21 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x21)], resolved: None }
14 21 
# 81ae7 Instruction { source: "Saving reg0x20 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x20)], resolved: None }
14 20 
# 81ae9 Instruction { source: "Saving reg0x1d before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x1d)], resolved: None }
14 1d 
# 81aeb Instruction { source: "Saving reg0x1c before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x1c)], resolved: None }
14 1c 
# 81aed Instruction { source: "Saving reg0x1a before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x1a)], resolved: None }
14 1a 
# 81aef Instruction { source: "Saving reg0x19 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x19)], resolved: None }
14 19 
# 81af1 Instruction { source: "Saving reg0x18 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x18)], resolved: None }
14 18 
# 81af3 Instruction { source: "Saving reg0x17 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x17)], resolved: None }
14 17 
# 81af5 Instruction { source: "Saving reg0x16 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x16)], resolved: None }
14 16 
# 81af7 Instruction { source: "Saving reg0x15 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x15)], resolved: None }
14 15 
# 81af9 Instruction { source: "Saving reg0x14 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x14)], resolved: None }
14 14 
# 81afb Instruction { source: "Saving reg0x13 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x13)], resolved: None }
14 13 
# 81afd Instruction { source: "Saving reg0x12 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x12)], resolved: None }
14 12 
# 81aff Instruction { source: "Saving reg0x11 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x11)], resolved: None }
14 11 
# 81b01 Instruction { source: "Saving reg0x10 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x10)], resolved: None }
14 10 
# 81b03 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81b09 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 13 1b 08 00 
# 81b0f Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: JmpImm, args: [Label24(:print_dec32)], resolved: None }
40 0d 28 08 
# 81b13 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81b19 Instruction { source: "Restoring reg0x10 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x10)], resolved: None }
15 10 
# 81b1b Instruction { source: "Restoring reg0x11 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x11)], resolved: None }
15 11 
# 81b1d Instruction { source: "Restoring reg0x12 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x12)], resolved: None }
15 12 
# 81b1f Instruction { source: "Restoring reg0x13 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x13)], resolved: None }
15 13 
# 81b21 Instruction { source: "Restoring reg0x14 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x14)], resolved: None }
15 14 
# 81b23 Instruction { source: "Restoring reg0x15 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x15)], resolved: None }
15 15 
# 81b25 Instruction { source: "Restoring reg0x16 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x16)], resolved: None }
15 16 
# 81b27 Instruction { source: "Restoring reg0x17 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x17)], resolved: None }
15 17 
# 81b29 Instruction { source: "Restoring reg0x18 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x18)], resolved: None }
15 18 
# 81b2b Instruction { source: "Restoring reg0x19 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x19)], resolved: None }
15 19 
# 81b2d Instruction { source: "Restoring reg0x1a after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x1a)], resolved: None }
15 1a 
# 81b2f Instruction { source: "Restoring reg0x1c after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x1c)], resolved: None }
15 1c 
# 81b31 Instruction { source: "Restoring reg0x1d after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x1d)], resolved: None }
15 1d 
# 81b33 Instruction { source: "Restoring reg0x20 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x20)], resolved: None }
15 20 
# 81b35 Instruction { source: "Restoring reg0x21 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x21)], resolved: None }
15 21 
# 81b37 Instruction { source: "Restoring reg0x22 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x22)], resolved: None }
15 22 
# 81b39 Instruction { source: "Restoring reg0x23 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x23)], resolved: None }
15 23 
# 81b3b Instruction { source: "Restoring reg0x24 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x24)], resolved: None }
15 24 
# 81b3d Instruction { source: "Restoring reg0x28 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x28)], resolved: None }
15 28 
# 81b3f Instruction { source: "Restoring reg0x29 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x29)], resolved: None }
15 29 
# 81b41 Instruction { source: "Restoring reg0x2a after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x2a)], resolved: None }
15 2a 
# 81b43 Instruction { source: "Restoring reg0x2b after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x2b)], resolved: None }
15 2b 
# 81b45 Instruction { source: "Restoring reg0x2c after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x2c)], resolved: None }
15 2c 
# 81b47 Instruction { source: "Restoring reg0x2d after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x2d)], resolved: None }
15 2d 
# 81b49 Instruction { source: "Restoring reg0x2e after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x2e)], resolved: None }
15 2e 
# 81b4b Instruction { source: "Restoring reg0x2f after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x2f)], resolved: None }
15 2f 
# 81b4d Instruction { source: "t106 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x0a=10)], resolved: None }
00 2d 0a 
# 81b50 Instruction { source: "ttyout <- t106", opcode: TtyOut, args: [Register(0x2d)], resolved: None }
13 2d 
# 81b52 Instruction { source: "t107 <- i U8", opcode: Copy8, args: [Register(0x1d), Register(0x1d)], resolved: None }
16 1d 1d 
# 81b55 Instruction { source: "t108 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x01=1)], resolved: None }
00 2d 01 
# 81b58 Instruction { source: "i <- t107 Add t108", opcode: Add8NoCarryIn, args: [Register(0x1d), Register(0x2d), Register(0x1d)], resolved: None }
24 1d 2d 1d 
# 81b5c Instruction { source: "goto RpnCalc_handle_while_predicate_44", opcode: JmpImm, args: [Label24(RpnCalc_handle_while_predicate_44)], resolved: None }
40 70 1a 08 
# RpnCalc_handle_while_end_46
# 81b60 Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 50 1c 08 
# RpnCalc_handle_if_else_9_43
# 81b64 Instruction { source: "t109 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1d)], resolved: None }
16 1c 1d 
# 81b67 Instruction { source: "t110 <- 0n57/0x39u8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x39=57)], resolved: None }
00 2d 39 
# 81b6a Instruction { source: "if t109 <= t110 then 'RpnCalc_handle_if_true_10_47' else 'RpnCalc_handle_if_else_10_48'", opcode: Cmp8, args: [Register(0x1d), Register(0x2d)], resolved: None }
25 1d 2d 
# 81b6d Instruction { source: "if t109 <= t110 then 'RpnCalc_handle_if_true_10_47' else 'RpnCalc_handle_if_else_10_48'", opcode: JcImm, args: [Label24(RpnCalc_handle_if_true_10_47)], resolved: None }
41 75 1b 08 
# 81b71 Instruction { source: "if t109 <= t110 then 'RpnCalc_handle_if_true_10_47' else 'RpnCalc_handle_if_else_10_48'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_10_48)], resolved: None }
40 50 1c 08 
# RpnCalc_handle_if_true_10_47
# 81b75 Instruction { source: "t111 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1d)], resolved: None }
16 1c 1d 
# 81b78 Instruction { source: "t112 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x30=48)], resolved: None }
00 2d 30 
# 81b7b Instruction { source: "if t111 >= t112 then 'RpnCalc_handle_if_true_0_50' else 'RpnCalc_handle_if_else_0_51'", opcode: Cmp8, args: [Register(0x2d), Register(0x1d)], resolved: None }
25 2d 1d 
# 81b7e Instruction { source: "if t111 >= t112 then 'RpnCalc_handle_if_true_0_50' else 'RpnCalc_handle_if_else_0_51'", opcode: JcImm, args: [Label24(RpnCalc_handle_if_true_0_50)], resolved: None }
41 86 1b 08 
# 81b82 Instruction { source: "if t111 >= t112 then 'RpnCalc_handle_if_true_0_50' else 'RpnCalc_handle_if_else_0_51'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_0_51)], resolved: None }
40 4c 1c 08 
# RpnCalc_handle_if_true_0_50
# 81b86 Instruction { source: "t114 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x10)], resolved: None }
81 18 10 
# 81b89 Instruction { source: "t115 <- 0n72/0x00000048u32 ", opcode: LoadImm32, args: [Register(0x14), Constant32(0x00000048=72)], resolved: None }
80 14 48 00 00 00 
# 81b8f Instruction { source: "t113 <- t114 Add t115", opcode: Add32NoCarryIn, args: [Register(0x10), Register(0x14), Register(0x10)], resolved: None }
a0 10 14 10 
# 81b93 Instruction { source: "t116 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x01=1)], resolved: None }
00 2d 01 
# 81b96 Instruction { source: "mem[t113] <- t116 U8", opcode: Store8, args: [Register(0x2d), Register(0x10)], resolved: None }
11 2d 10 
# 81b99 Instruction { source: "t118 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x10)], resolved: None }
81 18 10 
# 81b9c Instruction { source: "t119 <- 0n68/0x00000044u32 ", opcode: LoadImm32, args: [Register(0x14), Constant32(0x00000044=68)], resolved: None }
80 14 44 00 00 00 
# 81ba2 Instruction { source: "t117 <- t118 Add t119", opcode: Add32NoCarryIn, args: [Register(0x10), Register(0x14), Register(0x10)], resolved: None }
a0 10 14 10 
# 81ba6 Instruction { source: "t123 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x14)], resolved: None }
81 18 14 
# 81ba9 Instruction { source: "t124 <- 0n68/0x00000044u32 ", opcode: LoadImm32, args: [Register(0x20), Constant32(0x00000044=68)], resolved: None }
80 20 44 00 00 00 
# 81baf Instruction { source: "t122 <- t123 Add t124", opcode: Add32NoCarryIn, args: [Register(0x14), Register(0x20), Register(0x14)], resolved: None }
a0 14 20 14 
# 81bb3 Instruction { source: "t121 <- mem[t122] U32", opcode: Load32, args: [Register(0x14), Register(0x14)], resolved: None }
90 14 14 
# 81bb6 Instruction { source: "t125 <- 0n10/0x0000000au32 ", opcode: LoadImm32, args: [Register(0x20), Constant32(0x0000000a=10)], resolved: None }
80 20 0a 00 00 00 
# 81bbc Instruction { source: "Arg0[a]=t121 Some(t120) <= call mul32_32(t121,t125,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# 81bbf Instruction { source: "Arg1[b]=t125 Some(t120) <= call mul32_32(t121,t125,)", opcode: Copy32, args: [Register(0x20), Register(0x04)], resolved: None }
81 20 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255}
# Registers to save: [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]
# 81bc2 Instruction { source: "Saving reg0x1a before Some(t120) <= call mul32_32(t121,t125,)", opcode: Push8, args: [Register(0x1a)], resolved: None }
14 1a 
# 81bc4 Instruction { source: "Saving reg0x19 before Some(t120) <= call mul32_32(t121,t125,)", opcode: Push8, args: [Register(0x19)], resolved: None }
14 19 
# 81bc6 Instruction { source: "Saving reg0x18 before Some(t120) <= call mul32_32(t121,t125,)", opcode: Push8, args: [Register(0x18)], resolved: None }
14 18 
# 81bc8 Instruction { source: "Saving reg0x17 before Some(t120) <= call mul32_32(t121,t125,)", opcode: Push8, args: [Register(0x17)], resolved: None }
14 17 
# 81bca Instruction { source: "Saving reg0x16 before Some(t120) <= call mul32_32(t121,t125,)", opcode: Push8, args: [Register(0x16)], resolved: None }
14 16 
# 81bcc Instruction { source: "Saving reg0x15 before Some(t120) <= call mul32_32(t121,t125,)", opcode: Push8, args: [Register(0x15)], resolved: None }
14 15 
# 81bce Instruction { source: "Saving reg0x14 before Some(t120) <= call mul32_32(t121,t125,)", opcode: Push8, args: [Register(0x14)], resolved: None }
14 14 
# 81bd0 Instruction { source: "Saving reg0x13 before Some(t120) <= call mul32_32(t121,t125,)", opcode: Push8, args: [Register(0x13)], resolved: None }
14 13 
# 81bd2 Instruction { source: "Saving reg0x12 before Some(t120) <= call mul32_32(t121,t125,)", opcode: Push8, args: [Register(0x12)], resolved: None }
14 12 
# 81bd4 Instruction { source: "Saving reg0x11 before Some(t120) <= call mul32_32(t121,t125,)", opcode: Push8, args: [Register(0x11)], resolved: None }
14 11 
# 81bd6 Instruction { source: "Saving reg0x10 before Some(t120) <= call mul32_32(t121,t125,)", opcode: Push8, args: [Register(0x10)], resolved: None }
14 10 
# 81bd8 Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81bde Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c e8 1b 08 00 
# 81be4 Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: JmpImm, args: [Label24(:mul32_32)], resolved: None }
40 10 25 08 
# 81be8 Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81bee Instruction { source: "Restoring reg0x10 after Some(t120) <= call mul32_32(t121,t125,)", opcode: Pop8, args: [Register(0x10)], resolved: None }
15 10 
# 81bf0 Instruction { source: "Restoring reg0x11 after Some(t120) <= call mul32_32(t121,t125,)", opcode: Pop8, args: [Register(0x11)], resolved: None }
15 11 
# 81bf2 Instruction { source: "Restoring reg0x12 after Some(t120) <= call mul32_32(t121,t125,)", opcode: Pop8, args: [Register(0x12)], resolved: None }
15 12 
# 81bf4 Instruction { source: "Restoring reg0x13 after Some(t120) <= call mul32_32(t121,t125,)", opcode: Pop8, args: [Register(0x13)], resolved: None }
15 13 
# 81bf6 Instruction { source: "Restoring reg0x14 after Some(t120) <= call mul32_32(t121,t125,)", opcode: Pop8, args: [Register(0x14)], resolved: None }
15 14 
# 81bf8 Instruction { source: "Restoring reg0x15 after Some(t120) <= call mul32_32(t121,t125,)", opcode: Pop8, args: [Register(0x15)], resolved: None }
15 15 
# 81bfa Instruction { source: "Restoring reg0x16 after Some(t120) <= call mul32_32(t121,t125,)", opcode: Pop8, args: [Register(0x16)], resolved: None }
15 16 
# 81bfc Instruction { source: "Restoring reg0x17 after Some(t120) <= call mul32_32(t121,t125,)", opcode: Pop8, args: [Register(0x17)], resolved: None }
15 17 
# 81bfe Instruction { source: "Restoring reg0x18 after Some(t120) <= call mul32_32(t121,t125,)", opcode: Pop8, args: [Register(0x18)], resolved: None }
15 18 
# 81c00 Instruction { source: "Restoring reg0x19 after Some(t120) <= call mul32_32(t121,t125,)", opcode: Pop8, args: [Register(0x19)], resolved: None }
15 19 
# 81c02 Instruction { source: "Restoring reg0x1a after Some(t120) <= call mul32_32(t121,t125,)", opcode: Pop8, args: [Register(0x1a)], resolved: None }
15 1a 
# 81c04 Instruction { source: "Some(t120) <= call mul32_32(t121,t125,)", opcode: Copy32, args: [Register(0x00), Register(0x14)], resolved: None }
81 00 14 
# 81c07 Instruction { source: "mem[t117] <- t120 U32", opcode: Store32_1, args: [Register(0x14), Register(0x10)], resolved: None }
92 14 10 
# 81c0a Instruction { source: "mem[t117] <- t120 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 81c0b Instruction { source: "t127 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x10)], resolved: None }
81 18 10 
# 81c0e Instruction { source: "t128 <- 0n68/0x00000044u32 ", opcode: LoadImm32, args: [Register(0x14), Constant32(0x00000044=68)], resolved: None }
80 14 44 00 00 00 
# 81c14 Instruction { source: "t126 <- t127 Add t128", opcode: Add32NoCarryIn, args: [Register(0x10), Register(0x14), Register(0x10)], resolved: None }
a0 10 14 10 
# 81c18 Instruction { source: "t132 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x14)], resolved: None }
81 18 14 
# 81c1b Instruction { source: "t133 <- 0n68/0x00000044u32 ", opcode: LoadImm32, args: [Register(0x18), Constant32(0x00000044=68)], resolved: None }
80 18 44 00 00 00 
# 81c21 Instruction { source: "t131 <- t132 Add t133", opcode: Add32NoCarryIn, args: [Register(0x14), Register(0x18), Register(0x14)], resolved: None }
a0 14 18 14 
# 81c25 Instruction { source: "t130 <- mem[t131] U32", opcode: Load32, args: [Register(0x14), Register(0x14)], resolved: None }
90 14 14 
# 81c28 Instruction { source: "t136 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x2f)], resolved: None }
16 1c 2f 
# 81c2b Instruction { source: "t137 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x1c), Constant8(0x30=48)], resolved: None }
00 1c 30 
# 81c2e Instruction { source: "t135 <- t136 Subtract t137", opcode: Copy8, args: [Register(0x1c), Register(0x00)], resolved: None }
16 1c 00 
# 81c31 Instruction { source: "t135 <- t136 Subtract t137", opcode: Negate8, args: [Register(0x00)], resolved: None }
04 00 
# 81c33 Instruction { source: "t135 <- t136 Subtract t137", opcode: Add8NoCarryIn, args: [Register(0x2f), Register(0x00), Register(0x2f)], resolved: None }
24 2f 00 2f 
# 81c37 Instruction { source: "Zero-pad for t134 U32 <- t135 U8", opcode: LoadImm32, args: [Register(0x18), Constant32(0x00000000=0)], resolved: None }
80 18 00 00 00 00 
# 81c3d Instruction { source: "t134 U32 <- t135 U8", opcode: Copy8, args: [Register(0x2f), Register(0x18)], resolved: None }
16 2f 18 
# 81c40 Instruction { source: "t129 <- t130 Add t134", opcode: Add32NoCarryIn, args: [Register(0x14), Register(0x18), Register(0x14)], resolved: None }
a0 14 18 14 
# 81c44 Instruction { source: "mem[t126] <- t129 U32", opcode: Store32_1, args: [Register(0x14), Register(0x10)], resolved: None }
92 14 10 
# 81c47 Instruction { source: "mem[t126] <- t129 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 81c48 Instruction { source: "goto RpnCalc_handle_if_end_49", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_49)], resolved: None }
40 4c 1c 08 
# RpnCalc_handle_if_else_0_51
# RpnCalc_handle_if_end_49
# 81c4c Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 50 1c 08 
# RpnCalc_handle_if_else_10_48
# RpnCalc_handle_if_end_23
# 81c50 Instruction { source: "t138 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x1d), Constant8(0x01=1)], resolved: None }
00 1d 01 
# 81c53 Instruction { source: "return Some(t138)", opcode: Copy8, args: [Register(0x1d), Register(0x00)], resolved: None }
16 1d 00 
# 81c56 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81c58 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :RpnCalc_init
# Ret None
# Arg0=c
# Var c (Arg0 c Ptr(Struct("RpnCalc"))) U32 Some([48, 49, 50, 51])
# Var s (Local s Ptr(Struct("Stack")) U32) U32 Some([52, 53, 54, 55])
# Var t0 (t0 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Struct("Stack")), value: Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") } }) U32 Some([48, 49, 50, 51])
# Var t1 (t1 Call(Call { function: "stack_init", parameters: [Ident("s")] })) U8 Some([56])
# Var t2 (t2 Ident("s")) U32 Some([52, 53, 54, 55])
# Var t3 (t3 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 68)) }) U32 Some([48, 49, 50, 51])
# Var t4 (t4 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([48, 49, 50, 51])
# Var t5 (t5 Number(USIZE, 68)) U32 Some([52, 53, 54, 55])
# Var t6 (t6 Number(USIZE, 0)) U32 Some([52, 53, 54, 55])
# 81c5d Instruction { source: "Save function parameter 'c' registers [0, 1, 2, 3] to locals [48, 49, 50, 51].", opcode: Copy32, args: [Register(0x00), Register(0x30)], resolved: None }
81 00 30 
# 81c60 Instruction { source: "t0 <- c U32", opcode: Copy32, args: [Register(0x30), Register(0x30)], resolved: None }
81 30 30 
# 81c63 Instruction { source: "s <- t0 U32", opcode: Copy32, args: [Register(0x30), Register(0x34)], resolved: None }
81 30 34 
# 81c66 Instruction { source: "t2 <- s U32", opcode: Copy32, args: [Register(0x34), Register(0x34)], resolved: None }
81 34 34 
# 81c69 Instruction { source: "Arg0[s]=t2 None <= call stack_init(t2,)", opcode: Copy32, args: [Register(0x34), Register(0x00)], resolved: None }
81 34 00 
# Registers used by this function: {48, 49, 50, 51, 52, 53, 54, 55, 56}
# Registers used by callee tree: {176, 177, 178, 179, 180, 181, 182, 183}
# Registers to save: []
# 81c6c Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81c72 Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 7c 1c 08 00 
# 81c78 Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: JmpImm, args: [Label24(:stack_init)], resolved: None }
40 ad 2c 08 
# 81c7c Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81c82 Instruction { source: "t4 <- c U32", opcode: Copy32, args: [Register(0x30), Register(0x30)], resolved: None }
81 30 30 
# 81c85 Instruction { source: "t5 <- 0n68/0x00000044u32 ", opcode: LoadImm32, args: [Register(0x34), Constant32(0x00000044=68)], resolved: None }
80 34 44 00 00 00 
# 81c8b Instruction { source: "t3 <- t4 Add t5", opcode: Add32NoCarryIn, args: [Register(0x30), Register(0x34), Register(0x30)], resolved: None }
a0 30 34 30 
# 81c8f Instruction { source: "t6 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x34), Constant32(0x00000000=0)], resolved: None }
80 34 00 00 00 00 
# 81c95 Instruction { source: "mem[t3] <- t6 U32", opcode: Store32_1, args: [Register(0x34), Register(0x30)], resolved: None }
92 34 30 
# 81c98 Instruction { source: "mem[t3] <- t6 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 81c99 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81c9b Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :RpnCalc_push_pending
# Ret None
# Arg0=c
# Var c (Arg0 c Ptr(Struct("RpnCalc"))) U32 Some([60, 61, 62, 63])
# Var t0 (t0 PtrFieldDeref("c", "have_num")) U8 Some([64])
# Var t1 (t1 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 72)) }) U32 Some([68, 69, 70, 71])
# Var t10 (t10 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([60, 61, 62, 63])
# Var t11 (t11 Number(USIZE, 68)) U32 Some([68, 69, 70, 71])
# Var t12 (t12 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 68)) }) U32 Some([68, 69, 70, 71])
# Var t13 (t13 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([60, 61, 62, 63])
# Var t14 (t14 Number(USIZE, 68)) U32 Some([68, 69, 70, 71])
# Var t15 (t15 Number(USIZE, 0)) U32 Some([72, 73, 74, 75])
# Var t16 (t16 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 72)) }) U32 Some([60, 61, 62, 63])
# Var t17 (t17 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([60, 61, 62, 63])
# Var t18 (t18 Number(USIZE, 72)) U32 Some([68, 69, 70, 71])
# Var t19 (t19 Number(U8, 0)) U8 Some([64])
# Var t2 (t2 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([60, 61, 62, 63])
# Var t3 (t3 Number(USIZE, 72)) U32 Some([68, 69, 70, 71])
# Var t4 (t4 Number(U8, 0)) U8 Some([76])
# Var t5 (t5 Call(Call { function: "stack_push", parameters: [AddressOf(PtrFieldDeref("c", "stack")), PtrFieldDeref("c", "num")] })) U8 Some([77])
# Var t6 (t6 AddressOf(PtrFieldDeref("c", "stack"))) U32 Some([72, 73, 74, 75])
# Var t7 (t7 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Struct("Stack")), value: Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") } }) U32 Some([60, 61, 62, 63])
# Var t8 (t8 PtrFieldDeref("c", "num")) U32 Some([68, 69, 70, 71])
# Var t9 (t9 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 68)) }) U32 Some([68, 69, 70, 71])
# 81ca0 Instruction { source: "Save function parameter 'c' registers [0, 1, 2, 3] to locals [60, 61, 62, 63].", opcode: Copy32, args: [Register(0x00), Register(0x3c)], resolved: None }
81 00 3c 
# 81ca3 Instruction { source: "t2 <- c U32", opcode: Copy32, args: [Register(0x3c), Register(0x3c)], resolved: None }
81 3c 3c 
# 81ca6 Instruction { source: "t3 <- 0n72/0x00000048u32 ", opcode: LoadImm32, args: [Register(0x44), Constant32(0x00000048=72)], resolved: None }
80 44 48 00 00 00 
# 81cac Instruction { source: "t1 <- t2 Add t3", opcode: Add32NoCarryIn, args: [Register(0x3c), Register(0x44), Register(0x44)], resolved: None }
a0 3c 44 44 
# 81cb0 Instruction { source: "t0 <- mem[t1] U8", opcode: Load8, args: [Register(0x44), Register(0x40)], resolved: None }
10 44 40 
# 81cb3 Instruction { source: "t4 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x4c), Constant8(0x00=0)], resolved: None }
00 4c 00 
# 81cb6 Instruction { source: "if t0 != t4 then 'RpnCalc_push_pending_if_true_0_1' else 'RpnCalc_push_pending_if_else_0_2'", opcode: Cmp8, args: [Register(0x40), Register(0x4c)], resolved: None }
25 40 4c 
# 81cb9 Instruction { source: "if t0 != t4 then 'RpnCalc_push_pending_if_true_0_1' else 'RpnCalc_push_pending_if_else_0_2'", opcode: JzImm, args: [Label24(RpnCalc_push_pending_if_else_0_2)], resolved: None }
42 1d 1d 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t0 != t4 then 'RpnCalc_push_pending_if_true_0_1' else 'RpnCalc_push_pending_if_else_0_2'", opcode: JmpImm, args: [Label24(RpnCalc_push_pending_if_true_0_1)], resolved: None }
# RpnCalc_push_pending_if_true_0_1
# 81cbd Instruction { source: "t7 <- c U32", opcode: Copy32, args: [Register(0x3c), Register(0x3c)], resolved: None }
81 3c 3c 
# 81cc0 Instruction { source: "t6 <- t7 U32", opcode: Copy32, args: [Register(0x3c), Register(0x48)], resolved: None }
81 3c 48 
# 81cc3 Instruction { source: "t10 <- c U32", opcode: Copy32, args: [Register(0x3c), Register(0x3c)], resolved: None }
81 3c 3c 
# 81cc6 Instruction { source: "t11 <- 0n68/0x00000044u32 ", opcode: LoadImm32, args: [Register(0x44), Constant32(0x00000044=68)], resolved: None }
80 44 44 00 00 00 
# 81ccc Instruction { source: "t9 <- t10 Add t11", opcode: Add32NoCarryIn, args: [Register(0x3c), Register(0x44), Register(0x44)], resolved: None }
a0 3c 44 44 
# 81cd0 Instruction { source: "t8 <- mem[t9] U32", opcode: Load32, args: [Register(0x44), Register(0x44)], resolved: None }
90 44 44 
# 81cd3 Instruction { source: "Arg0[s]=t6 None <= call stack_push(t6,t8,)", opcode: Copy32, args: [Register(0x48), Register(0x00)], resolved: None }
81 48 00 
# 81cd6 Instruction { source: "Arg1[n]=t8 None <= call stack_push(t6,t8,)", opcode: Copy32, args: [Register(0x44), Register(0x04)], resolved: None }
81 44 04 
# Registers used by this function: {60, 61, 62, 63, 64, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77}
# Registers used by callee tree: {200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219}
# Registers to save: []
# 81cd9 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81cdf Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c e9 1c 08 00 
# 81ce5 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 4a 2d 08 
# 81ce9 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81cef Instruction { source: "t13 <- c U32", opcode: Copy32, args: [Register(0x3c), Register(0x3c)], resolved: None }
81 3c 3c 
# 81cf2 Instruction { source: "t14 <- 0n68/0x00000044u32 ", opcode: LoadImm32, args: [Register(0x44), Constant32(0x00000044=68)], resolved: None }
80 44 44 00 00 00 
# 81cf8 Instruction { source: "t12 <- t13 Add t14", opcode: Add32NoCarryIn, args: [Register(0x3c), Register(0x44), Register(0x44)], resolved: None }
a0 3c 44 44 
# 81cfc Instruction { source: "t15 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x48), Constant32(0x00000000=0)], resolved: None }
80 48 00 00 00 00 
# 81d02 Instruction { source: "mem[t12] <- t15 U32", opcode: Store32_1, args: [Register(0x48), Register(0x44)], resolved: None }
92 48 44 
# 81d05 Instruction { source: "mem[t12] <- t15 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 81d06 Instruction { source: "t17 <- c U32", opcode: Copy32, args: [Register(0x3c), Register(0x3c)], resolved: None }
81 3c 3c 
# 81d09 Instruction { source: "t18 <- 0n72/0x00000048u32 ", opcode: LoadImm32, args: [Register(0x44), Constant32(0x00000048=72)], resolved: None }
80 44 48 00 00 00 
# 81d0f Instruction { source: "t16 <- t17 Add t18", opcode: Add32NoCarryIn, args: [Register(0x3c), Register(0x44), Register(0x3c)], resolved: None }
a0 3c 44 3c 
# 81d13 Instruction { source: "t19 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x40), Constant8(0x00=0)], resolved: None }
00 40 00 
# 81d16 Instruction { source: "mem[t16] <- t19 U8", opcode: Store8, args: [Register(0x40), Register(0x3c)], resolved: None }
11 40 3c 
# 81d19 Instruction { source: "goto RpnCalc_push_pending_if_end_0", opcode: JmpImm, args: [Label24(RpnCalc_push_pending_if_end_0)], resolved: None }
40 1d 1d 08 
# RpnCalc_push_pending_if_else_0_2
# RpnCalc_push_pending_if_end_0
# 81d1d Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81d1f Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :add_U64
# Ret None
# Arg0=a
# Arg1=b
# Arg2=c
# Var a (Arg0 a Ptr(Struct("U64"))) U32 Some([80, 81, 82, 83])
# Var b (Arg1 b Ptr(Struct("U64"))) U32 Some([84, 85, 86, 87])
# Var c (Arg2 c Ptr(Struct("U64"))) U32 Some([88, 89, 90, 91])
# Var lo (Local lo Number(USIZE) U32) U32 Some([92, 93, 94, 95])
# Var t0 (t0 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("a") } }) U32 Some([80, 81, 82, 83])
# Var t1 (t1 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 4)) }) U32 Some([96, 97, 98, 99])
# Var t10 (t10 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("b") }, Number(USIZE, 4)) }) U32 Some([100, 101, 102, 103])
# Var t11 (t11 Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("b") }) U32 Some([84, 85, 86, 87])
# Var t12 (t12 Number(USIZE, 4)) U32 Some([100, 101, 102, 103])
# Var t13 (t13 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") } }) U32 Some([88, 89, 90, 91])
# Var t14 (t14 Arithmetic(Add, PtrFieldDeref("a", "lo"), PtrFieldDeref("b", "lo"))) U32 Some([80, 81, 82, 83])
# Var t15 (t15 PtrFieldDeref("a", "lo")) U32 Some([80, 81, 82, 83])
# Var t16 (t16 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("a") } }) U32 Some([80, 81, 82, 83])
# Var t17 (t17 PtrFieldDeref("b", "lo")) U32 Some([84, 85, 86, 87])
# Var t18 (t18 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("b") } }) U32 Some([84, 85, 86, 87])
# Var t19 (t19 PtrFieldDeref("c", "lo")) U32 Some([80, 81, 82, 83])
# Var t2 (t2 Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([88, 89, 90, 91])
# Var t20 (t20 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") } }) U32 Some([80, 81, 82, 83])
# Var t21 (t21 Ident("lo")) U32 Some([84, 85, 86, 87])
# Var t22 (t22 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 4)) }) U32 Some([80, 81, 82, 83])
# Var t23 (t23 Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([80, 81, 82, 83])
# Var t24 (t24 Number(USIZE, 4)) U32 Some([84, 85, 86, 87])
# Var t25 (t25 Arithmetic(Add, PtrFieldDeref("c", "hi"), Number(USIZE, 1))) U32 Some([84, 85, 86, 87])
# Var t26 (t26 PtrFieldDeref("c", "hi")) U32 Some([84, 85, 86, 87])
# Var t27 (t27 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 4)) }) U32 Some([84, 85, 86, 87])
# Var t28 (t28 Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([84, 85, 86, 87])
# Var t29 (t29 Number(USIZE, 4)) U32 Some([88, 89, 90, 91])
# Var t3 (t3 Number(USIZE, 4)) U32 Some([96, 97, 98, 99])
# Var t30 (t30 Number(USIZE, 1)) U32 Some([88, 89, 90, 91])
# Var t4 (t4 Arithmetic(Add, PtrFieldDeref("a", "hi"), PtrFieldDeref("b", "hi"))) U32 Some([100, 101, 102, 103])
# Var t5 (t5 PtrFieldDeref("a", "hi")) U32 Some([104, 105, 106, 107])
# Var t6 (t6 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("a") }, Number(USIZE, 4)) }) U32 Some([100, 101, 102, 103])
# Var t7 (t7 Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("a") }) U32 Some([80, 81, 82, 83])
# Var t8 (t8 Number(USIZE, 4)) U32 Some([100, 101, 102, 103])
# Var t9 (t9 PtrFieldDeref("b", "hi")) U32 Some([100, 101, 102, 103])
# 81d24 Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [80, 81, 82, 83].", opcode: Copy32, args: [Register(0x00), Register(0x50)], resolved: None }
81 00 50 
# 81d27 Instruction { source: "Save function parameter 'b' registers [4, 5, 6, 7] to locals [84, 85, 86, 87].", opcode: Copy32, args: [Register(0x04), Register(0x54)], resolved: None }
81 04 54 
# 81d2a Instruction { source: "Save function parameter 'c' registers [8, 9, 10, 11] to locals [88, 89, 90, 91].", opcode: Copy32, args: [Register(0x08), Register(0x58)], resolved: None }
81 08 58 
# 81d2d Instruction { source: "t0 <- a U32", opcode: Copy32, args: [Register(0x50), Register(0x50)], resolved: None }
81 50 50 
# 81d30 Instruction { source: "lo <- mem[t0] U32", opcode: Load32, args: [Register(0x50), Register(0x5c)], resolved: None }
90 50 5c 
# 81d33 Instruction { source: "t2 <- c U32", opcode: Copy32, args: [Register(0x58), Register(0x58)], resolved: None }
81 58 58 
# 81d36 Instruction { source: "t3 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x60), Constant32(0x00000004=4)], resolved: None }
80 60 04 00 00 00 
# 81d3c Instruction { source: "t1 <- t2 Add t3", opcode: Add32NoCarryIn, args: [Register(0x58), Register(0x60), Register(0x60)], resolved: None }
a0 58 60 60 
# 81d40 Instruction { source: "t7 <- a U32", opcode: Copy32, args: [Register(0x50), Register(0x50)], resolved: None }
81 50 50 
# 81d43 Instruction { source: "t8 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x64), Constant32(0x00000004=4)], resolved: None }
80 64 04 00 00 00 
# 81d49 Instruction { source: "t6 <- t7 Add t8", opcode: Add32NoCarryIn, args: [Register(0x50), Register(0x64), Register(0x64)], resolved: None }
a0 50 64 64 
# 81d4d Instruction { source: "t5 <- mem[t6] U32", opcode: Load32, args: [Register(0x64), Register(0x68)], resolved: None }
90 64 68 
# 81d50 Instruction { source: "t11 <- b U32", opcode: Copy32, args: [Register(0x54), Register(0x54)], resolved: None }
81 54 54 
# 81d53 Instruction { source: "t12 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x64), Constant32(0x00000004=4)], resolved: None }
80 64 04 00 00 00 
# 81d59 Instruction { source: "t10 <- t11 Add t12", opcode: Add32NoCarryIn, args: [Register(0x54), Register(0x64), Register(0x64)], resolved: None }
a0 54 64 64 
# 81d5d Instruction { source: "t9 <- mem[t10] U32", opcode: Load32, args: [Register(0x64), Register(0x64)], resolved: None }
90 64 64 
# 81d60 Instruction { source: "t4 <- t5 Add t9", opcode: Add32NoCarryIn, args: [Register(0x68), Register(0x64), Register(0x64)], resolved: None }
a0 68 64 64 
# 81d64 Instruction { source: "mem[t1] <- t4 U32", opcode: Store32_1, args: [Register(0x64), Register(0x60)], resolved: None }
92 64 60 
# 81d67 Instruction { source: "mem[t1] <- t4 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 81d68 Instruction { source: "t13 <- c U32", opcode: Copy32, args: [Register(0x58), Register(0x58)], resolved: None }
81 58 58 
# 81d6b Instruction { source: "t16 <- a U32", opcode: Copy32, args: [Register(0x50), Register(0x50)], resolved: None }
81 50 50 
# 81d6e Instruction { source: "t15 <- mem[t16] U32", opcode: Load32, args: [Register(0x50), Register(0x50)], resolved: None }
90 50 50 
# 81d71 Instruction { source: "t18 <- b U32", opcode: Copy32, args: [Register(0x54), Register(0x54)], resolved: None }
81 54 54 
# 81d74 Instruction { source: "t17 <- mem[t18] U32", opcode: Load32, args: [Register(0x54), Register(0x54)], resolved: None }
90 54 54 
# 81d77 Instruction { source: "t14 <- t15 Add t17", opcode: Add32NoCarryIn, args: [Register(0x50), Register(0x54), Register(0x50)], resolved: None }
a0 50 54 50 
# 81d7b Instruction { source: "mem[t13] <- t14 U32", opcode: Store32_1, args: [Register(0x50), Register(0x58)], resolved: None }
92 50 58 
# 81d7e Instruction { source: "mem[t13] <- t14 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 81d7f Instruction { source: "t20 <- c U32", opcode: Copy32, args: [Register(0x58), Register(0x50)], resolved: None }
81 58 50 
# 81d82 Instruction { source: "t19 <- mem[t20] U32", opcode: Load32, args: [Register(0x50), Register(0x50)], resolved: None }
90 50 50 
# 81d85 Instruction { source: "t21 <- lo U32", opcode: Copy32, args: [Register(0x5c), Register(0x54)], resolved: None }
81 5c 54 
# 81d88 Instruction { source: "if t19 < t21 then 'add_U64_if_true_0_1' else 'add_U64_if_else_0_2'", opcode: Cmp8, args: [Register(0x57), Register(0x53)], resolved: None }
25 57 53 
# 81d8b Instruction { source: "if t19 < t21 then 'add_U64_if_true_0_1' else 'add_U64_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x56), Register(0x52)], resolved: None }
26 56 52 
# 81d8e Instruction { source: "if t19 < t21 then 'add_U64_if_true_0_1' else 'add_U64_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x55), Register(0x51)], resolved: None }
26 55 51 
# 81d91 Instruction { source: "if t19 < t21 then 'add_U64_if_true_0_1' else 'add_U64_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x54), Register(0x50)], resolved: None }
26 54 50 
# 81d94 Instruction { source: "if t19 < t21 then 'add_U64_if_true_0_1' else 'add_U64_if_else_0_2'", opcode: JcImm, args: [Label24(add_U64_if_else_0_2)], resolved: None }
41 c7 1d 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t19 < t21 then 'add_U64_if_true_0_1' else 'add_U64_if_else_0_2'", opcode: JmpImm, args: [Label24(add_U64_if_true_0_1)], resolved: None }
# add_U64_if_true_0_1
# 81d98 Instruction { source: "t23 <- c U32", opcode: Copy32, args: [Register(0x58), Register(0x50)], resolved: None }
81 58 50 
# 81d9b Instruction { source: "t24 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x54), Constant32(0x00000004=4)], resolved: None }
80 54 04 00 00 00 
# 81da1 Instruction { source: "t22 <- t23 Add t24", opcode: Add32NoCarryIn, args: [Register(0x50), Register(0x54), Register(0x50)], resolved: None }
a0 50 54 50 
# 81da5 Instruction { source: "t28 <- c U32", opcode: Copy32, args: [Register(0x58), Register(0x54)], resolved: None }
81 58 54 
# 81da8 Instruction { source: "t29 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x58), Constant32(0x00000004=4)], resolved: None }
80 58 04 00 00 00 
# 81dae Instruction { source: "t27 <- t28 Add t29", opcode: Add32NoCarryIn, args: [Register(0x54), Register(0x58), Register(0x54)], resolved: None }
a0 54 58 54 
# 81db2 Instruction { source: "t26 <- mem[t27] U32", opcode: Load32, args: [Register(0x54), Register(0x54)], resolved: None }
90 54 54 
# 81db5 Instruction { source: "t30 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x58), Constant32(0x00000001=1)], resolved: None }
80 58 01 00 00 00 
# 81dbb Instruction { source: "t25 <- t26 Add t30", opcode: Add32NoCarryIn, args: [Register(0x54), Register(0x58), Register(0x54)], resolved: None }
a0 54 58 54 
# 81dbf Instruction { source: "mem[t22] <- t25 U32", opcode: Store32_1, args: [Register(0x54), Register(0x50)], resolved: None }
92 54 50 
# 81dc2 Instruction { source: "mem[t22] <- t25 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 81dc3 Instruction { source: "goto add_U64_if_end_0", opcode: JmpImm, args: [Label24(add_U64_if_end_0)], resolved: None }
40 c7 1d 08 
# add_U64_if_else_0_2
# add_U64_if_end_0
# 81dc7 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81dc9 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :div16
# Ret Some(U32)
# Arg0=a
# Arg1=b
# Var a (Arg0 a Number(USIZE)) U32 Some([108, 109, 110, 111])
# Var b (Arg1 b Number(USIZE)) U32 Some([112, 113, 114, 115])
# Var hi (Local hi Number(USIZE) U32) U32 Some([116, 117, 118, 119])
# Var lo (Local lo Number(USIZE) U32) U32 Some([120, 121, 122, 123])
# Var mid (Local mid Number(USIZE) U32) U32 Some([124, 125, 126, 127])
# Var r (Local r Number(USIZE) U32) U32 Some([120, 121, 122, 123])
# Var t0 (t0 Ident("a")) U32 Some([108, 109, 110, 111])
# Var t1 (t1 Ident("b")) U32 Some([112, 113, 114, 115])
# Var t10 (t10 Ident("hi")) U32 Some([116, 117, 118, 119])
# Var t11 (t11 Arithmetic(Add, Ident("lo"), Ident("hi"))) U32 Some([124, 125, 126, 127])
# Var t12 (t12 Ident("lo")) U32 Some([120, 121, 122, 123])
# Var t13 (t13 Ident("hi")) U32 Some([116, 117, 118, 119])
# Var t14 (t14 Ident("mid")) U32 Some([124, 125, 126, 127])
# Var t15 (t15 Ident("b")) U32 Some([112, 113, 114, 115])
# Var t16 (t16 Index("x", Number(U8, 2))) U8 Some([128])
# Var t17 (t17 Number(U8, 0)) U8 Some([129])
# Var t18 (t18 Ident("mid")) U32 Some([116, 117, 118, 119])
# Var t19 (t19 Number(USIZE, 1)) U32 Some([124, 125, 126, 127])
# Var t2 (t2 Number(USIZE, 0)) U32 Some([108, 109, 110, 111])
# Var t20 (t20 Index("x", Number(U8, 3))) U8 Some([128])
# Var t21 (t21 Number(U8, 0)) U8 Some([129])
# Var t22 (t22 Ident("mid")) U32 Some([116, 117, 118, 119])
# Var t23 (t23 Number(USIZE, 1)) U32 Some([124, 125, 126, 127])
# Var t24 (t24 Ident("x")) U32 Some([132, 133, 134, 135])
# Var t25 (t25 Ident("a")) U32 Some([108, 109, 110, 111])
# Var t26 (t26 Ident("mid")) U32 Some([116, 117, 118, 119])
# Var t27 (t27 Number(USIZE, 1)) U32 Some([124, 125, 126, 127])
# Var t28 (t28 Ident("x")) U32 Some([120, 121, 122, 123])
# Var t29 (t29 Ident("a")) U32 Some([108, 109, 110, 111])
# Var t3 (t3 Ident("a")) U32 Some([108, 109, 110, 111])
# Var t30 (t30 Ident("mid")) U32 Some([108, 109, 110, 111])
# Var t31 (t31 Ident("a")) U32 Some([108, 109, 110, 111])
# Var t32 (t32 Ident("x")) U32 Some([120, 121, 122, 123])
# Var t33 (t33 Ident("r")) U32 Some([120, 121, 122, 123])
# Var t34 (t34 Ident("b")) U32 Some([112, 113, 114, 115])
# Var t35 (t35 Ident("mid")) U32 Some([108, 109, 110, 111])
# Var t36 (t36 Ident("mid")) U32 Some([120, 121, 122, 123])
# Var t37 (t37 Number(USIZE, 1)) U32 Some([124, 125, 126, 127])
# Var t38 (t38 Ident("lo")) U32 Some([108, 109, 110, 111])
# Var t4 (t4 Number(USIZE, 256)) U32 Some([116, 117, 118, 119])
# Var t5 (t5 Cast { old_type: None, new_type: Number(USIZE), value: Arithmetic(Divide, Index("a", Number(U8, 0)), Index("b", Number(U8, 0))) }) U32 Some([108, 109, 110, 111])
# Var t6 (t6 Arithmetic(Divide, Index("a", Number(U8, 0)), Index("b", Number(U8, 0)))) U8 Some([136])
# Var t7 (t7 Index("a", Number(U8, 0))) U8 Some([136])
# Var t8 (t8 Index("b", Number(U8, 0))) U8 Some([137])
# Var t9 (t9 Ident("lo")) U32 Some([120, 121, 122, 123])
# Var x (Local x Number(USIZE) U32) U32 Some([132, 133, 134, 135])
# 81dce Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [108, 109, 110, 111].", opcode: Copy32, args: [Register(0x00), Register(0x6c)], resolved: None }
81 00 6c 
# 81dd1 Instruction { source: "Save function parameter 'b' registers [4, 5, 6, 7] to locals [112, 113, 114, 115].", opcode: Copy32, args: [Register(0x04), Register(0x70)], resolved: None }
81 04 70 
# 81dd4 Instruction { source: "t0 <- a U32", opcode: Copy32, args: [Register(0x6c), Register(0x6c)], resolved: None }
81 6c 6c 
# 81dd7 Instruction { source: "t1 <- b U32", opcode: Copy32, args: [Register(0x70), Register(0x70)], resolved: None }
81 70 70 
# 81dda Instruction { source: "if t0 < t1 then 'div16_if_true_0_1' else 'div16_if_else_0_2'", opcode: Cmp8, args: [Register(0x73), Register(0x6f)], resolved: None }
25 73 6f 
# 81ddd Instruction { source: "if t0 < t1 then 'div16_if_true_0_1' else 'div16_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x72), Register(0x6e)], resolved: None }
26 72 6e 
# 81de0 Instruction { source: "if t0 < t1 then 'div16_if_true_0_1' else 'div16_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x71), Register(0x6d)], resolved: None }
26 71 6d 
# 81de3 Instruction { source: "if t0 < t1 then 'div16_if_true_0_1' else 'div16_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x70), Register(0x6c)], resolved: None }
26 70 6c 
# 81de6 Instruction { source: "if t0 < t1 then 'div16_if_true_0_1' else 'div16_if_else_0_2'", opcode: JcImm, args: [Label24(div16_if_else_0_2)], resolved: None }
41 f9 1d 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t0 < t1 then 'div16_if_true_0_1' else 'div16_if_else_0_2'", opcode: JmpImm, args: [Label24(div16_if_true_0_1)], resolved: None }
# div16_if_true_0_1
# 81dea Instruction { source: "t2 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x6c), Constant32(0x00000000=0)], resolved: None }
80 6c 00 00 00 00 
# 81df0 Instruction { source: "return Some(t2)", opcode: Copy32, args: [Register(0x6c), Register(0x00)], resolved: None }
81 6c 00 
# 81df3 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81df5 Instruction { source: "goto div16_if_end_0", opcode: JmpImm, args: [Label24(div16_if_end_0)], resolved: None }
40 f9 1d 08 
# div16_if_else_0_2
# div16_if_end_0
# 81df9 Instruction { source: "t3 <- a U32", opcode: Copy32, args: [Register(0x6c), Register(0x6c)], resolved: None }
81 6c 6c 
# 81dfc Instruction { source: "t4 <- 0n256/0x00000100u32 ", opcode: LoadImm32, args: [Register(0x74), Constant32(0x00000100=256)], resolved: None }
80 74 00 01 00 00 
# 81e02 Instruction { source: "if t3 < t4 then 'div16_if_true_0_4' else 'div16_if_else_0_5'", opcode: Cmp8, args: [Register(0x77), Register(0x6f)], resolved: None }
25 77 6f 
# 81e05 Instruction { source: "if t3 < t4 then 'div16_if_true_0_4' else 'div16_if_else_0_5'", opcode: Cmp8IfZero, args: [Register(0x76), Register(0x6e)], resolved: None }
26 76 6e 
# 81e08 Instruction { source: "if t3 < t4 then 'div16_if_true_0_4' else 'div16_if_else_0_5'", opcode: Cmp8IfZero, args: [Register(0x75), Register(0x6d)], resolved: None }
26 75 6d 
# 81e0b Instruction { source: "if t3 < t4 then 'div16_if_true_0_4' else 'div16_if_else_0_5'", opcode: Cmp8IfZero, args: [Register(0x74), Register(0x6c)], resolved: None }
26 74 6c 
# 81e0e Instruction { source: "if t3 < t4 then 'div16_if_true_0_4' else 'div16_if_else_0_5'", opcode: JcImm, args: [Label24(div16_if_else_0_5)], resolved: None }
41 2e 1e 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t3 < t4 then 'div16_if_true_0_4' else 'div16_if_else_0_5'", opcode: JmpImm, args: [Label24(div16_if_true_0_4)], resolved: None }
# div16_if_true_0_4
# 81e12 Instruction { source: "t7 <- a[0x00..0x01] U8", opcode: Copy8, args: [Register(0x6c), Register(0x88)], resolved: None }
16 6c 88 
# 81e15 Instruction { source: "t8 <- b[0x00..0x01] U8", opcode: Copy8, args: [Register(0x70), Register(0x89)], resolved: None }
16 70 89 
# 81e18 Instruction { source: "t6 <- t7 Divide t8", opcode: Divide8, args: [Register(0x88), Register(0x89), Register(0x88)], resolved: None }
27 88 89 88 
# 81e1c Instruction { source: "Zero-pad for t5 U32 <- t6 U8", opcode: LoadImm32, args: [Register(0x6c), Constant32(0x00000000=0)], resolved: None }
80 6c 00 00 00 00 
# 81e22 Instruction { source: "t5 U32 <- t6 U8", opcode: Copy8, args: [Register(0x88), Register(0x6c)], resolved: None }
16 88 6c 
# 81e25 Instruction { source: "return Some(t5)", opcode: Copy32, args: [Register(0x6c), Register(0x00)], resolved: None }
81 6c 00 
# 81e28 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81e2a Instruction { source: "goto div16_if_end_3", opcode: JmpImm, args: [Label24(div16_if_end_3)], resolved: None }
40 2e 1e 08 
# div16_if_else_0_5
# div16_if_end_3
# 81e2e Instruction { source: "lo <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x78), Constant32(0x00000000=0)], resolved: None }
80 78 00 00 00 00 
# 81e34 Instruction { source: "hi <- 0n65535/0x0000ffffu32 ", opcode: LoadImm32, args: [Register(0x74), Constant32(0x0000ffff=65535)], resolved: None }
80 74 ff ff 00 00 
# div16_while_predicate_6
# 81e3a Instruction { source: "t9 <- lo U32", opcode: Copy32, args: [Register(0x78), Register(0x78)], resolved: None }
81 78 78 
# 81e3d Instruction { source: "t10 <- hi U32", opcode: Copy32, args: [Register(0x74), Register(0x74)], resolved: None }
81 74 74 
# 81e40 Instruction { source: "if t9 < t10 then 'div16_while_body_7' else 'div16_while_end_8'", opcode: Cmp8, args: [Register(0x77), Register(0x7b)], resolved: None }
25 77 7b 
# 81e43 Instruction { source: "if t9 < t10 then 'div16_while_body_7' else 'div16_while_end_8'", opcode: Cmp8IfZero, args: [Register(0x76), Register(0x7a)], resolved: None }
26 76 7a 
# 81e46 Instruction { source: "if t9 < t10 then 'div16_while_body_7' else 'div16_while_end_8'", opcode: Cmp8IfZero, args: [Register(0x75), Register(0x79)], resolved: None }
26 75 79 
# 81e49 Instruction { source: "if t9 < t10 then 'div16_while_body_7' else 'div16_while_end_8'", opcode: Cmp8IfZero, args: [Register(0x74), Register(0x78)], resolved: None }
26 74 78 
# 81e4c Instruction { source: "if t9 < t10 then 'div16_while_body_7' else 'div16_while_end_8'", opcode: JcImm, args: [Label24(div16_while_end_8)], resolved: None }
41 b1 1f 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t9 < t10 then 'div16_while_body_7' else 'div16_while_end_8'", opcode: JmpImm, args: [Label24(div16_while_body_7)], resolved: None }
# div16_while_body_7
# 81e50 Instruction { source: "t12 <- lo U32", opcode: Copy32, args: [Register(0x78), Register(0x78)], resolved: None }
81 78 78 
# 81e53 Instruction { source: "t13 <- hi U32", opcode: Copy32, args: [Register(0x74), Register(0x74)], resolved: None }
81 74 74 
# 81e56 Instruction { source: "t11 <- t12 Add t13", opcode: Add32NoCarryIn, args: [Register(0x78), Register(0x74), Register(0x7c)], resolved: None }
a0 78 74 7c 
# 81e5a Instruction { source: "Arg0[a]=t11 Some(mid) <= call shiftright1(t11,)", opcode: Copy32, args: [Register(0x7c), Register(0x00)], resolved: None }
81 7c 00 
# Registers used by this function: {108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137}
# Registers used by callee tree: {148, 149, 150, 151, 152, 153, 154}
# Registers to save: []
# 81e5d Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81e63 Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 6d 1e 08 00 
# 81e69 Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: JmpImm, args: [Label24(:shiftright1)], resolved: None }
40 07 2b 08 
# 81e6d Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81e73 Instruction { source: "Some(mid) <= call shiftright1(t11,)", opcode: Copy32, args: [Register(0x00), Register(0x7c)], resolved: None }
81 00 7c 
# 81e76 Instruction { source: "t14 <- mid U32", opcode: Copy32, args: [Register(0x7c), Register(0x7c)], resolved: None }
81 7c 7c 
# 81e79 Instruction { source: "t15 <- b U32", opcode: Copy32, args: [Register(0x70), Register(0x70)], resolved: None }
81 70 70 
# 81e7c Instruction { source: "Arg0[a]=t14 Some(x) <= call mul16_32(t14,t15,)", opcode: Copy32, args: [Register(0x7c), Register(0x00)], resolved: None }
81 7c 00 
# 81e7f Instruction { source: "Arg1[b]=t15 Some(x) <= call mul16_32(t14,t15,)", opcode: Copy32, args: [Register(0x70), Register(0x04)], resolved: None }
81 70 04 
# Registers used by this function: {108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137}
# Registers used by callee tree: {216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241}
# Registers to save: []
# 81e82 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81e88 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 92 1e 08 00 
# 81e8e Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: JmpImm, args: [Label24(:mul16_32)], resolved: None }
40 42 24 08 
# 81e92 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81e98 Instruction { source: "Some(x) <= call mul16_32(t14,t15,)", opcode: Copy32, args: [Register(0x00), Register(0x84)], resolved: None }
81 00 84 
# 81e9b Instruction { source: "t16 <- x[0x02..0x03] U8", opcode: Copy8, args: [Register(0x86), Register(0x80)], resolved: None }
16 86 80 
# 81e9e Instruction { source: "t17 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x81), Constant8(0x00=0)], resolved: None }
00 81 00 
# 81ea1 Instruction { source: "if t16 > t17 then 'div16_if_true_0_10' else 'div16_if_else_0_11'", opcode: Cmp8, args: [Register(0x80), Register(0x81)], resolved: None }
25 80 81 
# 81ea4 Instruction { source: "if t16 > t17 then 'div16_if_true_0_10' else 'div16_if_else_0_11'", opcode: JcImm, args: [Label24(div16_if_else_0_11)], resolved: None }
41 ce 1e 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t16 > t17 then 'div16_if_true_0_10' else 'div16_if_else_0_11'", opcode: JmpImm, args: [Label24(div16_if_true_0_10)], resolved: None }
# div16_if_true_0_10
# 81ea8 Instruction { source: "t18 <- mid U32", opcode: Copy32, args: [Register(0x7c), Register(0x74)], resolved: None }
81 7c 74 
# 81eab Instruction { source: "t19 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x7c), Constant32(0x00000001=1)], resolved: None }
80 7c 01 00 00 00 
# 81eb1 Instruction { source: "hi <- t18 Subtract t19", opcode: Copy32, args: [Register(0x7c), Register(0x00)], resolved: None }
81 7c 00 
# 81eb4 Instruction { source: "hi <- t18 Subtract t19", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 81eb6 Instruction { source: "hi <- t18 Subtract t19", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 81eb8 Instruction { source: "hi <- t18 Subtract t19", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 81eba Instruction { source: "hi <- t18 Subtract t19", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 81ebc Instruction { source: "hi <- t18 Subtract t19", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 81ec2 Instruction { source: "hi <- t18 Subtract t19", opcode: Add32NoCarryIn, args: [Register(0x74), Register(0x00), Register(0x74)], resolved: None }
a0 74 00 74 
# 81ec6 Instruction { source: "goto div16_while_predicate_6", opcode: JmpImm, args: [Label24(div16_while_predicate_6)], resolved: None }
40 3a 1e 08 
# 81eca Instruction { source: "goto div16_if_end_9", opcode: JmpImm, args: [Label24(div16_if_end_9)], resolved: None }
40 ce 1e 08 
# div16_if_else_0_11
# div16_if_end_9
# 81ece Instruction { source: "t20 <- x[0x03..0x04] U8", opcode: Copy8, args: [Register(0x87), Register(0x80)], resolved: None }
16 87 80 
# 81ed1 Instruction { source: "t21 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x81), Constant8(0x00=0)], resolved: None }
00 81 00 
# 81ed4 Instruction { source: "if t20 > t21 then 'div16_if_true_0_13' else 'div16_if_else_0_14'", opcode: Cmp8, args: [Register(0x80), Register(0x81)], resolved: None }
25 80 81 
# 81ed7 Instruction { source: "if t20 > t21 then 'div16_if_true_0_13' else 'div16_if_else_0_14'", opcode: JcImm, args: [Label24(div16_if_else_0_14)], resolved: None }
41 01 1f 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t20 > t21 then 'div16_if_true_0_13' else 'div16_if_else_0_14'", opcode: JmpImm, args: [Label24(div16_if_true_0_13)], resolved: None }
# div16_if_true_0_13
# 81edb Instruction { source: "t22 <- mid U32", opcode: Copy32, args: [Register(0x7c), Register(0x74)], resolved: None }
81 7c 74 
# 81ede Instruction { source: "t23 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x7c), Constant32(0x00000001=1)], resolved: None }
80 7c 01 00 00 00 
# 81ee4 Instruction { source: "hi <- t22 Subtract t23", opcode: Copy32, args: [Register(0x7c), Register(0x00)], resolved: None }
81 7c 00 
# 81ee7 Instruction { source: "hi <- t22 Subtract t23", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 81ee9 Instruction { source: "hi <- t22 Subtract t23", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 81eeb Instruction { source: "hi <- t22 Subtract t23", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 81eed Instruction { source: "hi <- t22 Subtract t23", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 81eef Instruction { source: "hi <- t22 Subtract t23", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 81ef5 Instruction { source: "hi <- t22 Subtract t23", opcode: Add32NoCarryIn, args: [Register(0x74), Register(0x00), Register(0x74)], resolved: None }
a0 74 00 74 
# 81ef9 Instruction { source: "goto div16_while_predicate_6", opcode: JmpImm, args: [Label24(div16_while_predicate_6)], resolved: None }
40 3a 1e 08 
# 81efd Instruction { source: "goto div16_if_end_12", opcode: JmpImm, args: [Label24(div16_if_end_12)], resolved: None }
40 01 1f 08 
# div16_if_else_0_14
# div16_if_end_12
# 81f01 Instruction { source: "t24 <- x U32", opcode: Copy32, args: [Register(0x84), Register(0x84)], resolved: None }
81 84 84 
# 81f04 Instruction { source: "t25 <- a U32", opcode: Copy32, args: [Register(0x6c), Register(0x6c)], resolved: None }
81 6c 6c 
# 81f07 Instruction { source: "if t24 > t25 then 'div16_if_true_0_16' else 'div16_if_else_0_17'", opcode: Cmp8, args: [Register(0x87), Register(0x6f)], resolved: None }
25 87 6f 
# 81f0a Instruction { source: "if t24 > t25 then 'div16_if_true_0_16' else 'div16_if_else_0_17'", opcode: Cmp8IfZero, args: [Register(0x86), Register(0x6e)], resolved: None }
26 86 6e 
# 81f0d Instruction { source: "if t24 > t25 then 'div16_if_true_0_16' else 'div16_if_else_0_17'", opcode: Cmp8IfZero, args: [Register(0x85), Register(0x6d)], resolved: None }
26 85 6d 
# 81f10 Instruction { source: "if t24 > t25 then 'div16_if_true_0_16' else 'div16_if_else_0_17'", opcode: Cmp8IfZero, args: [Register(0x84), Register(0x6c)], resolved: None }
26 84 6c 
# 81f13 Instruction { source: "if t24 > t25 then 'div16_if_true_0_16' else 'div16_if_else_0_17'", opcode: JcImm, args: [Label24(div16_if_else_0_17)], resolved: None }
41 3d 1f 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t24 > t25 then 'div16_if_true_0_16' else 'div16_if_else_0_17'", opcode: JmpImm, args: [Label24(div16_if_true_0_16)], resolved: None }
# div16_if_true_0_16
# 81f17 Instruction { source: "t26 <- mid U32", opcode: Copy32, args: [Register(0x7c), Register(0x74)], resolved: None }
81 7c 74 
# 81f1a Instruction { source: "t27 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x7c), Constant32(0x00000001=1)], resolved: None }
80 7c 01 00 00 00 
# 81f20 Instruction { source: "hi <- t26 Subtract t27", opcode: Copy32, args: [Register(0x7c), Register(0x00)], resolved: None }
81 7c 00 
# 81f23 Instruction { source: "hi <- t26 Subtract t27", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 81f25 Instruction { source: "hi <- t26 Subtract t27", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 81f27 Instruction { source: "hi <- t26 Subtract t27", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 81f29 Instruction { source: "hi <- t26 Subtract t27", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 81f2b Instruction { source: "hi <- t26 Subtract t27", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 81f31 Instruction { source: "hi <- t26 Subtract t27", opcode: Add32NoCarryIn, args: [Register(0x74), Register(0x00), Register(0x74)], resolved: None }
a0 74 00 74 
# 81f35 Instruction { source: "goto div16_while_predicate_6", opcode: JmpImm, args: [Label24(div16_while_predicate_6)], resolved: None }
40 3a 1e 08 
# 81f39 Instruction { source: "goto div16_if_end_15", opcode: JmpImm, args: [Label24(div16_if_end_15)], resolved: None }
40 3d 1f 08 
# div16_if_else_0_17
# div16_if_end_15
# 81f3d Instruction { source: "t28 <- x U32", opcode: Copy32, args: [Register(0x84), Register(0x78)], resolved: None }
81 84 78 
# 81f40 Instruction { source: "t29 <- a U32", opcode: Copy32, args: [Register(0x6c), Register(0x6c)], resolved: None }
81 6c 6c 
# 81f43 Instruction { source: "if t28 == t29 then 'div16_if_true_0_19' else 'div16_if_else_0_20'", opcode: Cmp8, args: [Register(0x7b), Register(0x6f)], resolved: None }
25 7b 6f 
# 81f46 Instruction { source: "if t28 == t29 then 'div16_if_true_0_19' else 'div16_if_else_0_20'", opcode: Cmp8IfZero, args: [Register(0x7a), Register(0x6e)], resolved: None }
26 7a 6e 
# 81f49 Instruction { source: "if t28 == t29 then 'div16_if_true_0_19' else 'div16_if_else_0_20'", opcode: Cmp8IfZero, args: [Register(0x79), Register(0x6d)], resolved: None }
26 79 6d 
# 81f4c Instruction { source: "if t28 == t29 then 'div16_if_true_0_19' else 'div16_if_else_0_20'", opcode: Cmp8IfZero, args: [Register(0x78), Register(0x6c)], resolved: None }
26 78 6c 
# 81f4f Instruction { source: "if t28 == t29 then 'div16_if_true_0_19' else 'div16_if_else_0_20'", opcode: JzImm, args: [Label24(div16_if_true_0_19)], resolved: None }
42 57 1f 08 
# 81f53 Instruction { source: "if t28 == t29 then 'div16_if_true_0_19' else 'div16_if_else_0_20'", opcode: JmpImm, args: [Label24(div16_if_else_0_20)], resolved: None }
40 63 1f 08 
# div16_if_true_0_19
# 81f57 Instruction { source: "t30 <- mid U32", opcode: Copy32, args: [Register(0x7c), Register(0x6c)], resolved: None }
81 7c 6c 
# 81f5a Instruction { source: "return Some(t30)", opcode: Copy32, args: [Register(0x6c), Register(0x00)], resolved: None }
81 6c 00 
# 81f5d Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81f5f Instruction { source: "goto div16_if_end_18", opcode: JmpImm, args: [Label24(div16_if_end_18)], resolved: None }
40 63 1f 08 
# div16_if_else_0_20
# div16_if_end_18
# 81f63 Instruction { source: "t31 <- a U32", opcode: Copy32, args: [Register(0x6c), Register(0x6c)], resolved: None }
81 6c 6c 
# 81f66 Instruction { source: "t32 <- x U32", opcode: Copy32, args: [Register(0x84), Register(0x78)], resolved: None }
81 84 78 
# 81f69 Instruction { source: "r <- t31 Subtract t32", opcode: Copy32, args: [Register(0x78), Register(0x00)], resolved: None }
81 78 00 
# 81f6c Instruction { source: "r <- t31 Subtract t32", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 81f6e Instruction { source: "r <- t31 Subtract t32", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 81f70 Instruction { source: "r <- t31 Subtract t32", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 81f72 Instruction { source: "r <- t31 Subtract t32", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 81f74 Instruction { source: "r <- t31 Subtract t32", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 81f7a Instruction { source: "r <- t31 Subtract t32", opcode: Add32NoCarryIn, args: [Register(0x6c), Register(0x00), Register(0x78)], resolved: None }
a0 6c 00 78 
# 81f7e Instruction { source: "t33 <- r U32", opcode: Copy32, args: [Register(0x78), Register(0x78)], resolved: None }
81 78 78 
# 81f81 Instruction { source: "t34 <- b U32", opcode: Copy32, args: [Register(0x70), Register(0x70)], resolved: None }
81 70 70 
# 81f84 Instruction { source: "if t33 < t34 then 'div16_if_true_0_22' else 'div16_if_else_0_23'", opcode: Cmp8, args: [Register(0x73), Register(0x7b)], resolved: None }
25 73 7b 
# 81f87 Instruction { source: "if t33 < t34 then 'div16_if_true_0_22' else 'div16_if_else_0_23'", opcode: Cmp8IfZero, args: [Register(0x72), Register(0x7a)], resolved: None }
26 72 7a 
# 81f8a Instruction { source: "if t33 < t34 then 'div16_if_true_0_22' else 'div16_if_else_0_23'", opcode: Cmp8IfZero, args: [Register(0x71), Register(0x79)], resolved: None }
26 71 79 
# 81f8d Instruction { source: "if t33 < t34 then 'div16_if_true_0_22' else 'div16_if_else_0_23'", opcode: Cmp8IfZero, args: [Register(0x70), Register(0x78)], resolved: None }
26 70 78 
# 81f90 Instruction { source: "if t33 < t34 then 'div16_if_true_0_22' else 'div16_if_else_0_23'", opcode: JcImm, args: [Label24(div16_if_else_0_23)], resolved: None }
41 a0 1f 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t33 < t34 then 'div16_if_true_0_22' else 'div16_if_else_0_23'", opcode: JmpImm, args: [Label24(div16_if_true_0_22)], resolved: None }
# div16_if_true_0_22
# 81f94 Instruction { source: "t35 <- mid U32", opcode: Copy32, args: [Register(0x7c), Register(0x6c)], resolved: None }
81 7c 6c 
# 81f97 Instruction { source: "return Some(t35)", opcode: Copy32, args: [Register(0x6c), Register(0x00)], resolved: None }
81 6c 00 
# 81f9a Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81f9c Instruction { source: "goto div16_if_end_21", opcode: JmpImm, args: [Label24(div16_if_end_21)], resolved: None }
40 a0 1f 08 
# div16_if_else_0_23
# div16_if_end_21
# 81fa0 Instruction { source: "t36 <- mid U32", opcode: Copy32, args: [Register(0x7c), Register(0x78)], resolved: None }
81 7c 78 
# 81fa3 Instruction { source: "t37 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x7c), Constant32(0x00000001=1)], resolved: None }
80 7c 01 00 00 00 
# 81fa9 Instruction { source: "lo <- t36 Add t37", opcode: Add32NoCarryIn, args: [Register(0x78), Register(0x7c), Register(0x78)], resolved: None }
a0 78 7c 78 
# 81fad Instruction { source: "goto div16_while_predicate_6", opcode: JmpImm, args: [Label24(div16_while_predicate_6)], resolved: None }
40 3a 1e 08 
# div16_while_end_8
# 81fb1 Instruction { source: "t38 <- lo U32", opcode: Copy32, args: [Register(0x78), Register(0x6c)], resolved: None }
81 78 6c 
# 81fb4 Instruction { source: "return Some(t38)", opcode: Copy32, args: [Register(0x6c), Register(0x00)], resolved: None }
81 6c 00 
# 81fb7 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81fb9 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :div32
# Ret Some(U32)
# Arg0=a
# Arg1=b
# Var __frame_pointer (__frame_pointer) U32 Some([12, 13, 14, 15])
# Var a (Arg0 a Number(USIZE)) U32 Some([140, 141, 142, 143])
# Var b (Arg1 b Number(USIZE)) U32 Some([144, 145, 146, 147])
# Var hi (Local hi Number(USIZE) U32) U32 Some([148, 149, 150, 151])
# Var lo (Local lo Number(USIZE) U32) U32 Some([152, 153, 154, 155])
# Var mid (Local mid Number(USIZE) U32) U32 Some([156, 157, 158, 159])
# Var r (Local r Number(USIZE) U32) U32 Some([152, 153, 154, 155])
# Var t0 (Stack size negated) U32 Some([148, 149, 150, 151])
# Var t1 (t1 Ident("a")) U32 Some([140, 141, 142, 143])
# Var t10 (Stack size) U32 Some([140, 141, 142, 143])
# Var t11 (t11 Ident("lo")) U32 Some([152, 153, 154, 155])
# Var t12 (t12 Ident("hi")) U32 Some([148, 149, 150, 151])
# Var t13 (t13 Call(Call { function: "shiftright1", parameters: [Ident("lo")] })) U32 Some([156, 157, 158, 159])
# Var t14 (t14 Ident("lo")) U32 Some([152, 153, 154, 155])
# Var t15 (t15 Call(Call { function: "shiftright1", parameters: [Ident("hi")] })) U32 Some([160, 161, 162, 163])
# Var t16 (t16 Ident("hi")) U32 Some([148, 149, 150, 151])
# Var t17 (t17 Call(Call { function: "mul32_64", parameters: [Ident("mid"), Ident("b"), AddressOf(Ident("x64"))] })) U8 Some([164])
# Var t18 (t18 Ident("mid")) U32 Some([156, 157, 158, 159])
# Var t19 (t19 Ident("b")) U32 Some([144, 145, 146, 147])
# Var t2 (t2 Ident("b")) U32 Some([144, 145, 146, 147])
# Var t20 (t20 AddressOf(Ident("x64"))) U32 Some([160, 161, 162, 163])
# Var t21 (t21 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([160, 161, 162, 163])
# Var t22 (t22 Ident("__frame_pointer")) U32 Some([168, 169, 170, 171])
# Var t23 (t23 Number(USIZE, 0)) U32 Some([160, 161, 162, 163])
# Var t24 (t24 LocalFieldDeref("x64", "hi")) U32 Some([160, 161, 162, 163])
# Var t25 (t25 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 4)) }) U32 Some([160, 161, 162, 163])
# Var t26 (t26 Ident("__frame_pointer")) U32 Some([168, 169, 170, 171])
# Var t27 (t27 Number(USIZE, 4)) U32 Some([160, 161, 162, 163])
# Var t28 (t28 Number(USIZE, 0)) U32 Some([172, 173, 174, 175])
# Var t29 (t29 Ident("mid")) U32 Some([148, 149, 150, 151])
# Var t3 (t3 Number(USIZE, 0)) U32 Some([140, 141, 142, 143])
# Var t30 (t30 Number(USIZE, 1)) U32 Some([156, 157, 158, 159])
# Var t31 (t31 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Ident("__frame_pointer") }) U32 Some([168, 169, 170, 171])
# Var t32 (t32 Ident("x")) U32 Some([160, 161, 162, 163])
# Var t33 (t33 Ident("a")) U32 Some([140, 141, 142, 143])
# Var t34 (t34 Ident("mid")) U32 Some([148, 149, 150, 151])
# Var t35 (t35 Number(USIZE, 1)) U32 Some([156, 157, 158, 159])
# Var t36 (t36 Ident("x")) U32 Some([152, 153, 154, 155])
# Var t37 (t37 Ident("a")) U32 Some([140, 141, 142, 143])
# Var t38 (t38 Ident("mid")) U32 Some([140, 141, 142, 143])
# Var t39 (Stack size) U32 Some([144, 145, 146, 147])
# Var t4 (Stack size) U32 Some([144, 145, 146, 147])
# Var t40 (t40 Ident("a")) U32 Some([140, 141, 142, 143])
# Var t41 (t41 Ident("x")) U32 Some([152, 153, 154, 155])
# Var t42 (t42 Ident("r")) U32 Some([152, 153, 154, 155])
# Var t43 (t43 Ident("b")) U32 Some([144, 145, 146, 147])
# Var t44 (t44 Ident("mid")) U32 Some([140, 141, 142, 143])
# Var t45 (Stack size) U32 Some([144, 145, 146, 147])
# Var t46 (t46 Ident("mid")) U32 Some([152, 153, 154, 155])
# Var t47 (t47 Number(USIZE, 1)) U32 Some([156, 157, 158, 159])
# Var t48 (t48 Ident("lo")) U32 Some([140, 141, 142, 143])
# Var t49 (Stack size) U32 Some([144, 145, 146, 147])
# Var t5 (t5 Ident("a")) U32 Some([140, 141, 142, 143])
# Var t6 (t6 Number(USIZE, 65536)) U32 Some([148, 149, 150, 151])
# Var t7 (t7 Call(Call { function: "div16", parameters: [Ident("a"), Ident("b")] })) U32 Some([144, 145, 146, 147])
# Var t8 (t8 Ident("a")) U32 Some([140, 141, 142, 143])
# Var t9 (t9 Ident("b")) U32 Some([144, 145, 146, 147])
# Var x (Local x Number(USIZE) U32) U32 Some([160, 161, 162, 163])
# Var x64 (Local x64 Struct("U64") FrameOffset(0)) FrameOffset(0) None
# 81fbe Instruction { source: "reserve 8 bytes of stack space for locals", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffff8=4294967288)], resolved: None }
a3 0c f8 ff ff ff 
# 81fc4 Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [140, 141, 142, 143].", opcode: Copy32, args: [Register(0x00), Register(0x8c)], resolved: None }
81 00 8c 
# 81fc7 Instruction { source: "Save function parameter 'b' registers [4, 5, 6, 7] to locals [144, 145, 146, 147].", opcode: Copy32, args: [Register(0x04), Register(0x90)], resolved: None }
81 04 90 
# 81fca Instruction { source: "t0 <- 0xfffffff8u32 ", opcode: LoadImm32, args: [Register(0x94), Constant32(0xfffffff8=4294967288)], resolved: None }
80 94 f8 ff ff ff 
# 81fd0 Instruction { source: "__frame_pointer <- __frame_pointer Add t0", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x94), Register(0x0c)], resolved: None }
a0 0c 94 0c 
# 81fd4 Instruction { source: "t1 <- a U32", opcode: Copy32, args: [Register(0x8c), Register(0x8c)], resolved: None }
81 8c 8c 
# 81fd7 Instruction { source: "t2 <- b U32", opcode: Copy32, args: [Register(0x90), Register(0x90)], resolved: None }
81 90 90 
# 81fda Instruction { source: "if t1 < t2 then 'div32_if_true_0_1' else 'div32_if_else_0_2'", opcode: Cmp8, args: [Register(0x93), Register(0x8f)], resolved: None }
25 93 8f 
# 81fdd Instruction { source: "if t1 < t2 then 'div32_if_true_0_1' else 'div32_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x92), Register(0x8e)], resolved: None }
26 92 8e 
# 81fe0 Instruction { source: "if t1 < t2 then 'div32_if_true_0_1' else 'div32_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x91), Register(0x8d)], resolved: None }
26 91 8d 
# 81fe3 Instruction { source: "if t1 < t2 then 'div32_if_true_0_1' else 'div32_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x90), Register(0x8c)], resolved: None }
26 90 8c 
# 81fe6 Instruction { source: "if t1 < t2 then 'div32_if_true_0_1' else 'div32_if_else_0_2'", opcode: JcImm, args: [Label24(div32_if_else_0_2)], resolved: None }
41 09 20 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t1 < t2 then 'div32_if_true_0_1' else 'div32_if_else_0_2'", opcode: JmpImm, args: [Label24(div32_if_true_0_1)], resolved: None }
# div32_if_true_0_1
# 81fea Instruction { source: "t3 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x8c), Constant32(0x00000000=0)], resolved: None }
80 8c 00 00 00 00 
# 81ff0 Instruction { source: "t4 <- 0n8/0x00000008u32 ", opcode: LoadImm32, args: [Register(0x90), Constant32(0x00000008=8)], resolved: None }
80 90 08 00 00 00 
# 81ff6 Instruction { source: "__frame_pointer <- __frame_pointer Add t4", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x90), Register(0x0c)], resolved: None }
a0 0c 90 0c 
# 81ffa Instruction { source: "return Some(t3)", opcode: Copy32, args: [Register(0x8c), Register(0x00)], resolved: None }
81 8c 00 
# 81ffd Instruction { source: "Dealloc 8 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000008=8)], resolved: None }
a3 0c 08 00 00 00 
# 82003 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82005 Instruction { source: "goto div32_if_end_0", opcode: JmpImm, args: [Label24(div32_if_end_0)], resolved: None }
40 09 20 08 
# div32_if_else_0_2
# div32_if_end_0
# 82009 Instruction { source: "t5 <- a U32", opcode: Copy32, args: [Register(0x8c), Register(0x8c)], resolved: None }
81 8c 8c 
# 8200c Instruction { source: "t6 <- 0n65536/0x00010000u32 ", opcode: LoadImm32, args: [Register(0x94), Constant32(0x00010000=65536)], resolved: None }
80 94 00 00 01 00 
# 82012 Instruction { source: "if t5 < t6 then 'div32_if_true_0_4' else 'div32_if_else_0_5'", opcode: Cmp8, args: [Register(0x97), Register(0x8f)], resolved: None }
25 97 8f 
# 82015 Instruction { source: "if t5 < t6 then 'div32_if_true_0_4' else 'div32_if_else_0_5'", opcode: Cmp8IfZero, args: [Register(0x96), Register(0x8e)], resolved: None }
26 96 8e 
# 82018 Instruction { source: "if t5 < t6 then 'div32_if_true_0_4' else 'div32_if_else_0_5'", opcode: Cmp8IfZero, args: [Register(0x95), Register(0x8d)], resolved: None }
26 95 8d 
# 8201b Instruction { source: "if t5 < t6 then 'div32_if_true_0_4' else 'div32_if_else_0_5'", opcode: Cmp8IfZero, args: [Register(0x94), Register(0x8c)], resolved: None }
26 94 8c 
# 8201e Instruction { source: "if t5 < t6 then 'div32_if_true_0_4' else 'div32_if_else_0_5'", opcode: JcImm, args: [Label24(div32_if_else_0_5)], resolved: None }
41 7c 20 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t5 < t6 then 'div32_if_true_0_4' else 'div32_if_else_0_5'", opcode: JmpImm, args: [Label24(div32_if_true_0_4)], resolved: None }
# div32_if_true_0_4
# 82022 Instruction { source: "t8 <- a U32", opcode: Copy32, args: [Register(0x8c), Register(0x8c)], resolved: None }
81 8c 8c 
# 82025 Instruction { source: "t9 <- b U32", opcode: Copy32, args: [Register(0x90), Register(0x90)], resolved: None }
81 90 90 
# 82028 Instruction { source: "Arg0[a]=t8 Some(t7) <= call div16(t8,t9,)", opcode: Copy32, args: [Register(0x8c), Register(0x00)], resolved: None }
81 8c 00 
# 8202b Instruction { source: "Arg1[b]=t9 Some(t7) <= call div16(t8,t9,)", opcode: Copy32, args: [Register(0x90), Register(0x04)], resolved: None }
81 90 04 
# Registers used by this function: {140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 168, 169, 170, 171, 172, 173, 174, 175}
# Registers used by callee tree: {108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137, 148, 149, 150, 151, 152, 153, 154, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241}
# Registers to save: [148, 149, 150, 151, 152, 153, 154]
# 8202e Instruction { source: "Saving reg0x9a before Some(t7) <= call div16(t8,t9,)", opcode: Push8, args: [Register(0x9a)], resolved: None }
14 9a 
# 82030 Instruction { source: "Saving reg0x99 before Some(t7) <= call div16(t8,t9,)", opcode: Push8, args: [Register(0x99)], resolved: None }
14 99 
# 82032 Instruction { source: "Saving reg0x98 before Some(t7) <= call div16(t8,t9,)", opcode: Push8, args: [Register(0x98)], resolved: None }
14 98 
# 82034 Instruction { source: "Saving reg0x97 before Some(t7) <= call div16(t8,t9,)", opcode: Push8, args: [Register(0x97)], resolved: None }
14 97 
# 82036 Instruction { source: "Saving reg0x96 before Some(t7) <= call div16(t8,t9,)", opcode: Push8, args: [Register(0x96)], resolved: None }
14 96 
# 82038 Instruction { source: "Saving reg0x95 before Some(t7) <= call div16(t8,t9,)", opcode: Push8, args: [Register(0x95)], resolved: None }
14 95 
# 8203a Instruction { source: "Saving reg0x94 before Some(t7) <= call div16(t8,t9,)", opcode: Push8, args: [Register(0x94)], resolved: None }
14 94 
# 8203c Instruction { source: "PseudoCall(Label24(:div16))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82042 Instruction { source: "PseudoCall(Label24(:div16))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 4c 20 08 00 
# 82048 Instruction { source: "PseudoCall(Label24(:div16))", opcode: JmpImm, args: [Label24(:div16)], resolved: None }
40 ce 1d 08 
# 8204c Instruction { source: "PseudoCall(Label24(:div16))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82052 Instruction { source: "Restoring reg0x94 after Some(t7) <= call div16(t8,t9,)", opcode: Pop8, args: [Register(0x94)], resolved: None }
15 94 
# 82054 Instruction { source: "Restoring reg0x95 after Some(t7) <= call div16(t8,t9,)", opcode: Pop8, args: [Register(0x95)], resolved: None }
15 95 
# 82056 Instruction { source: "Restoring reg0x96 after Some(t7) <= call div16(t8,t9,)", opcode: Pop8, args: [Register(0x96)], resolved: None }
15 96 
# 82058 Instruction { source: "Restoring reg0x97 after Some(t7) <= call div16(t8,t9,)", opcode: Pop8, args: [Register(0x97)], resolved: None }
15 97 
# 8205a Instruction { source: "Restoring reg0x98 after Some(t7) <= call div16(t8,t9,)", opcode: Pop8, args: [Register(0x98)], resolved: None }
15 98 
# 8205c Instruction { source: "Restoring reg0x99 after Some(t7) <= call div16(t8,t9,)", opcode: Pop8, args: [Register(0x99)], resolved: None }
15 99 
# 8205e Instruction { source: "Restoring reg0x9a after Some(t7) <= call div16(t8,t9,)", opcode: Pop8, args: [Register(0x9a)], resolved: None }
15 9a 
# 82060 Instruction { source: "Some(t7) <= call div16(t8,t9,)", opcode: Copy32, args: [Register(0x00), Register(0x90)], resolved: None }
81 00 90 
# 82063 Instruction { source: "t10 <- 0n8/0x00000008u32 ", opcode: LoadImm32, args: [Register(0x8c), Constant32(0x00000008=8)], resolved: None }
80 8c 08 00 00 00 
# 82069 Instruction { source: "__frame_pointer <- __frame_pointer Add t10", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x8c), Register(0x0c)], resolved: None }
a0 0c 8c 0c 
# 8206d Instruction { source: "return Some(t7)", opcode: Copy32, args: [Register(0x90), Register(0x00)], resolved: None }
81 90 00 
# 82070 Instruction { source: "Dealloc 8 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000008=8)], resolved: None }
a3 0c 08 00 00 00 
# 82076 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82078 Instruction { source: "goto div32_if_end_3", opcode: JmpImm, args: [Label24(div32_if_end_3)], resolved: None }
40 7c 20 08 
# div32_if_else_0_5
# div32_if_end_3
# 8207c Instruction { source: "lo <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x98), Constant32(0x00000000=0)], resolved: None }
80 98 00 00 00 00 
# 82082 Instruction { source: "hi <- 0xffffffffu32 ", opcode: LoadImm32, args: [Register(0x94), Constant32(0xffffffff=4294967295)], resolved: None }
80 94 ff ff ff ff 
# div32_while_predicate_6
# 82088 Instruction { source: "t11 <- lo U32", opcode: Copy32, args: [Register(0x98), Register(0x98)], resolved: None }
81 98 98 
# 8208b Instruction { source: "t12 <- hi U32", opcode: Copy32, args: [Register(0x94), Register(0x94)], resolved: None }
81 94 94 
# 8208e Instruction { source: "if t11 < t12 then 'div32_while_body_7' else 'div32_while_end_8'", opcode: Cmp8, args: [Register(0x97), Register(0x9b)], resolved: None }
25 97 9b 
# 82091 Instruction { source: "if t11 < t12 then 'div32_while_body_7' else 'div32_while_end_8'", opcode: Cmp8IfZero, args: [Register(0x96), Register(0x9a)], resolved: None }
26 96 9a 
# 82094 Instruction { source: "if t11 < t12 then 'div32_while_body_7' else 'div32_while_end_8'", opcode: Cmp8IfZero, args: [Register(0x95), Register(0x99)], resolved: None }
26 95 99 
# 82097 Instruction { source: "if t11 < t12 then 'div32_while_body_7' else 'div32_while_end_8'", opcode: Cmp8IfZero, args: [Register(0x94), Register(0x98)], resolved: None }
26 94 98 
# 8209a Instruction { source: "if t11 < t12 then 'div32_while_body_7' else 'div32_while_end_8'", opcode: JcImm, args: [Label24(div32_while_end_8)], resolved: None }
41 6f 22 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t11 < t12 then 'div32_while_body_7' else 'div32_while_end_8'", opcode: JmpImm, args: [Label24(div32_while_body_7)], resolved: None }
# div32_while_body_7
# 8209e Instruction { source: "t14 <- lo U32", opcode: Copy32, args: [Register(0x98), Register(0x98)], resolved: None }
81 98 98 
# 820a1 Instruction { source: "Arg0[a]=t14 Some(t13) <= call shiftright1(t14,)", opcode: Copy32, args: [Register(0x98), Register(0x00)], resolved: None }
81 98 00 
# Registers used by this function: {140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 168, 169, 170, 171, 172, 173, 174, 175}
# Registers used by callee tree: {148, 149, 150, 151, 152, 153, 154}
# Registers to save: [148, 149, 150, 151, 152, 153, 154]
# 820a4 Instruction { source: "Saving reg0x9a before Some(t13) <= call shiftright1(t14,)", opcode: Push8, args: [Register(0x9a)], resolved: None }
14 9a 
# 820a6 Instruction { source: "Saving reg0x99 before Some(t13) <= call shiftright1(t14,)", opcode: Push8, args: [Register(0x99)], resolved: None }
14 99 
# 820a8 Instruction { source: "Saving reg0x98 before Some(t13) <= call shiftright1(t14,)", opcode: Push8, args: [Register(0x98)], resolved: None }
14 98 
# 820aa Instruction { source: "Saving reg0x97 before Some(t13) <= call shiftright1(t14,)", opcode: Push8, args: [Register(0x97)], resolved: None }
14 97 
# 820ac Instruction { source: "Saving reg0x96 before Some(t13) <= call shiftright1(t14,)", opcode: Push8, args: [Register(0x96)], resolved: None }
14 96 
# 820ae Instruction { source: "Saving reg0x95 before Some(t13) <= call shiftright1(t14,)", opcode: Push8, args: [Register(0x95)], resolved: None }
14 95 
# 820b0 Instruction { source: "Saving reg0x94 before Some(t13) <= call shiftright1(t14,)", opcode: Push8, args: [Register(0x94)], resolved: None }
14 94 
# 820b2 Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 820b8 Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c c2 20 08 00 
# 820be Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: JmpImm, args: [Label24(:shiftright1)], resolved: None }
40 07 2b 08 
# 820c2 Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 820c8 Instruction { source: "Restoring reg0x94 after Some(t13) <= call shiftright1(t14,)", opcode: Pop8, args: [Register(0x94)], resolved: None }
15 94 
# 820ca Instruction { source: "Restoring reg0x95 after Some(t13) <= call shiftright1(t14,)", opcode: Pop8, args: [Register(0x95)], resolved: None }
15 95 
# 820cc Instruction { source: "Restoring reg0x96 after Some(t13) <= call shiftright1(t14,)", opcode: Pop8, args: [Register(0x96)], resolved: None }
15 96 
# 820ce Instruction { source: "Restoring reg0x97 after Some(t13) <= call shiftright1(t14,)", opcode: Pop8, args: [Register(0x97)], resolved: None }
15 97 
# 820d0 Instruction { source: "Restoring reg0x98 after Some(t13) <= call shiftright1(t14,)", opcode: Pop8, args: [Register(0x98)], resolved: None }
15 98 
# 820d2 Instruction { source: "Restoring reg0x99 after Some(t13) <= call shiftright1(t14,)", opcode: Pop8, args: [Register(0x99)], resolved: None }
15 99 
# 820d4 Instruction { source: "Restoring reg0x9a after Some(t13) <= call shiftright1(t14,)", opcode: Pop8, args: [Register(0x9a)], resolved: None }
15 9a 
# 820d6 Instruction { source: "Some(t13) <= call shiftright1(t14,)", opcode: Copy32, args: [Register(0x00), Register(0x9c)], resolved: None }
81 00 9c 
# 820d9 Instruction { source: "t16 <- hi U32", opcode: Copy32, args: [Register(0x94), Register(0x94)], resolved: None }
81 94 94 
# 820dc Instruction { source: "Arg0[a]=t16 Some(t15) <= call shiftright1(t16,)", opcode: Copy32, args: [Register(0x94), Register(0x00)], resolved: None }
81 94 00 
# Registers used by this function: {140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 168, 169, 170, 171, 172, 173, 174, 175}
# Registers used by callee tree: {148, 149, 150, 151, 152, 153, 154}
# Registers to save: [148, 149, 150, 151, 152, 153, 154]
# 820df Instruction { source: "Saving reg0x9a before Some(t15) <= call shiftright1(t16,)", opcode: Push8, args: [Register(0x9a)], resolved: None }
14 9a 
# 820e1 Instruction { source: "Saving reg0x99 before Some(t15) <= call shiftright1(t16,)", opcode: Push8, args: [Register(0x99)], resolved: None }
14 99 
# 820e3 Instruction { source: "Saving reg0x98 before Some(t15) <= call shiftright1(t16,)", opcode: Push8, args: [Register(0x98)], resolved: None }
14 98 
# 820e5 Instruction { source: "Saving reg0x97 before Some(t15) <= call shiftright1(t16,)", opcode: Push8, args: [Register(0x97)], resolved: None }
14 97 
# 820e7 Instruction { source: "Saving reg0x96 before Some(t15) <= call shiftright1(t16,)", opcode: Push8, args: [Register(0x96)], resolved: None }
14 96 
# 820e9 Instruction { source: "Saving reg0x95 before Some(t15) <= call shiftright1(t16,)", opcode: Push8, args: [Register(0x95)], resolved: None }
14 95 
# 820eb Instruction { source: "Saving reg0x94 before Some(t15) <= call shiftright1(t16,)", opcode: Push8, args: [Register(0x94)], resolved: None }
14 94 
# 820ed Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 820f3 Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c fd 20 08 00 
# 820f9 Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: JmpImm, args: [Label24(:shiftright1)], resolved: None }
40 07 2b 08 
# 820fd Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82103 Instruction { source: "Restoring reg0x94 after Some(t15) <= call shiftright1(t16,)", opcode: Pop8, args: [Register(0x94)], resolved: None }
15 94 
# 82105 Instruction { source: "Restoring reg0x95 after Some(t15) <= call shiftright1(t16,)", opcode: Pop8, args: [Register(0x95)], resolved: None }
15 95 
# 82107 Instruction { source: "Restoring reg0x96 after Some(t15) <= call shiftright1(t16,)", opcode: Pop8, args: [Register(0x96)], resolved: None }
15 96 
# 82109 Instruction { source: "Restoring reg0x97 after Some(t15) <= call shiftright1(t16,)", opcode: Pop8, args: [Register(0x97)], resolved: None }
15 97 
# 8210b Instruction { source: "Restoring reg0x98 after Some(t15) <= call shiftright1(t16,)", opcode: Pop8, args: [Register(0x98)], resolved: None }
15 98 
# 8210d Instruction { source: "Restoring reg0x99 after Some(t15) <= call shiftright1(t16,)", opcode: Pop8, args: [Register(0x99)], resolved: None }
15 99 
# 8210f Instruction { source: "Restoring reg0x9a after Some(t15) <= call shiftright1(t16,)", opcode: Pop8, args: [Register(0x9a)], resolved: None }
15 9a 
# 82111 Instruction { source: "Some(t15) <= call shiftright1(t16,)", opcode: Copy32, args: [Register(0x00), Register(0xa0)], resolved: None }
81 00 a0 
# 82114 Instruction { source: "mid <- t13 Add t15", opcode: Add32NoCarryIn, args: [Register(0x9c), Register(0xa0), Register(0x9c)], resolved: None }
a0 9c a0 9c 
# 82118 Instruction { source: "t18 <- mid U32", opcode: Copy32, args: [Register(0x9c), Register(0x9c)], resolved: None }
81 9c 9c 
# 8211b Instruction { source: "t19 <- b U32", opcode: Copy32, args: [Register(0x90), Register(0x90)], resolved: None }
81 90 90 
# 8211e Instruction { source: "t22 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0xa8)], resolved: None }
81 0c a8 
# 82121 Instruction { source: "t23 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0xa0), Constant32(0x00000000=0)], resolved: None }
80 a0 00 00 00 00 
# 82127 Instruction { source: "t21 <- t22 Add t23", opcode: Add32NoCarryIn, args: [Register(0xa8), Register(0xa0), Register(0xa0)], resolved: None }
a0 a8 a0 a0 
# 8212b Instruction { source: "t20 <- t21 U32", opcode: Copy32, args: [Register(0xa0), Register(0xa0)], resolved: None }
81 a0 a0 
# 8212e Instruction { source: "Arg0[a]=t18 None <= call mul32_64(t18,t19,t20,)", opcode: Copy32, args: [Register(0x9c), Register(0x00)], resolved: None }
81 9c 00 
# 82131 Instruction { source: "Arg1[b]=t19 None <= call mul32_64(t18,t19,t20,)", opcode: Copy32, args: [Register(0x90), Register(0x04)], resolved: None }
81 90 04 
# 82134 Instruction { source: "Arg2[c]=t20 None <= call mul32_64(t18,t19,t20,)", opcode: Copy32, args: [Register(0xa0), Register(0x08)], resolved: None }
81 a0 08 
# Registers used by this function: {140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 168, 169, 170, 171, 172, 173, 174, 175}
# Registers used by callee tree: {28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241}
# Registers to save: []
# 82137 Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8213d Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 47 21 08 00 
# 82143 Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: JmpImm, args: [Label24(:mul32_64)], resolved: None }
40 d9 25 08 
# 82147 Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8214d Instruction { source: "t26 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0xa8)], resolved: None }
81 0c a8 
# 82150 Instruction { source: "t27 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0xa0), Constant32(0x00000004=4)], resolved: None }
80 a0 04 00 00 00 
# 82156 Instruction { source: "t25 <- t26 Add t27", opcode: Add32NoCarryIn, args: [Register(0xa8), Register(0xa0), Register(0xa0)], resolved: None }
a0 a8 a0 a0 
# 8215a Instruction { source: "t24 <- mem[t25] U32", opcode: Load32, args: [Register(0xa0), Register(0xa0)], resolved: None }
90 a0 a0 
# 8215d Instruction { source: "t28 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0xac), Constant32(0x00000000=0)], resolved: None }
80 ac 00 00 00 00 
# 82163 Instruction { source: "if t24 > t28 then 'div32_if_true_0_10' else 'div32_if_else_0_11'", opcode: Cmp8, args: [Register(0xa3), Register(0xaf)], resolved: None }
25 a3 af 
# 82166 Instruction { source: "if t24 > t28 then 'div32_if_true_0_10' else 'div32_if_else_0_11'", opcode: Cmp8IfZero, args: [Register(0xa2), Register(0xae)], resolved: None }
26 a2 ae 
# 82169 Instruction { source: "if t24 > t28 then 'div32_if_true_0_10' else 'div32_if_else_0_11'", opcode: Cmp8IfZero, args: [Register(0xa1), Register(0xad)], resolved: None }
26 a1 ad 
# 8216c Instruction { source: "if t24 > t28 then 'div32_if_true_0_10' else 'div32_if_else_0_11'", opcode: Cmp8IfZero, args: [Register(0xa0), Register(0xac)], resolved: None }
26 a0 ac 
# 8216f Instruction { source: "if t24 > t28 then 'div32_if_true_0_10' else 'div32_if_else_0_11'", opcode: JcImm, args: [Label24(div32_if_else_0_11)], resolved: None }
41 99 21 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t24 > t28 then 'div32_if_true_0_10' else 'div32_if_else_0_11'", opcode: JmpImm, args: [Label24(div32_if_true_0_10)], resolved: None }
# div32_if_true_0_10
# 82173 Instruction { source: "t29 <- mid U32", opcode: Copy32, args: [Register(0x9c), Register(0x94)], resolved: None }
81 9c 94 
# 82176 Instruction { source: "t30 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x9c), Constant32(0x00000001=1)], resolved: None }
80 9c 01 00 00 00 
# 8217c Instruction { source: "hi <- t29 Subtract t30", opcode: Copy32, args: [Register(0x9c), Register(0x00)], resolved: None }
81 9c 00 
# 8217f Instruction { source: "hi <- t29 Subtract t30", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 82181 Instruction { source: "hi <- t29 Subtract t30", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 82183 Instruction { source: "hi <- t29 Subtract t30", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 82185 Instruction { source: "hi <- t29 Subtract t30", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 82187 Instruction { source: "hi <- t29 Subtract t30", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 8218d Instruction { source: "hi <- t29 Subtract t30", opcode: Add32NoCarryIn, args: [Register(0x94), Register(0x00), Register(0x94)], resolved: None }
a0 94 00 94 
# 82191 Instruction { source: "goto div32_while_predicate_6", opcode: JmpImm, args: [Label24(div32_while_predicate_6)], resolved: None }
40 88 20 08 
# 82195 Instruction { source: "goto div32_if_end_9", opcode: JmpImm, args: [Label24(div32_if_end_9)], resolved: None }
40 99 21 08 
# div32_if_else_0_11
# div32_if_end_9
# 82199 Instruction { source: "t31 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0xa8)], resolved: None }
81 0c a8 
# 8219c Instruction { source: "x <- mem[t31] U32", opcode: Load32, args: [Register(0xa8), Register(0xa0)], resolved: None }
90 a8 a0 
# 8219f Instruction { source: "t32 <- x U32", opcode: Copy32, args: [Register(0xa0), Register(0xa0)], resolved: None }
81 a0 a0 
# 821a2 Instruction { source: "t33 <- a U32", opcode: Copy32, args: [Register(0x8c), Register(0x8c)], resolved: None }
81 8c 8c 
# 821a5 Instruction { source: "if t32 > t33 then 'div32_if_true_0_13' else 'div32_if_else_0_14'", opcode: Cmp8, args: [Register(0xa3), Register(0x8f)], resolved: None }
25 a3 8f 
# 821a8 Instruction { source: "if t32 > t33 then 'div32_if_true_0_13' else 'div32_if_else_0_14'", opcode: Cmp8IfZero, args: [Register(0xa2), Register(0x8e)], resolved: None }
26 a2 8e 
# 821ab Instruction { source: "if t32 > t33 then 'div32_if_true_0_13' else 'div32_if_else_0_14'", opcode: Cmp8IfZero, args: [Register(0xa1), Register(0x8d)], resolved: None }
26 a1 8d 
# 821ae Instruction { source: "if t32 > t33 then 'div32_if_true_0_13' else 'div32_if_else_0_14'", opcode: Cmp8IfZero, args: [Register(0xa0), Register(0x8c)], resolved: None }
26 a0 8c 
# 821b1 Instruction { source: "if t32 > t33 then 'div32_if_true_0_13' else 'div32_if_else_0_14'", opcode: JcImm, args: [Label24(div32_if_else_0_14)], resolved: None }
41 db 21 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t32 > t33 then 'div32_if_true_0_13' else 'div32_if_else_0_14'", opcode: JmpImm, args: [Label24(div32_if_true_0_13)], resolved: None }
# div32_if_true_0_13
# 821b5 Instruction { source: "t34 <- mid U32", opcode: Copy32, args: [Register(0x9c), Register(0x94)], resolved: None }
81 9c 94 
# 821b8 Instruction { source: "t35 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x9c), Constant32(0x00000001=1)], resolved: None }
80 9c 01 00 00 00 
# 821be Instruction { source: "hi <- t34 Subtract t35", opcode: Copy32, args: [Register(0x9c), Register(0x00)], resolved: None }
81 9c 00 
# 821c1 Instruction { source: "hi <- t34 Subtract t35", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 821c3 Instruction { source: "hi <- t34 Subtract t35", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 821c5 Instruction { source: "hi <- t34 Subtract t35", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 821c7 Instruction { source: "hi <- t34 Subtract t35", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 821c9 Instruction { source: "hi <- t34 Subtract t35", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 821cf Instruction { source: "hi <- t34 Subtract t35", opcode: Add32NoCarryIn, args: [Register(0x94), Register(0x00), Register(0x94)], resolved: None }
a0 94 00 94 
# 821d3 Instruction { source: "goto div32_while_predicate_6", opcode: JmpImm, args: [Label24(div32_while_predicate_6)], resolved: None }
40 88 20 08 
# 821d7 Instruction { source: "goto div32_if_end_12", opcode: JmpImm, args: [Label24(div32_if_end_12)], resolved: None }
40 db 21 08 
# div32_if_else_0_14
# div32_if_end_12
# 821db Instruction { source: "t36 <- x U32", opcode: Copy32, args: [Register(0xa0), Register(0x98)], resolved: None }
81 a0 98 
# 821de Instruction { source: "t37 <- a U32", opcode: Copy32, args: [Register(0x8c), Register(0x8c)], resolved: None }
81 8c 8c 
# 821e1 Instruction { source: "if t36 == t37 then 'div32_if_true_0_16' else 'div32_if_else_0_17'", opcode: Cmp8, args: [Register(0x9b), Register(0x8f)], resolved: None }
25 9b 8f 
# 821e4 Instruction { source: "if t36 == t37 then 'div32_if_true_0_16' else 'div32_if_else_0_17'", opcode: Cmp8IfZero, args: [Register(0x9a), Register(0x8e)], resolved: None }
26 9a 8e 
# 821e7 Instruction { source: "if t36 == t37 then 'div32_if_true_0_16' else 'div32_if_else_0_17'", opcode: Cmp8IfZero, args: [Register(0x99), Register(0x8d)], resolved: None }
26 99 8d 
# 821ea Instruction { source: "if t36 == t37 then 'div32_if_true_0_16' else 'div32_if_else_0_17'", opcode: Cmp8IfZero, args: [Register(0x98), Register(0x8c)], resolved: None }
26 98 8c 
# 821ed Instruction { source: "if t36 == t37 then 'div32_if_true_0_16' else 'div32_if_else_0_17'", opcode: JzImm, args: [Label24(div32_if_true_0_16)], resolved: None }
42 f5 21 08 
# 821f1 Instruction { source: "if t36 == t37 then 'div32_if_true_0_16' else 'div32_if_else_0_17'", opcode: JmpImm, args: [Label24(div32_if_else_0_17)], resolved: None }
40 11 22 08 
# div32_if_true_0_16
# 821f5 Instruction { source: "t38 <- mid U32", opcode: Copy32, args: [Register(0x9c), Register(0x8c)], resolved: None }
81 9c 8c 
# 821f8 Instruction { source: "t39 <- 0n8/0x00000008u32 ", opcode: LoadImm32, args: [Register(0x90), Constant32(0x00000008=8)], resolved: None }
80 90 08 00 00 00 
# 821fe Instruction { source: "__frame_pointer <- __frame_pointer Add t39", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x90), Register(0x0c)], resolved: None }
a0 0c 90 0c 
# 82202 Instruction { source: "return Some(t38)", opcode: Copy32, args: [Register(0x8c), Register(0x00)], resolved: None }
81 8c 00 
# 82205 Instruction { source: "Dealloc 8 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000008=8)], resolved: None }
a3 0c 08 00 00 00 
# 8220b Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 8220d Instruction { source: "goto div32_if_end_15", opcode: JmpImm, args: [Label24(div32_if_end_15)], resolved: None }
40 11 22 08 
# div32_if_else_0_17
# div32_if_end_15
# 82211 Instruction { source: "t40 <- a U32", opcode: Copy32, args: [Register(0x8c), Register(0x8c)], resolved: None }
81 8c 8c 
# 82214 Instruction { source: "t41 <- x U32", opcode: Copy32, args: [Register(0xa0), Register(0x98)], resolved: None }
81 a0 98 
# 82217 Instruction { source: "r <- t40 Subtract t41", opcode: Copy32, args: [Register(0x98), Register(0x00)], resolved: None }
81 98 00 
# 8221a Instruction { source: "r <- t40 Subtract t41", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 8221c Instruction { source: "r <- t40 Subtract t41", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 8221e Instruction { source: "r <- t40 Subtract t41", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 82220 Instruction { source: "r <- t40 Subtract t41", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 82222 Instruction { source: "r <- t40 Subtract t41", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 82228 Instruction { source: "r <- t40 Subtract t41", opcode: Add32NoCarryIn, args: [Register(0x8c), Register(0x00), Register(0x98)], resolved: None }
a0 8c 00 98 
# 8222c Instruction { source: "t42 <- r U32", opcode: Copy32, args: [Register(0x98), Register(0x98)], resolved: None }
81 98 98 
# 8222f Instruction { source: "t43 <- b U32", opcode: Copy32, args: [Register(0x90), Register(0x90)], resolved: None }
81 90 90 
# 82232 Instruction { source: "if t42 < t43 then 'div32_if_true_0_19' else 'div32_if_else_0_20'", opcode: Cmp8, args: [Register(0x93), Register(0x9b)], resolved: None }
25 93 9b 
# 82235 Instruction { source: "if t42 < t43 then 'div32_if_true_0_19' else 'div32_if_else_0_20'", opcode: Cmp8IfZero, args: [Register(0x92), Register(0x9a)], resolved: None }
26 92 9a 
# 82238 Instruction { source: "if t42 < t43 then 'div32_if_true_0_19' else 'div32_if_else_0_20'", opcode: Cmp8IfZero, args: [Register(0x91), Register(0x99)], resolved: None }
26 91 99 
# 8223b Instruction { source: "if t42 < t43 then 'div32_if_true_0_19' else 'div32_if_else_0_20'", opcode: Cmp8IfZero, args: [Register(0x90), Register(0x98)], resolved: None }
26 90 98 
# 8223e Instruction { source: "if t42 < t43 then 'div32_if_true_0_19' else 'div32_if_else_0_20'", opcode: JcImm, args: [Label24(div32_if_else_0_20)], resolved: None }
41 5e 22 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t42 < t43 then 'div32_if_true_0_19' else 'div32_if_else_0_20'", opcode: JmpImm, args: [Label24(div32_if_true_0_19)], resolved: None }
# div32_if_true_0_19
# 82242 Instruction { source: "t44 <- mid U32", opcode: Copy32, args: [Register(0x9c), Register(0x8c)], resolved: None }
81 9c 8c 
# 82245 Instruction { source: "t45 <- 0n8/0x00000008u32 ", opcode: LoadImm32, args: [Register(0x90), Constant32(0x00000008=8)], resolved: None }
80 90 08 00 00 00 
# 8224b Instruction { source: "__frame_pointer <- __frame_pointer Add t45", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x90), Register(0x0c)], resolved: None }
a0 0c 90 0c 
# 8224f Instruction { source: "return Some(t44)", opcode: Copy32, args: [Register(0x8c), Register(0x00)], resolved: None }
81 8c 00 
# 82252 Instruction { source: "Dealloc 8 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000008=8)], resolved: None }
a3 0c 08 00 00 00 
# 82258 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 8225a Instruction { source: "goto div32_if_end_18", opcode: JmpImm, args: [Label24(div32_if_end_18)], resolved: None }
40 5e 22 08 
# div32_if_else_0_20
# div32_if_end_18
# 8225e Instruction { source: "t46 <- mid U32", opcode: Copy32, args: [Register(0x9c), Register(0x98)], resolved: None }
81 9c 98 
# 82261 Instruction { source: "t47 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x9c), Constant32(0x00000001=1)], resolved: None }
80 9c 01 00 00 00 
# 82267 Instruction { source: "lo <- t46 Add t47", opcode: Add32NoCarryIn, args: [Register(0x98), Register(0x9c), Register(0x98)], resolved: None }
a0 98 9c 98 
# 8226b Instruction { source: "goto div32_while_predicate_6", opcode: JmpImm, args: [Label24(div32_while_predicate_6)], resolved: None }
40 88 20 08 
# div32_while_end_8
# 8226f Instruction { source: "t48 <- lo U32", opcode: Copy32, args: [Register(0x98), Register(0x8c)], resolved: None }
81 98 8c 
# 82272 Instruction { source: "t49 <- 0n8/0x00000008u32 ", opcode: LoadImm32, args: [Register(0x90), Constant32(0x00000008=8)], resolved: None }
80 90 08 00 00 00 
# 82278 Instruction { source: "__frame_pointer <- __frame_pointer Add t49", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x90), Register(0x0c)], resolved: None }
a0 0c 90 0c 
# 8227c Instruction { source: "return Some(t48)", opcode: Copy32, args: [Register(0x8c), Register(0x00)], resolved: None }
81 8c 00 
# 8227f Instruction { source: "Dealloc 8 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000008=8)], resolved: None }
a3 0c 08 00 00 00 
# 82285 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82287 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :div32_by10
# Ret Some(U32)
# Arg0=a
# Var a (Arg0 a Number(USIZE)) U32 Some([176, 177, 178, 179])
# Var prod (Local prod Struct("U64") Static(524544)) Static(524544) None
# Var t0 (t0 Call(Call { function: "mul32_64", parameters: [Ident("a"), Number(USIZE, 3435973837), AddressOf(Ident("prod"))] })) U8 Some([180])
# Var t1 (t1 Ident("a")) U32 Some([176, 177, 178, 179])
# Var t2 (t2 Number(USIZE, 3435973837)) U32 Some([184, 185, 186, 187])
# Var t3 (t3 AddressOf(Ident("prod"))) U32 Some([188, 189, 190, 191])
# Var t4 (static "prod") U32 Some([188, 189, 190, 191])
# Var t5 (t5 Call(Call { function: "shiftright3", parameters: [LocalFieldDeref("prod", "hi")] })) U32 Some([176, 177, 178, 179])
# Var t6 (t6 LocalFieldDeref("prod", "hi")) U32 Some([176, 177, 178, 179])
# Var t7 (t7 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Number(USIZE, 524544), Number(USIZE, 4)) }) U32 Some([176, 177, 178, 179])
# Var t8 (t8 Number(USIZE, 524544)) U32 Some([176, 177, 178, 179])
# Var t9 (t9 Number(USIZE, 4)) U32 Some([184, 185, 186, 187])
# 8228c Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [176, 177, 178, 179].", opcode: Copy32, args: [Register(0x00), Register(0xb0)], resolved: None }
81 00 b0 
# 8228f Instruction { source: "t1 <- a U32", opcode: Copy32, args: [Register(0xb0), Register(0xb0)], resolved: None }
81 b0 b0 
# 82292 Instruction { source: "t2 <- 0xcccccccdu32 ", opcode: LoadImm32, args: [Register(0xb8), Constant32(0xcccccccd=3435973837)], resolved: None }
80 b8 cd cc cc cc 
# 82298 Instruction { source: "t4 <- 0n524544/0x00080100u32 ", opcode: LoadImm32, args: [Register(0xbc), Constant32(0x00080100=524544)], resolved: None }
80 bc 00 01 08 00 
# 8229e Instruction { source: "t3 <- t4 U32", opcode: Copy32, args: [Register(0xbc), Register(0xbc)], resolved: None }
81 bc bc 
# 822a1 Instruction { source: "Arg0[a]=t1 None <= call mul32_64(t1,t2,t3,)", opcode: Copy32, args: [Register(0xb0), Register(0x00)], resolved: None }
81 b0 00 
# 822a4 Instruction { source: "Arg1[b]=t2 None <= call mul32_64(t1,t2,t3,)", opcode: Copy32, args: [Register(0xb8), Register(0x04)], resolved: None }
81 b8 04 
# 822a7 Instruction { source: "Arg2[c]=t3 None <= call mul32_64(t1,t2,t3,)", opcode: Copy32, args: [Register(0xbc), Register(0x08)], resolved: None }
81 bc 08 
# Registers used by this function: {176, 177, 178, 179, 180, 184, 185, 186, 187, 188, 189, 190, 191}
# Registers used by callee tree: {28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241}
# Registers to save: []
# 822aa Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 822b0 Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c ba 22 08 00 
# 822b6 Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: JmpImm, args: [Label24(:mul32_64)], resolved: None }
40 d9 25 08 
# 822ba Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 822c0 Instruction { source: "t8 <- 0n524544/0x00080100u32 ", opcode: LoadImm32, args: [Register(0xb0), Constant32(0x00080100=524544)], resolved: None }
80 b0 00 01 08 00 
# 822c6 Instruction { source: "t9 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0xb8), Constant32(0x00000004=4)], resolved: None }
80 b8 04 00 00 00 
# 822cc Instruction { source: "t7 <- t8 Add t9", opcode: Add32NoCarryIn, args: [Register(0xb0), Register(0xb8), Register(0xb0)], resolved: None }
a0 b0 b8 b0 
# 822d0 Instruction { source: "t6 <- mem[t7] U32", opcode: Load32, args: [Register(0xb0), Register(0xb0)], resolved: None }
90 b0 b0 
# 822d3 Instruction { source: "Arg0[a]=t6 Some(t5) <= call shiftright3(t6,)", opcode: Copy32, args: [Register(0xb0), Register(0x00)], resolved: None }
81 b0 00 
# Registers used by this function: {176, 177, 178, 179, 180, 184, 185, 186, 187, 188, 189, 190, 191}
# Registers used by callee tree: {156, 157, 158, 159, 160, 161, 162}
# Registers to save: []
# 822d6 Instruction { source: "PseudoCall(Label24(:shiftright3))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 822dc Instruction { source: "PseudoCall(Label24(:shiftright3))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c e6 22 08 00 
# 822e2 Instruction { source: "PseudoCall(Label24(:shiftright3))", opcode: JmpImm, args: [Label24(:shiftright3)], resolved: None }
40 bf 2b 08 
# 822e6 Instruction { source: "PseudoCall(Label24(:shiftright3))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 822ec Instruction { source: "Some(t5) <= call shiftright3(t6,)", opcode: Copy32, args: [Register(0x00), Register(0xb0)], resolved: None }
81 00 b0 
# 822ef Instruction { source: "return Some(t5)", opcode: Copy32, args: [Register(0xb0), Register(0x00)], resolved: None }
81 b0 00 
# 822f2 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 822f4 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :getchar
# Ret Some(U8)
# Var t0 (t0 Arithmetic(And, Ident("tty"), Number(U8, 128))) U8 Some([192])
# Var t1 (t1 Ident("tty")) U8 Some([192])
# Var t2 (t2 Number(U8, 128)) U8 Some([193])
# Var t3 (t3 Number(U8, 0)) U8 Some([193])
# Var t4 (t4 Arithmetic(And, Ident("tty"), Number(U8, 127))) U8 Some([192])
# Var t5 (t5 Ident("tty")) U8 Some([192])
# Var t6 (t6 Number(U8, 127)) U8 Some([193])
# Var tty (Local tty Number(U8) U8) U8 Some([194])
# 822f9 Instruction { source: "tty <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xc2), Constant8(0x00=0)], resolved: None }
00 c2 00 
# getchar_while_predicate_0
# 822fc Instruction { source: "t1 <- tty U8", opcode: Copy8, args: [Register(0xc2), Register(0xc0)], resolved: None }
16 c2 c0 
# 822ff Instruction { source: "t2 <- 0n128/0x80u8 ", opcode: LoadImm8, args: [Register(0xc1), Constant8(0x80=128)], resolved: None }
00 c1 80 
# 82302 Instruction { source: "t0 <- t1 BitwiseAnd t2", opcode: And8, args: [Register(0xc0), Register(0xc1), Register(0xc0)], resolved: None }
33 c0 c1 c0 
# 82306 Instruction { source: "t3 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xc1), Constant8(0x00=0)], resolved: None }
00 c1 00 
# 82309 Instruction { source: "if t0 == t3 then 'getchar_while_body_1' else 'getchar_while_end_2'", opcode: Cmp8, args: [Register(0xc0), Register(0xc1)], resolved: None }
25 c0 c1 
# 8230c Instruction { source: "if t0 == t3 then 'getchar_while_body_1' else 'getchar_while_end_2'", opcode: JzImm, args: [Label24(getchar_while_body_1)], resolved: None }
42 14 23 08 
# 82310 Instruction { source: "if t0 == t3 then 'getchar_while_body_1' else 'getchar_while_end_2'", opcode: JmpImm, args: [Label24(getchar_while_end_2)], resolved: None }
40 1a 23 08 
# getchar_while_body_1
# 82314 Instruction { source: "tty <- ttyin", opcode: TtyIn, args: [Register(0xc2)], resolved: None }
12 c2 
# 82316 Instruction { source: "goto getchar_while_predicate_0", opcode: JmpImm, args: [Label24(getchar_while_predicate_0)], resolved: None }
40 fc 22 08 
# getchar_while_end_2
# 8231a Instruction { source: "t5 <- tty U8", opcode: Copy8, args: [Register(0xc2), Register(0xc0)], resolved: None }
16 c2 c0 
# 8231d Instruction { source: "t6 <- 0n127/0x7fu8 ", opcode: LoadImm8, args: [Register(0xc1), Constant8(0x7f=127)], resolved: None }
00 c1 7f 
# 82320 Instruction { source: "t4 <- t5 BitwiseAnd t6", opcode: And8, args: [Register(0xc0), Register(0xc1), Register(0xc0)], resolved: None }
33 c0 c1 c0 
# 82324 Instruction { source: "return Some(t4)", opcode: Copy8, args: [Register(0xc0), Register(0x00)], resolved: None }
16 c0 00 
# 82327 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82329 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :main
# Ret Some(U8)
# Var __frame_pointer (__frame_pointer) U32 Some([12, 13, 14, 15])
# Var calc (Local calc Ptr(Struct("RpnCalc")) U32) U32 Some([196, 197, 198, 199])
# Var calcs (Local calcs Array(Struct("RpnCalc"), 8) FrameOffset(0)) FrameOffset(0) None
# Var ch (Local ch Number(U8) U8) U8 Some([200])
# Var result (Local result Number(U8) U8) U8 Some([200])
# Var t0 (Stack size negated) U32 Some([196, 197, 198, 199])
# Var t1 (t1 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Struct("RpnCalc")), value: Arithmetic(Add, Ident("__frame_pointer"), Arithmetic(Multiply, Number(USIZE, 0), Number(USIZE, 76))) }) U32 Some([196, 197, 198, 199])
# Var t10 (t10 Ident("calc")) U32 Some([196, 197, 198, 199])
# Var t11 (t11 Ident("ch")) U8 Some([200])
# Var t12 (t12 Ident("result")) U8 Some([200])
# Var t13 (t13 Number(U8, 0)) U8 Some([201])
# Var t14 (t14 Number(U8, 0)) U8 Some([202])
# Var t15 (Stack size) U32 Some([204, 205, 206, 207])
# Var t2 (t2 Ident("__frame_pointer")) U32 Some([208, 209, 210, 211])
# Var t3 (t3 Arithmetic(Multiply, Number(USIZE, 0), Number(USIZE, 76))) U32 Some([196, 197, 198, 199])
# Var t4 (t4 Number(USIZE, 0)) U32 Some([196, 197, 198, 199])
# Var t5 (t5 Number(USIZE, 76)) U32 Some([204, 205, 206, 207])
# Var t6 (t6 Call(Call { function: "RpnCalc_init", parameters: [Ident("calc")] })) U8 Some([212])
# Var t7 (t7 Ident("calc")) U32 Some([196, 197, 198, 199])
# Var t8 (t8 Number(U8, 0)) U8 Some([200])
# Var t9 (t9 Number(U8, 0)) U8 Some([201])
# 8232e Instruction { source: "reserve 608 bytes of stack space for locals", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffda0=4294966688)], resolved: None }
a3 0c a0 fd ff ff 
# 82334 Instruction { source: "t0 <- 0xfffffda0u32 ", opcode: LoadImm32, args: [Register(0xc4), Constant32(0xfffffda0=4294966688)], resolved: None }
80 c4 a0 fd ff ff 
# 8233a Instruction { source: "__frame_pointer <- __frame_pointer Add t0", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0xc4), Register(0x0c)], resolved: None }
a0 0c c4 0c 
# 8233e Instruction { source: "t2 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0xd0)], resolved: None }
81 0c d0 
# 82341 Instruction { source: "t4 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0xc4), Constant32(0x00000000=0)], resolved: None }
80 c4 00 00 00 00 
# 82347 Instruction { source: "t5 <- 0n76/0x0000004cu32 ", opcode: LoadImm32, args: [Register(0xcc), Constant32(0x0000004c=76)], resolved: None }
80 cc 4c 00 00 00 
# 8234d Instruction { source: "t3 <- t4 Multiply t5", opcode: LoadImm32, args: [Register(0x00), Constant32(0x00000000=0)], resolved: None }
80 00 00 00 00 00 
# 82353 Instruction { source: "t3 <- t4 Multiply t5", opcode: Mul8_1, args: [Register(0xc4), Register(0xcc)], resolved: None }
20 c4 cc 
# 82356 Instruction { source: "t3 <- t4 Multiply t5", opcode: Mul8_2, args: [], resolved: None }
21 
# 82357 Instruction { source: "t3 <- t4 Multiply t5", opcode: Copy32, args: [Register(0x00), Register(0xc4)], resolved: None }
81 00 c4 
# 8235a Instruction { source: "t1 <- t2 Add t3", opcode: Add32NoCarryIn, args: [Register(0xd0), Register(0xc4), Register(0xc4)], resolved: None }
a0 d0 c4 c4 
# 8235e Instruction { source: "calc <- t1 U32", opcode: Copy32, args: [Register(0xc4), Register(0xc4)], resolved: None }
81 c4 c4 
# 82361 Instruction { source: "t7 <- calc U32", opcode: Copy32, args: [Register(0xc4), Register(0xc4)], resolved: None }
81 c4 c4 
# 82364 Instruction { source: "Arg0[c]=t7 None <= call RpnCalc_init(t7,)", opcode: Copy32, args: [Register(0xc4), Register(0x00)], resolved: None }
81 c4 00 
# Registers used by this function: {196, 197, 198, 199, 200, 201, 202, 204, 205, 206, 207, 208, 209, 210, 211, 212}
# Registers used by callee tree: {48, 49, 50, 51, 52, 53, 54, 55, 56, 176, 177, 178, 179, 180, 181, 182, 183}
# Registers to save: []
# 82367 Instruction { source: "PseudoCall(Label24(:RpnCalc_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8236d Instruction { source: "PseudoCall(Label24(:RpnCalc_init))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 77 23 08 00 
# 82373 Instruction { source: "PseudoCall(Label24(:RpnCalc_init))", opcode: JmpImm, args: [Label24(:RpnCalc_init)], resolved: None }
40 5d 1c 08 
# 82377 Instruction { source: "PseudoCall(Label24(:RpnCalc_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# main_while_predicate_0
# 8237d Instruction { source: "t8 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xc8), Constant8(0x00=0)], resolved: None }
00 c8 00 
# 82380 Instruction { source: "t9 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xc9), Constant8(0x00=0)], resolved: None }
00 c9 00 
# 82383 Instruction { source: "if t8 == t9 then 'main_while_body_1' else 'main_while_end_2'", opcode: Cmp8, args: [Register(0xc8), Register(0xc9)], resolved: None }
25 c8 c9 
# 82386 Instruction { source: "if t8 == t9 then 'main_while_body_1' else 'main_while_end_2'", opcode: JzImm, args: [Label24(main_while_body_1)], resolved: None }
42 8e 23 08 
# 8238a Instruction { source: "if t8 == t9 then 'main_while_body_1' else 'main_while_end_2'", opcode: JmpImm, args: [Label24(main_while_end_2)], resolved: None }
40 3d 24 08 
# main_while_body_1
# Registers used by this function: {196, 197, 198, 199, 200, 201, 202, 204, 205, 206, 207, 208, 209, 210, 211, 212}
# Registers used by callee tree: {192, 193, 194}
# Registers to save: []
# 8238e Instruction { source: "PseudoCall(Label24(:getchar))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82394 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 9e 23 08 00 
# 8239a Instruction { source: "PseudoCall(Label24(:getchar))", opcode: JmpImm, args: [Label24(:getchar)], resolved: None }
40 f9 22 08 
# 8239e Instruction { source: "PseudoCall(Label24(:getchar))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 823a4 Instruction { source: "Some(ch) <= call getchar()", opcode: Copy8, args: [Register(0x00), Register(0xc8)], resolved: None }
16 00 c8 
# 823a7 Instruction { source: "t10 <- calc U32", opcode: Copy32, args: [Register(0xc4), Register(0xc4)], resolved: None }
81 c4 c4 
# 823aa Instruction { source: "t11 <- ch U8", opcode: Copy8, args: [Register(0xc8), Register(0xc8)], resolved: None }
16 c8 c8 
# 823ad Instruction { source: "Arg0[c]=t10 Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Copy32, args: [Register(0xc4), Register(0x00)], resolved: None }
81 c4 00 
# 823b0 Instruction { source: "Arg1[ch]=t11 Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Copy8, args: [Register(0xc8), Register(0x04)], resolved: None }
16 c8 04 
# Registers used by this function: {196, 197, 198, 199, 200, 201, 202, 204, 205, 206, 207, 208, 209, 210, 211, 212}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255}
# Registers to save: [196, 197, 198, 199, 200, 201, 202, 204, 205, 206, 207, 208, 209, 210, 211, 212]
# 823b3 Instruction { source: "Saving reg0xd4 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xd4)], resolved: None }
14 d4 
# 823b5 Instruction { source: "Saving reg0xd3 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xd3)], resolved: None }
14 d3 
# 823b7 Instruction { source: "Saving reg0xd2 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xd2)], resolved: None }
14 d2 
# 823b9 Instruction { source: "Saving reg0xd1 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xd1)], resolved: None }
14 d1 
# 823bb Instruction { source: "Saving reg0xd0 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xd0)], resolved: None }
14 d0 
# 823bd Instruction { source: "Saving reg0xcf before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xcf)], resolved: None }
14 cf 
# 823bf Instruction { source: "Saving reg0xce before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xce)], resolved: None }
14 ce 
# 823c1 Instruction { source: "Saving reg0xcd before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xcd)], resolved: None }
14 cd 
# 823c3 Instruction { source: "Saving reg0xcc before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xcc)], resolved: None }
14 cc 
# 823c5 Instruction { source: "Saving reg0xca before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xca)], resolved: None }
14 ca 
# 823c7 Instruction { source: "Saving reg0xc9 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xc9)], resolved: None }
14 c9 
# 823c9 Instruction { source: "Saving reg0xc8 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xc8)], resolved: None }
14 c8 
# 823cb Instruction { source: "Saving reg0xc7 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xc7)], resolved: None }
14 c7 
# 823cd Instruction { source: "Saving reg0xc6 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xc6)], resolved: None }
14 c6 
# 823cf Instruction { source: "Saving reg0xc5 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xc5)], resolved: None }
14 c5 
# 823d1 Instruction { source: "Saving reg0xc4 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xc4)], resolved: None }
14 c4 
# 823d3 Instruction { source: "PseudoCall(Label24(:RpnCalc_handle))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 823d9 Instruction { source: "PseudoCall(Label24(:RpnCalc_handle))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c e3 23 08 00 
# 823df Instruction { source: "PseudoCall(Label24(:RpnCalc_handle))", opcode: JmpImm, args: [Label24(:RpnCalc_handle)], resolved: None }
40 22 14 08 
# 823e3 Instruction { source: "PseudoCall(Label24(:RpnCalc_handle))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 823e9 Instruction { source: "Restoring reg0xc4 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xc4)], resolved: None }
15 c4 
# 823eb Instruction { source: "Restoring reg0xc5 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xc5)], resolved: None }
15 c5 
# 823ed Instruction { source: "Restoring reg0xc6 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xc6)], resolved: None }
15 c6 
# 823ef Instruction { source: "Restoring reg0xc7 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xc7)], resolved: None }
15 c7 
# 823f1 Instruction { source: "Restoring reg0xc8 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xc8)], resolved: None }
15 c8 
# 823f3 Instruction { source: "Restoring reg0xc9 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xc9)], resolved: None }
15 c9 
# 823f5 Instruction { source: "Restoring reg0xca after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xca)], resolved: None }
15 ca 
# 823f7 Instruction { source: "Restoring reg0xcc after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xcc)], resolved: None }
15 cc 
# 823f9 Instruction { source: "Restoring reg0xcd after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xcd)], resolved: None }
15 cd 
# 823fb Instruction { source: "Restoring reg0xce after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xce)], resolved: None }
15 ce 
# 823fd Instruction { source: "Restoring reg0xcf after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xcf)], resolved: None }
15 cf 
# 823ff Instruction { source: "Restoring reg0xd0 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xd0)], resolved: None }
15 d0 
# 82401 Instruction { source: "Restoring reg0xd1 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xd1)], resolved: None }
15 d1 
# 82403 Instruction { source: "Restoring reg0xd2 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xd2)], resolved: None }
15 d2 
# 82405 Instruction { source: "Restoring reg0xd3 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xd3)], resolved: None }
15 d3 
# 82407 Instruction { source: "Restoring reg0xd4 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xd4)], resolved: None }
15 d4 
# 82409 Instruction { source: "Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Copy8, args: [Register(0x00), Register(0xc8)], resolved: None }
16 00 c8 
# 8240c Instruction { source: "t12 <- result U8", opcode: Copy8, args: [Register(0xc8), Register(0xc8)], resolved: None }
16 c8 c8 
# 8240f Instruction { source: "t13 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xc9), Constant8(0x00=0)], resolved: None }
00 c9 00 
# 82412 Instruction { source: "if t12 == t13 then 'main_if_true_0_4' else 'main_if_else_0_5'", opcode: Cmp8, args: [Register(0xc8), Register(0xc9)], resolved: None }
25 c8 c9 
# 82415 Instruction { source: "if t12 == t13 then 'main_if_true_0_4' else 'main_if_else_0_5'", opcode: JzImm, args: [Label24(main_if_true_0_4)], resolved: None }
42 1d 24 08 
# 82419 Instruction { source: "if t12 == t13 then 'main_if_true_0_4' else 'main_if_else_0_5'", opcode: JmpImm, args: [Label24(main_if_else_0_5)], resolved: None }
40 39 24 08 
# main_if_true_0_4
# 8241d Instruction { source: "t14 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xca), Constant8(0x00=0)], resolved: None }
00 ca 00 
# 82420 Instruction { source: "t15 <- 0n608/0x00000260u32 ", opcode: LoadImm32, args: [Register(0xcc), Constant32(0x00000260=608)], resolved: None }
80 cc 60 02 00 00 
# 82426 Instruction { source: "__frame_pointer <- __frame_pointer Add t15", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0xcc), Register(0x0c)], resolved: None }
a0 0c cc 0c 
# 8242a Instruction { source: "return Some(t14)", opcode: Copy8, args: [Register(0xca), Register(0x00)], resolved: None }
16 ca 00 
# 8242d Instruction { source: "Dealloc 608 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000260=608)], resolved: None }
a3 0c 60 02 00 00 
# 82433 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82435 Instruction { source: "goto main_if_end_3", opcode: JmpImm, args: [Label24(main_if_end_3)], resolved: None }
40 39 24 08 
# main_if_else_0_5
# main_if_end_3
# 82439 Instruction { source: "goto main_while_predicate_0", opcode: JmpImm, args: [Label24(main_while_predicate_0)], resolved: None }
40 7d 23 08 
# main_while_end_2
# 8243d Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :mul16_32
# Ret Some(U32)
# Arg0=a
# Arg1=b
# Var a (Arg0 a Number(USIZE)) U32 Some([216, 217, 218, 219])
# Var b (Arg1 b Number(USIZE)) U32 Some([220, 221, 222, 223])
# Var c (Local c Number(USIZE) U32) U32 Some([224, 225, 226, 227])
# Var d (Local d Number(USIZE) U32) U32 Some([228, 229, 230, 231])
# Var e (Local e Number(USIZE) U32) U32 Some([216, 217, 218, 219])
# Var f (Local f Number(USIZE) U32) U32 Some([228, 229, 230, 231])
# Var t0 (t0 Ident("a")) U32 Some([216, 217, 218, 219])
# Var t1 (t1 Ident("b")) U32 Some([220, 221, 222, 223])
# Var t10 (t10 Ident("c")) U32 Some([224, 225, 226, 227])
# Var t11 (t11 Ident("f")) U32 Some([228, 229, 230, 231])
# Var t12 (t12 Ident("a")) U32 Some([216, 217, 218, 219])
# Var t13 (t13 Cast { old_type: None, new_type: Number(USIZE), value: Index("b", Number(U8, 1)) }) U32 Some([228, 229, 230, 231])
# Var t14 (t14 Index("b", Number(U8, 1))) U8 Some([232])
# Var t15 (t15 Cast { old_type: None, new_type: Number(USIZE), value: Index("a", Number(U8, 1)) }) U32 Some([216, 217, 218, 219])
# Var t16 (t16 Index("a", Number(U8, 1))) U8 Some([233])
# Var t17 (t17 Ident("b")) U32 Some([220, 221, 222, 223])
# Var t18 (t18 Ident("d")) U32 Some([220, 221, 222, 223])
# Var t19 (t19 Ident("e")) U32 Some([216, 217, 218, 219])
# Var t2 (t2 Cast { old_type: None, new_type: Number(USIZE), value: Index("a", Number(U8, 1)) }) U32 Some([228, 229, 230, 231])
# Var t20 (t20 Index("d", Number(U8, 2))) U8 Some([233])
# Var t21 (t21 Index("d", Number(U8, 1))) U8 Some([233])
# Var t22 (t22 Index("d", Number(U8, 0))) U8 Some([233])
# Var t23 (t23 Number(U8, 0)) U8 Some([233])
# Var t24 (t24 Arithmetic(Add, Ident("c"), Ident("d"))) U32 Some([216, 217, 218, 219])
# Var t25 (t25 Ident("c")) U32 Some([216, 217, 218, 219])
# Var t26 (t26 Ident("d")) U32 Some([220, 221, 222, 223])
# Var t3 (t3 Index("a", Number(U8, 1))) U8 Some([233])
# Var t4 (t4 Cast { old_type: None, new_type: Number(USIZE), value: Index("b", Number(U8, 1)) }) U32 Some([236, 237, 238, 239])
# Var t5 (t5 Index("b", Number(U8, 1))) U8 Some([232])
# Var t6 (t6 Index("f", Number(U8, 1))) U8 Some([240])
# Var t7 (t7 Index("f", Number(U8, 0))) U8 Some([240])
# Var t8 (t8 Number(U8, 0)) U8 Some([241])
# Var t9 (t9 Number(U8, 0)) U8 Some([241])
# 82442 Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [216, 217, 218, 219].", opcode: Copy32, args: [Register(0x00), Register(0xd8)], resolved: None }
81 00 d8 
# 82445 Instruction { source: "Save function parameter 'b' registers [4, 5, 6, 7] to locals [220, 221, 222, 223].", opcode: Copy32, args: [Register(0x04), Register(0xdc)], resolved: None }
81 04 dc 
# 82448 Instruction { source: "t0 <- a U32", opcode: Copy32, args: [Register(0xd8), Register(0xd8)], resolved: None }
81 d8 d8 
# 8244b Instruction { source: "t1 <- b U32", opcode: Copy32, args: [Register(0xdc), Register(0xdc)], resolved: None }
81 dc dc 
# 8244e Instruction { source: "c <- t0 Multiply t1", opcode: LoadImm32, args: [Register(0x00), Constant32(0x00000000=0)], resolved: None }
80 00 00 00 00 00 
# 82454 Instruction { source: "c <- t0 Multiply t1", opcode: Mul8_1, args: [Register(0xd8), Register(0xdc)], resolved: None }
20 d8 dc 
# 82457 Instruction { source: "c <- t0 Multiply t1", opcode: Mul8_2, args: [], resolved: None }
21 
# 82458 Instruction { source: "c <- t0 Multiply t1", opcode: Copy32, args: [Register(0x00), Register(0xe0)], resolved: None }
81 00 e0 
# 8245b Instruction { source: "t3 <- a[0x01..0x02] U8", opcode: Copy8, args: [Register(0xd9), Register(0xe9)], resolved: None }
16 d9 e9 
# 8245e Instruction { source: "Zero-pad for t2 U32 <- t3 U8", opcode: LoadImm32, args: [Register(0xe4), Constant32(0x00000000=0)], resolved: None }
80 e4 00 00 00 00 
# 82464 Instruction { source: "t2 U32 <- t3 U8", opcode: Copy8, args: [Register(0xe9), Register(0xe4)], resolved: None }
16 e9 e4 
# 82467 Instruction { source: "t5 <- b[0x01..0x02] U8", opcode: Copy8, args: [Register(0xdd), Register(0xe8)], resolved: None }
16 dd e8 
# 8246a Instruction { source: "Zero-pad for t4 U32 <- t5 U8", opcode: LoadImm32, args: [Register(0xec), Constant32(0x00000000=0)], resolved: None }
80 ec 00 00 00 00 
# 82470 Instruction { source: "t4 U32 <- t5 U8", opcode: Copy8, args: [Register(0xe8), Register(0xec)], resolved: None }
16 e8 ec 
# 82473 Instruction { source: "f <- t2 Multiply t4", opcode: LoadImm32, args: [Register(0x00), Constant32(0x00000000=0)], resolved: None }
80 00 00 00 00 00 
# 82479 Instruction { source: "f <- t2 Multiply t4", opcode: Mul8_1, args: [Register(0xe4), Register(0xec)], resolved: None }
20 e4 ec 
# 8247c Instruction { source: "f <- t2 Multiply t4", opcode: Mul8_2, args: [], resolved: None }
21 
# 8247d Instruction { source: "f <- t2 Multiply t4", opcode: Copy32, args: [Register(0x00), Register(0xe4)], resolved: None }
81 00 e4 
# 82480 Instruction { source: "t6 <- f[0x01..0x02] U8", opcode: Copy8, args: [Register(0xe5), Register(0xf0)], resolved: None }
16 e5 f0 
# 82483 Instruction { source: "f[0x03..0x04] <- t6 U8", opcode: Copy8, args: [Register(0xf0), Register(0xe7)], resolved: None }
16 f0 e7 
# 82486 Instruction { source: "t7 <- f[0x00..0x01] U8", opcode: Copy8, args: [Register(0xe4), Register(0xf0)], resolved: None }
16 e4 f0 
# 82489 Instruction { source: "f[0x02..0x03] <- t7 U8", opcode: Copy8, args: [Register(0xf0), Register(0xe6)], resolved: None }
16 f0 e6 
# 8248c Instruction { source: "t8 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xf1), Constant8(0x00=0)], resolved: None }
00 f1 00 
# 8248f Instruction { source: "f[0x01..0x02] <- t8 U8", opcode: Copy8, args: [Register(0xf1), Register(0xe5)], resolved: None }
16 f1 e5 
# 82492 Instruction { source: "t9 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xf1), Constant8(0x00=0)], resolved: None }
00 f1 00 
# 82495 Instruction { source: "f[0x00..0x01] <- t9 U8", opcode: Copy8, args: [Register(0xf1), Register(0xe4)], resolved: None }
16 f1 e4 
# 82498 Instruction { source: "t10 <- c U32", opcode: Copy32, args: [Register(0xe0), Register(0xe0)], resolved: None }
81 e0 e0 
# 8249b Instruction { source: "t11 <- f U32", opcode: Copy32, args: [Register(0xe4), Register(0xe4)], resolved: None }
81 e4 e4 
# 8249e Instruction { source: "c <- t10 Add t11", opcode: Add32NoCarryIn, args: [Register(0xe0), Register(0xe4), Register(0xe0)], resolved: None }
a0 e0 e4 e0 
# 824a2 Instruction { source: "t12 <- a U32", opcode: Copy32, args: [Register(0xd8), Register(0xd8)], resolved: None }
81 d8 d8 
# 824a5 Instruction { source: "t14 <- b[0x01..0x02] U8", opcode: Copy8, args: [Register(0xdd), Register(0xe8)], resolved: None }
16 dd e8 
# 824a8 Instruction { source: "Zero-pad for t13 U32 <- t14 U8", opcode: LoadImm32, args: [Register(0xe4), Constant32(0x00000000=0)], resolved: None }
80 e4 00 00 00 00 
# 824ae Instruction { source: "t13 U32 <- t14 U8", opcode: Copy8, args: [Register(0xe8), Register(0xe4)], resolved: None }
16 e8 e4 
# 824b1 Instruction { source: "d <- t12 Multiply t13", opcode: LoadImm32, args: [Register(0x00), Constant32(0x00000000=0)], resolved: None }
80 00 00 00 00 00 
# 824b7 Instruction { source: "d <- t12 Multiply t13", opcode: Mul8_1, args: [Register(0xd8), Register(0xe4)], resolved: None }
20 d8 e4 
# 824ba Instruction { source: "d <- t12 Multiply t13", opcode: Mul8_2, args: [], resolved: None }
21 
# 824bb Instruction { source: "d <- t12 Multiply t13", opcode: Copy32, args: [Register(0x00), Register(0xe4)], resolved: None }
81 00 e4 
# 824be Instruction { source: "t16 <- a[0x01..0x02] U8", opcode: Copy8, args: [Register(0xd9), Register(0xe9)], resolved: None }
16 d9 e9 
# 824c1 Instruction { source: "Zero-pad for t15 U32 <- t16 U8", opcode: LoadImm32, args: [Register(0xd8), Constant32(0x00000000=0)], resolved: None }
80 d8 00 00 00 00 
# 824c7 Instruction { source: "t15 U32 <- t16 U8", opcode: Copy8, args: [Register(0xe9), Register(0xd8)], resolved: None }
16 e9 d8 
# 824ca Instruction { source: "t17 <- b U32", opcode: Copy32, args: [Register(0xdc), Register(0xdc)], resolved: None }
81 dc dc 
# 824cd Instruction { source: "e <- t15 Multiply t17", opcode: LoadImm32, args: [Register(0x00), Constant32(0x00000000=0)], resolved: None }
80 00 00 00 00 00 
# 824d3 Instruction { source: "e <- t15 Multiply t17", opcode: Mul8_1, args: [Register(0xd8), Register(0xdc)], resolved: None }
20 d8 dc 
# 824d6 Instruction { source: "e <- t15 Multiply t17", opcode: Mul8_2, args: [], resolved: None }
21 
# 824d7 Instruction { source: "e <- t15 Multiply t17", opcode: Copy32, args: [Register(0x00), Register(0xd8)], resolved: None }
81 00 d8 
# 824da Instruction { source: "t18 <- d U32", opcode: Copy32, args: [Register(0xe4), Register(0xdc)], resolved: None }
81 e4 dc 
# 824dd Instruction { source: "t19 <- e U32", opcode: Copy32, args: [Register(0xd8), Register(0xd8)], resolved: None }
81 d8 d8 
# 824e0 Instruction { source: "d <- t18 Add t19", opcode: Add32NoCarryIn, args: [Register(0xdc), Register(0xd8), Register(0xe4)], resolved: None }
a0 dc d8 e4 
# 824e4 Instruction { source: "t20 <- d[0x02..0x03] U8", opcode: Copy8, args: [Register(0xe6), Register(0xe9)], resolved: None }
16 e6 e9 
# 824e7 Instruction { source: "d[0x03..0x04] <- t20 U8", opcode: Copy8, args: [Register(0xe9), Register(0xe7)], resolved: None }
16 e9 e7 
# 824ea Instruction { source: "t21 <- d[0x01..0x02] U8", opcode: Copy8, args: [Register(0xe5), Register(0xe9)], resolved: None }
16 e5 e9 
# 824ed Instruction { source: "d[0x02..0x03] <- t21 U8", opcode: Copy8, args: [Register(0xe9), Register(0xe6)], resolved: None }
16 e9 e6 
# 824f0 Instruction { source: "t22 <- d[0x00..0x01] U8", opcode: Copy8, args: [Register(0xe4), Register(0xe9)], resolved: None }
16 e4 e9 
# 824f3 Instruction { source: "d[0x01..0x02] <- t22 U8", opcode: Copy8, args: [Register(0xe9), Register(0xe5)], resolved: None }
16 e9 e5 
# 824f6 Instruction { source: "t23 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xe9), Constant8(0x00=0)], resolved: None }
00 e9 00 
# 824f9 Instruction { source: "d[0x00..0x01] <- t23 U8", opcode: Copy8, args: [Register(0xe9), Register(0xe4)], resolved: None }
16 e9 e4 
# 824fc Instruction { source: "t25 <- c U32", opcode: Copy32, args: [Register(0xe0), Register(0xd8)], resolved: None }
81 e0 d8 
# 824ff Instruction { source: "t26 <- d U32", opcode: Copy32, args: [Register(0xe4), Register(0xdc)], resolved: None }
81 e4 dc 
# 82502 Instruction { source: "t24 <- t25 Add t26", opcode: Add32NoCarryIn, args: [Register(0xd8), Register(0xdc), Register(0xd8)], resolved: None }
a0 d8 dc d8 
# 82506 Instruction { source: "return Some(t24)", opcode: Copy32, args: [Register(0xd8), Register(0x00)], resolved: None }
81 d8 00 
# 82509 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 8250b Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :mul32_32
# Ret Some(U32)
# Arg0=a
# Arg1=b
# Var a (Arg0 a Number(USIZE)) U32 Some([244, 245, 246, 247])
# Var a_hi (Local a_hi Number(USIZE) U32) U32 Some([248, 249, 250, 251])
# Var b (Arg1 b Number(USIZE)) U32 Some([252, 253, 254, 255])
# Var b_hi (Local b_hi Number(USIZE) U32) U32 Some([16, 17, 18, 19])
# Var c (Local c Number(USIZE) U32) U32 Some([20, 21, 22, 23])
# Var d (Local d Number(USIZE) U32) U32 Some([244, 245, 246, 247])
# Var t0 (t0 Ident("a")) U32 Some([244, 245, 246, 247])
# Var t1 (t1 Ident("b")) U32 Some([248, 249, 250, 251])
# Var t10 (t10 Ident("a")) U32 Some([244, 245, 246, 247])
# Var t11 (t11 Ident("b_hi")) U32 Some([248, 249, 250, 251])
# Var t12 (t12 Index("d", Number(U8, 1))) U8 Some([24])
# Var t13 (t13 Index("d", Number(U8, 0))) U8 Some([24])
# Var t14 (t14 Number(U8, 0)) U8 Some([25])
# Var t15 (t15 Number(U8, 0)) U8 Some([25])
# Var t16 (t16 Arithmetic(Add, Ident("c"), Ident("d"))) U32 Some([244, 245, 246, 247])
# Var t17 (t17 Ident("c")) U32 Some([248, 249, 250, 251])
# Var t18 (t18 Ident("d")) U32 Some([244, 245, 246, 247])
# Var t2 (t2 Index("a", Number(U8, 3))) U8 Some([24])
# Var t3 (t3 Index("a", Number(U8, 2))) U8 Some([24])
# Var t4 (t4 Index("b", Number(U8, 3))) U8 Some([26])
# Var t5 (t5 Index("b", Number(U8, 2))) U8 Some([26])
# Var t6 (t6 Call(Call { function: "mul16_32", parameters: [Ident("a_hi"), Ident("b")] })) U32 Some([252, 253, 254, 255])
# Var t7 (t7 Ident("a_hi")) U32 Some([248, 249, 250, 251])
# Var t8 (t8 Ident("b")) U32 Some([252, 253, 254, 255])
# Var t9 (t9 Call(Call { function: "mul16_32", parameters: [Ident("a"), Ident("b_hi")] })) U32 Some([244, 245, 246, 247])
# 82510 Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [244, 245, 246, 247].", opcode: Copy32, args: [Register(0x00), Register(0xf4)], resolved: None }
81 00 f4 
# 82513 Instruction { source: "Save function parameter 'b' registers [4, 5, 6, 7] to locals [252, 253, 254, 255].", opcode: Copy32, args: [Register(0x04), Register(0xfc)], resolved: None }
81 04 fc 
# 82516 Instruction { source: "t0 <- a U32", opcode: Copy32, args: [Register(0xf4), Register(0xf4)], resolved: None }
81 f4 f4 
# 82519 Instruction { source: "t1 <- b U32", opcode: Copy32, args: [Register(0xfc), Register(0xf8)], resolved: None }
81 fc f8 
# 8251c Instruction { source: "Arg0[a]=t0 Some(c) <= call mul16_32(t0,t1,)", opcode: Copy32, args: [Register(0xf4), Register(0x00)], resolved: None }
81 f4 00 
# 8251f Instruction { source: "Arg1[b]=t1 Some(c) <= call mul16_32(t0,t1,)", opcode: Copy32, args: [Register(0xf8), Register(0x04)], resolved: None }
81 f8 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255}
# Registers used by callee tree: {216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241}
# Registers to save: []
# 82522 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82528 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 32 25 08 00 
# 8252e Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: JmpImm, args: [Label24(:mul16_32)], resolved: None }
40 42 24 08 
# 82532 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82538 Instruction { source: "Some(c) <= call mul16_32(t0,t1,)", opcode: Copy32, args: [Register(0x00), Register(0x14)], resolved: None }
81 00 14 
# 8253b Instruction { source: "a_hi <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0xf8), Constant32(0x00000000=0)], resolved: None }
80 f8 00 00 00 00 
# 82541 Instruction { source: "t2 <- a[0x03..0x04] U8", opcode: Copy8, args: [Register(0xf7), Register(0x18)], resolved: None }
16 f7 18 
# 82544 Instruction { source: "a_hi[0x01..0x02] <- t2 U8", opcode: Copy8, args: [Register(0x18), Register(0xf9)], resolved: None }
16 18 f9 
# 82547 Instruction { source: "t3 <- a[0x02..0x03] U8", opcode: Copy8, args: [Register(0xf6), Register(0x18)], resolved: None }
16 f6 18 
# 8254a Instruction { source: "a_hi[0x00..0x01] <- t3 U8", opcode: Copy8, args: [Register(0x18), Register(0xf8)], resolved: None }
16 18 f8 
# 8254d Instruction { source: "b_hi <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x10), Constant32(0x00000000=0)], resolved: None }
80 10 00 00 00 00 
# 82553 Instruction { source: "t4 <- b[0x03..0x04] U8", opcode: Copy8, args: [Register(0xff), Register(0x1a)], resolved: None }
16 ff 1a 
# 82556 Instruction { source: "b_hi[0x01..0x02] <- t4 U8", opcode: Copy8, args: [Register(0x1a), Register(0x11)], resolved: None }
16 1a 11 
# 82559 Instruction { source: "t5 <- b[0x02..0x03] U8", opcode: Copy8, args: [Register(0xfe), Register(0x1a)], resolved: None }
16 fe 1a 
# 8255c Instruction { source: "b_hi[0x00..0x01] <- t5 U8", opcode: Copy8, args: [Register(0x1a), Register(0x10)], resolved: None }
16 1a 10 
# 8255f Instruction { source: "t7 <- a_hi U32", opcode: Copy32, args: [Register(0xf8), Register(0xf8)], resolved: None }
81 f8 f8 
# 82562 Instruction { source: "t8 <- b U32", opcode: Copy32, args: [Register(0xfc), Register(0xfc)], resolved: None }
81 fc fc 
# 82565 Instruction { source: "Arg0[a]=t7 Some(t6) <= call mul16_32(t7,t8,)", opcode: Copy32, args: [Register(0xf8), Register(0x00)], resolved: None }
81 f8 00 
# 82568 Instruction { source: "Arg1[b]=t8 Some(t6) <= call mul16_32(t7,t8,)", opcode: Copy32, args: [Register(0xfc), Register(0x04)], resolved: None }
81 fc 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255}
# Registers used by callee tree: {216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241}
# Registers to save: []
# 8256b Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82571 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 7b 25 08 00 
# 82577 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: JmpImm, args: [Label24(:mul16_32)], resolved: None }
40 42 24 08 
# 8257b Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82581 Instruction { source: "Some(t6) <= call mul16_32(t7,t8,)", opcode: Copy32, args: [Register(0x00), Register(0xfc)], resolved: None }
81 00 fc 
# 82584 Instruction { source: "t10 <- a U32", opcode: Copy32, args: [Register(0xf4), Register(0xf4)], resolved: None }
81 f4 f4 
# 82587 Instruction { source: "t11 <- b_hi U32", opcode: Copy32, args: [Register(0x10), Register(0xf8)], resolved: None }
81 10 f8 
# 8258a Instruction { source: "Arg0[a]=t10 Some(t9) <= call mul16_32(t10,t11,)", opcode: Copy32, args: [Register(0xf4), Register(0x00)], resolved: None }
81 f4 00 
# 8258d Instruction { source: "Arg1[b]=t11 Some(t9) <= call mul16_32(t10,t11,)", opcode: Copy32, args: [Register(0xf8), Register(0x04)], resolved: None }
81 f8 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255}
# Registers used by callee tree: {216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241}
# Registers to save: []
# 82590 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82596 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c a0 25 08 00 
# 8259c Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: JmpImm, args: [Label24(:mul16_32)], resolved: None }
40 42 24 08 
# 825a0 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 825a6 Instruction { source: "Some(t9) <= call mul16_32(t10,t11,)", opcode: Copy32, args: [Register(0x00), Register(0xf4)], resolved: None }
81 00 f4 
# 825a9 Instruction { source: "d <- t6 Add t9", opcode: Add32NoCarryIn, args: [Register(0xfc), Register(0xf4), Register(0xf4)], resolved: None }
a0 fc f4 f4 
# 825ad Instruction { source: "t12 <- d[0x01..0x02] U8", opcode: Copy8, args: [Register(0xf5), Register(0x18)], resolved: None }
16 f5 18 
# 825b0 Instruction { source: "d[0x03..0x04] <- t12 U8", opcode: Copy8, args: [Register(0x18), Register(0xf7)], resolved: None }
16 18 f7 
# 825b3 Instruction { source: "t13 <- d[0x00..0x01] U8", opcode: Copy8, args: [Register(0xf4), Register(0x18)], resolved: None }
16 f4 18 
# 825b6 Instruction { source: "d[0x02..0x03] <- t13 U8", opcode: Copy8, args: [Register(0x18), Register(0xf6)], resolved: None }
16 18 f6 
# 825b9 Instruction { source: "t14 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x19), Constant8(0x00=0)], resolved: None }
00 19 00 
# 825bc Instruction { source: "d[0x01..0x02] <- t14 U8", opcode: Copy8, args: [Register(0x19), Register(0xf5)], resolved: None }
16 19 f5 
# 825bf Instruction { source: "t15 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x19), Constant8(0x00=0)], resolved: None }
00 19 00 
# 825c2 Instruction { source: "d[0x00..0x01] <- t15 U8", opcode: Copy8, args: [Register(0x19), Register(0xf4)], resolved: None }
16 19 f4 
# 825c5 Instruction { source: "t17 <- c U32", opcode: Copy32, args: [Register(0x14), Register(0xf8)], resolved: None }
81 14 f8 
# 825c8 Instruction { source: "t18 <- d U32", opcode: Copy32, args: [Register(0xf4), Register(0xf4)], resolved: None }
81 f4 f4 
# 825cb Instruction { source: "t16 <- t17 Add t18", opcode: Add32NoCarryIn, args: [Register(0xf8), Register(0xf4), Register(0xf4)], resolved: None }
a0 f8 f4 f4 
# 825cf Instruction { source: "return Some(t16)", opcode: Copy32, args: [Register(0xf4), Register(0x00)], resolved: None }
81 f4 00 
# 825d2 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 825d4 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :mul32_64
# Ret None
# Arg0=a
# Arg1=b
# Arg2=c
# Var __frame_pointer (__frame_pointer) U32 Some([12, 13, 14, 15])
# Var a (Arg0 a Number(USIZE)) U32 Some([28, 29, 30, 31])
# Var a_hi (Local a_hi Number(USIZE) U32) U32 Some([32, 33, 34, 35])
# Var b (Arg1 b Number(USIZE)) U32 Some([36, 37, 38, 39])
# Var b_hi (Local b_hi Number(USIZE) U32) U32 Some([40, 41, 42, 43])
# Var c (Arg2 c Ptr(Struct("U64"))) U32 Some([44, 45, 46, 47])
# Var t0 (Stack size negated) U32 Some([32, 33, 34, 35])
# Var t1 (t1 Index("a", Number(U8, 3))) U8 Some([48])
# Var t10 (t10 Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([44, 45, 46, 47])
# Var t11 (t11 Number(USIZE, 4)) U32 Some([52, 53, 54, 55])
# Var t12 (t12 Call(Call { function: "mul16_32", parameters: [Ident("a_hi"), Ident("b_hi")] })) U32 Some([52, 53, 54, 55])
# Var t13 (t13 Ident("a_hi")) U32 Some([32, 33, 34, 35])
# Var t14 (t14 Ident("b_hi")) U32 Some([40, 41, 42, 43])
# Var t15 (t15 Ident("a_hi")) U32 Some([32, 33, 34, 35])
# Var t16 (t16 Ident("b")) U32 Some([36, 37, 38, 39])
# Var t17 (t17 Index("temp", Number(U8, 0))) U8 Some([56])
# Var t18 (t18 Index("temp", Number(U8, 1))) U8 Some([56])
# Var t19 (t19 Index("temp", Number(U8, 2))) U8 Some([56])
# Var t2 (t2 Index("a", Number(U8, 2))) U8 Some([48])
# Var t20 (t20 Index("temp", Number(U8, 3))) U8 Some([56])
# Var t21 (t21 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Ident("__frame_pointer") }) U32 Some([60, 61, 62, 63])
# Var t22 (t22 Ident("temp_lo")) U32 Some([32, 33, 34, 35])
# Var t23 (t23 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 4)) }) U32 Some([32, 33, 34, 35])
# Var t24 (t24 Ident("__frame_pointer")) U32 Some([60, 61, 62, 63])
# Var t25 (t25 Number(USIZE, 4)) U32 Some([32, 33, 34, 35])
# Var t26 (t26 Ident("temp_hi")) U32 Some([36, 37, 38, 39])
# Var t27 (t27 Call(Call { function: "add_U64", parameters: [Ident("c"), AddressOf(Ident("temp64")), Ident("c")] })) U8 Some([64])
# Var t28 (t28 Ident("c")) U32 Some([32, 33, 34, 35])
# Var t29 (t29 AddressOf(Ident("temp64"))) U32 Some([36, 37, 38, 39])
# Var t3 (t3 Index("b", Number(U8, 3))) U8 Some([65])
# Var t30 (t30 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([36, 37, 38, 39])
# Var t31 (t31 Ident("__frame_pointer")) U32 Some([60, 61, 62, 63])
# Var t32 (t32 Number(USIZE, 0)) U32 Some([36, 37, 38, 39])
# Var t33 (t33 Ident("c")) U32 Some([44, 45, 46, 47])
# Var t34 (t34 Ident("a")) U32 Some([28, 29, 30, 31])
# Var t35 (t35 Ident("b_hi")) U32 Some([32, 33, 34, 35])
# Var t36 (t36 Index("temp", Number(U8, 0))) U8 Some([48])
# Var t37 (t37 Index("temp", Number(U8, 1))) U8 Some([48])
# Var t38 (t38 Index("temp", Number(U8, 2))) U8 Some([48])
# Var t39 (t39 Index("temp", Number(U8, 3))) U8 Some([48])
# Var t4 (t4 Index("b", Number(U8, 2))) U8 Some([65])
# Var t40 (t40 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Ident("__frame_pointer") }) U32 Some([60, 61, 62, 63])
# Var t41 (t41 Ident("temp_lo")) U32 Some([28, 29, 30, 31])
# Var t42 (t42 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 4)) }) U32 Some([28, 29, 30, 31])
# Var t43 (t43 Ident("__frame_pointer")) U32 Some([60, 61, 62, 63])
# Var t44 (t44 Number(USIZE, 4)) U32 Some([28, 29, 30, 31])
# Var t45 (t45 Ident("temp_hi")) U32 Some([32, 33, 34, 35])
# Var t46 (t46 Call(Call { function: "add_U64", parameters: [Ident("c"), AddressOf(Ident("temp64")), Ident("c")] })) U8 Some([64])
# Var t47 (t47 Ident("c")) U32 Some([28, 29, 30, 31])
# Var t48 (t48 AddressOf(Ident("temp64"))) U32 Some([32, 33, 34, 35])
# Var t49 (t49 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([32, 33, 34, 35])
# Var t5 (t5 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") } }) U32 Some([44, 45, 46, 47])
# Var t50 (t50 Ident("__frame_pointer")) U32 Some([60, 61, 62, 63])
# Var t51 (t51 Number(USIZE, 0)) U32 Some([32, 33, 34, 35])
# Var t52 (t52 Ident("c")) U32 Some([36, 37, 38, 39])
# Var t53 (Stack size) U32 Some([28, 29, 30, 31])
# Var t6 (t6 Call(Call { function: "mul16_32", parameters: [Ident("a"), Ident("b")] })) U32 Some([52, 53, 54, 55])
# Var t7 (t7 Ident("a")) U32 Some([28, 29, 30, 31])
# Var t8 (t8 Ident("b")) U32 Some([36, 37, 38, 39])
# Var t9 (t9 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 4)) }) U32 Some([68, 69, 70, 71])
# Var temp (Local temp Number(USIZE) U32) U32 Some([32, 33, 34, 35])
# Var temp64 (Local temp64 Struct("U64") FrameOffset(0)) FrameOffset(0) None
# Var temp_hi (Local temp_hi Number(USIZE) U32) U32 Some([52, 53, 54, 55])
# Var temp_lo (Local temp_lo Number(USIZE) U32) U32 Some([68, 69, 70, 71])
# 825d9 Instruction { source: "reserve 8 bytes of stack space for locals", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffff8=4294967288)], resolved: None }
a3 0c f8 ff ff ff 
# 825df Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [28, 29, 30, 31].", opcode: Copy32, args: [Register(0x00), Register(0x1c)], resolved: None }
81 00 1c 
# 825e2 Instruction { source: "Save function parameter 'b' registers [4, 5, 6, 7] to locals [36, 37, 38, 39].", opcode: Copy32, args: [Register(0x04), Register(0x24)], resolved: None }
81 04 24 
# 825e5 Instruction { source: "Save function parameter 'c' registers [8, 9, 10, 11] to locals [44, 45, 46, 47].", opcode: Copy32, args: [Register(0x08), Register(0x2c)], resolved: None }
81 08 2c 
# 825e8 Instruction { source: "t0 <- 0xfffffff8u32 ", opcode: LoadImm32, args: [Register(0x20), Constant32(0xfffffff8=4294967288)], resolved: None }
80 20 f8 ff ff ff 
# 825ee Instruction { source: "__frame_pointer <- __frame_pointer Add t0", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x20), Register(0x0c)], resolved: None }
a0 0c 20 0c 
# 825f2 Instruction { source: "a_hi <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x20), Constant32(0x00000000=0)], resolved: None }
80 20 00 00 00 00 
# 825f8 Instruction { source: "t1 <- a[0x03..0x04] U8", opcode: Copy8, args: [Register(0x1f), Register(0x30)], resolved: None }
16 1f 30 
# 825fb Instruction { source: "a_hi[0x01..0x02] <- t1 U8", opcode: Copy8, args: [Register(0x30), Register(0x21)], resolved: None }
16 30 21 
# 825fe Instruction { source: "t2 <- a[0x02..0x03] U8", opcode: Copy8, args: [Register(0x1e), Register(0x30)], resolved: None }
16 1e 30 
# 82601 Instruction { source: "a_hi[0x00..0x01] <- t2 U8", opcode: Copy8, args: [Register(0x30), Register(0x20)], resolved: None }
16 30 20 
# 82604 Instruction { source: "b_hi <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x28), Constant32(0x00000000=0)], resolved: None }
80 28 00 00 00 00 
# 8260a Instruction { source: "t3 <- b[0x03..0x04] U8", opcode: Copy8, args: [Register(0x27), Register(0x41)], resolved: None }
16 27 41 
# 8260d Instruction { source: "b_hi[0x01..0x02] <- t3 U8", opcode: Copy8, args: [Register(0x41), Register(0x29)], resolved: None }
16 41 29 
# 82610 Instruction { source: "t4 <- b[0x02..0x03] U8", opcode: Copy8, args: [Register(0x26), Register(0x41)], resolved: None }
16 26 41 
# 82613 Instruction { source: "b_hi[0x00..0x01] <- t4 U8", opcode: Copy8, args: [Register(0x41), Register(0x28)], resolved: None }
16 41 28 
# 82616 Instruction { source: "t5 <- c U32", opcode: Copy32, args: [Register(0x2c), Register(0x2c)], resolved: None }
81 2c 2c 
# 82619 Instruction { source: "t7 <- a U32", opcode: Copy32, args: [Register(0x1c), Register(0x1c)], resolved: None }
81 1c 1c 
# 8261c Instruction { source: "t8 <- b U32", opcode: Copy32, args: [Register(0x24), Register(0x24)], resolved: None }
81 24 24 
# 8261f Instruction { source: "Arg0[a]=t7 Some(t6) <= call mul16_32(t7,t8,)", opcode: Copy32, args: [Register(0x1c), Register(0x00)], resolved: None }
81 1c 00 
# 82622 Instruction { source: "Arg1[b]=t8 Some(t6) <= call mul16_32(t7,t8,)", opcode: Copy32, args: [Register(0x24), Register(0x04)], resolved: None }
81 24 04 
# Registers used by this function: {28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71}
# Registers used by callee tree: {216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241}
# Registers to save: []
# 82625 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8262b Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 35 26 08 00 
# 82631 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: JmpImm, args: [Label24(:mul16_32)], resolved: None }
40 42 24 08 
# 82635 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8263b Instruction { source: "Some(t6) <= call mul16_32(t7,t8,)", opcode: Copy32, args: [Register(0x00), Register(0x34)], resolved: None }
81 00 34 
# 8263e Instruction { source: "mem[t5] <- t6 U32", opcode: Store32_1, args: [Register(0x34), Register(0x2c)], resolved: None }
92 34 2c 
# 82641 Instruction { source: "mem[t5] <- t6 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 82642 Instruction { source: "t10 <- c U32", opcode: Copy32, args: [Register(0x2c), Register(0x2c)], resolved: None }
81 2c 2c 
# 82645 Instruction { source: "t11 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x34), Constant32(0x00000004=4)], resolved: None }
80 34 04 00 00 00 
# 8264b Instruction { source: "t9 <- t10 Add t11", opcode: Add32NoCarryIn, args: [Register(0x2c), Register(0x34), Register(0x44)], resolved: None }
a0 2c 34 44 
# 8264f Instruction { source: "t13 <- a_hi U32", opcode: Copy32, args: [Register(0x20), Register(0x20)], resolved: None }
81 20 20 
# 82652 Instruction { source: "t14 <- b_hi U32", opcode: Copy32, args: [Register(0x28), Register(0x28)], resolved: None }
81 28 28 
# 82655 Instruction { source: "Arg0[a]=t13 Some(t12) <= call mul16_32(t13,t14,)", opcode: Copy32, args: [Register(0x20), Register(0x00)], resolved: None }
81 20 00 
# 82658 Instruction { source: "Arg1[b]=t14 Some(t12) <= call mul16_32(t13,t14,)", opcode: Copy32, args: [Register(0x28), Register(0x04)], resolved: None }
81 28 04 
# Registers used by this function: {28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71}
# Registers used by callee tree: {216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241}
# Registers to save: []
# 8265b Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82661 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 6b 26 08 00 
# 82667 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: JmpImm, args: [Label24(:mul16_32)], resolved: None }
40 42 24 08 
# 8266b Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82671 Instruction { source: "Some(t12) <= call mul16_32(t13,t14,)", opcode: Copy32, args: [Register(0x00), Register(0x34)], resolved: None }
81 00 34 
# 82674 Instruction { source: "mem[t9] <- t12 U32", opcode: Store32_1, args: [Register(0x34), Register(0x44)], resolved: None }
92 34 44 
# 82677 Instruction { source: "mem[t9] <- t12 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 82678 Instruction { source: "temp_lo <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x44), Constant32(0x00000000=0)], resolved: None }
80 44 00 00 00 00 
# 8267e Instruction { source: "temp_hi <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x34), Constant32(0x00000000=0)], resolved: None }
80 34 00 00 00 00 
# 82684 Instruction { source: "t15 <- a_hi U32", opcode: Copy32, args: [Register(0x20), Register(0x20)], resolved: None }
81 20 20 
# 82687 Instruction { source: "t16 <- b U32", opcode: Copy32, args: [Register(0x24), Register(0x24)], resolved: None }
81 24 24 
# 8268a Instruction { source: "Arg0[a]=t15 Some(temp) <= call mul16_32(t15,t16,)", opcode: Copy32, args: [Register(0x20), Register(0x00)], resolved: None }
81 20 00 
# 8268d Instruction { source: "Arg1[b]=t16 Some(temp) <= call mul16_32(t15,t16,)", opcode: Copy32, args: [Register(0x24), Register(0x04)], resolved: None }
81 24 04 
# Registers used by this function: {28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71}
# Registers used by callee tree: {216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241}
# Registers to save: []
# 82690 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82696 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c a0 26 08 00 
# 8269c Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: JmpImm, args: [Label24(:mul16_32)], resolved: None }
40 42 24 08 
# 826a0 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 826a6 Instruction { source: "Some(temp) <= call mul16_32(t15,t16,)", opcode: Copy32, args: [Register(0x00), Register(0x20)], resolved: None }
81 00 20 
# 826a9 Instruction { source: "t17 <- temp[0x00..0x01] U8", opcode: Copy8, args: [Register(0x20), Register(0x38)], resolved: None }
16 20 38 
# 826ac Instruction { source: "temp_lo[0x02..0x03] <- t17 U8", opcode: Copy8, args: [Register(0x38), Register(0x46)], resolved: None }
16 38 46 
# 826af Instruction { source: "t18 <- temp[0x01..0x02] U8", opcode: Copy8, args: [Register(0x21), Register(0x38)], resolved: None }
16 21 38 
# 826b2 Instruction { source: "temp_lo[0x03..0x04] <- t18 U8", opcode: Copy8, args: [Register(0x38), Register(0x47)], resolved: None }
16 38 47 
# 826b5 Instruction { source: "t19 <- temp[0x02..0x03] U8", opcode: Copy8, args: [Register(0x22), Register(0x38)], resolved: None }
16 22 38 
# 826b8 Instruction { source: "temp_hi[0x00..0x01] <- t19 U8", opcode: Copy8, args: [Register(0x38), Register(0x34)], resolved: None }
16 38 34 
# 826bb Instruction { source: "t20 <- temp[0x03..0x04] U8", opcode: Copy8, args: [Register(0x23), Register(0x38)], resolved: None }
16 23 38 
# 826be Instruction { source: "temp_hi[0x01..0x02] <- t20 U8", opcode: Copy8, args: [Register(0x38), Register(0x35)], resolved: None }
16 38 35 
# 826c1 Instruction { source: "t21 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0x3c)], resolved: None }
81 0c 3c 
# 826c4 Instruction { source: "t22 <- temp_lo U32", opcode: Copy32, args: [Register(0x44), Register(0x20)], resolved: None }
81 44 20 
# 826c7 Instruction { source: "mem[t21] <- t22 U32", opcode: Store32_1, args: [Register(0x20), Register(0x3c)], resolved: None }
92 20 3c 
# 826ca Instruction { source: "mem[t21] <- t22 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 826cb Instruction { source: "t24 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0x3c)], resolved: None }
81 0c 3c 
# 826ce Instruction { source: "t25 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x20), Constant32(0x00000004=4)], resolved: None }
80 20 04 00 00 00 
# 826d4 Instruction { source: "t23 <- t24 Add t25", opcode: Add32NoCarryIn, args: [Register(0x3c), Register(0x20), Register(0x20)], resolved: None }
a0 3c 20 20 
# 826d8 Instruction { source: "t26 <- temp_hi U32", opcode: Copy32, args: [Register(0x34), Register(0x24)], resolved: None }
81 34 24 
# 826db Instruction { source: "mem[t23] <- t26 U32", opcode: Store32_1, args: [Register(0x24), Register(0x20)], resolved: None }
92 24 20 
# 826de Instruction { source: "mem[t23] <- t26 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 826df Instruction { source: "t28 <- c U32", opcode: Copy32, args: [Register(0x2c), Register(0x20)], resolved: None }
81 2c 20 
# 826e2 Instruction { source: "t31 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0x3c)], resolved: None }
81 0c 3c 
# 826e5 Instruction { source: "t32 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x24), Constant32(0x00000000=0)], resolved: None }
80 24 00 00 00 00 
# 826eb Instruction { source: "t30 <- t31 Add t32", opcode: Add32NoCarryIn, args: [Register(0x3c), Register(0x24), Register(0x24)], resolved: None }
a0 3c 24 24 
# 826ef Instruction { source: "t29 <- t30 U32", opcode: Copy32, args: [Register(0x24), Register(0x24)], resolved: None }
81 24 24 
# 826f2 Instruction { source: "t33 <- c U32", opcode: Copy32, args: [Register(0x2c), Register(0x2c)], resolved: None }
81 2c 2c 
# 826f5 Instruction { source: "Arg0[a]=t28 None <= call add_U64(t28,t29,t33,)", opcode: Copy32, args: [Register(0x20), Register(0x00)], resolved: None }
81 20 00 
# 826f8 Instruction { source: "Arg1[b]=t29 None <= call add_U64(t28,t29,t33,)", opcode: Copy32, args: [Register(0x24), Register(0x04)], resolved: None }
81 24 04 
# 826fb Instruction { source: "Arg2[c]=t33 None <= call add_U64(t28,t29,t33,)", opcode: Copy32, args: [Register(0x2c), Register(0x08)], resolved: None }
81 2c 08 
# Registers used by this function: {28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71}
# Registers used by callee tree: {80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107}
# Registers to save: []
# 826fe Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82704 Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 0e 27 08 00 
# 8270a Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: JmpImm, args: [Label24(:add_U64)], resolved: None }
40 24 1d 08 
# 8270e Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82714 Instruction { source: "t34 <- a U32", opcode: Copy32, args: [Register(0x1c), Register(0x1c)], resolved: None }
81 1c 1c 
# 82717 Instruction { source: "t35 <- b_hi U32", opcode: Copy32, args: [Register(0x28), Register(0x20)], resolved: None }
81 28 20 
# 8271a Instruction { source: "Arg0[a]=t34 Some(temp) <= call mul16_32(t34,t35,)", opcode: Copy32, args: [Register(0x1c), Register(0x00)], resolved: None }
81 1c 00 
# 8271d Instruction { source: "Arg1[b]=t35 Some(temp) <= call mul16_32(t34,t35,)", opcode: Copy32, args: [Register(0x20), Register(0x04)], resolved: None }
81 20 04 
# Registers used by this function: {28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71}
# Registers used by callee tree: {216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241}
# Registers to save: []
# 82720 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82726 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 30 27 08 00 
# 8272c Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: JmpImm, args: [Label24(:mul16_32)], resolved: None }
40 42 24 08 
# 82730 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82736 Instruction { source: "Some(temp) <= call mul16_32(t34,t35,)", opcode: Copy32, args: [Register(0x00), Register(0x20)], resolved: None }
81 00 20 
# 82739 Instruction { source: "t36 <- temp[0x00..0x01] U8", opcode: Copy8, args: [Register(0x20), Register(0x30)], resolved: None }
16 20 30 
# 8273c Instruction { source: "temp_lo[0x02..0x03] <- t36 U8", opcode: Copy8, args: [Register(0x30), Register(0x46)], resolved: None }
16 30 46 
# 8273f Instruction { source: "t37 <- temp[0x01..0x02] U8", opcode: Copy8, args: [Register(0x21), Register(0x30)], resolved: None }
16 21 30 
# 82742 Instruction { source: "temp_lo[0x03..0x04] <- t37 U8", opcode: Copy8, args: [Register(0x30), Register(0x47)], resolved: None }
16 30 47 
# 82745 Instruction { source: "t38 <- temp[0x02..0x03] U8", opcode: Copy8, args: [Register(0x22), Register(0x30)], resolved: None }
16 22 30 
# 82748 Instruction { source: "temp_hi[0x00..0x01] <- t38 U8", opcode: Copy8, args: [Register(0x30), Register(0x34)], resolved: None }
16 30 34 
# 8274b Instruction { source: "t39 <- temp[0x03..0x04] U8", opcode: Copy8, args: [Register(0x23), Register(0x30)], resolved: None }
16 23 30 
# 8274e Instruction { source: "temp_hi[0x01..0x02] <- t39 U8", opcode: Copy8, args: [Register(0x30), Register(0x35)], resolved: None }
16 30 35 
# 82751 Instruction { source: "t40 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0x3c)], resolved: None }
81 0c 3c 
# 82754 Instruction { source: "t41 <- temp_lo U32", opcode: Copy32, args: [Register(0x44), Register(0x1c)], resolved: None }
81 44 1c 
# 82757 Instruction { source: "mem[t40] <- t41 U32", opcode: Store32_1, args: [Register(0x1c), Register(0x3c)], resolved: None }
92 1c 3c 
# 8275a Instruction { source: "mem[t40] <- t41 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 8275b Instruction { source: "t43 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0x3c)], resolved: None }
81 0c 3c 
# 8275e Instruction { source: "t44 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x1c), Constant32(0x00000004=4)], resolved: None }
80 1c 04 00 00 00 
# 82764 Instruction { source: "t42 <- t43 Add t44", opcode: Add32NoCarryIn, args: [Register(0x3c), Register(0x1c), Register(0x1c)], resolved: None }
a0 3c 1c 1c 
# 82768 Instruction { source: "t45 <- temp_hi U32", opcode: Copy32, args: [Register(0x34), Register(0x20)], resolved: None }
81 34 20 
# 8276b Instruction { source: "mem[t42] <- t45 U32", opcode: Store32_1, args: [Register(0x20), Register(0x1c)], resolved: None }
92 20 1c 
# 8276e Instruction { source: "mem[t42] <- t45 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 8276f Instruction { source: "t47 <- c U32", opcode: Copy32, args: [Register(0x2c), Register(0x1c)], resolved: None }
81 2c 1c 
# 82772 Instruction { source: "t50 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0x3c)], resolved: None }
81 0c 3c 
# 82775 Instruction { source: "t51 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x20), Constant32(0x00000000=0)], resolved: None }
80 20 00 00 00 00 
# 8277b Instruction { source: "t49 <- t50 Add t51", opcode: Add32NoCarryIn, args: [Register(0x3c), Register(0x20), Register(0x20)], resolved: None }
a0 3c 20 20 
# 8277f Instruction { source: "t48 <- t49 U32", opcode: Copy32, args: [Register(0x20), Register(0x20)], resolved: None }
81 20 20 
# 82782 Instruction { source: "t52 <- c U32", opcode: Copy32, args: [Register(0x2c), Register(0x24)], resolved: None }
81 2c 24 
# 82785 Instruction { source: "Arg0[a]=t47 None <= call add_U64(t47,t48,t52,)", opcode: Copy32, args: [Register(0x1c), Register(0x00)], resolved: None }
81 1c 00 
# 82788 Instruction { source: "Arg1[b]=t48 None <= call add_U64(t47,t48,t52,)", opcode: Copy32, args: [Register(0x20), Register(0x04)], resolved: None }
81 20 04 
# 8278b Instruction { source: "Arg2[c]=t52 None <= call add_U64(t47,t48,t52,)", opcode: Copy32, args: [Register(0x24), Register(0x08)], resolved: None }
81 24 08 
# Registers used by this function: {28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71}
# Registers used by callee tree: {80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107}
# Registers to save: []
# 8278e Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82794 Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 9e 27 08 00 
# 8279a Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: JmpImm, args: [Label24(:add_U64)], resolved: None }
40 24 1d 08 
# 8279e Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 827a4 Instruction { source: "t53 <- 0n8/0x00000008u32 ", opcode: LoadImm32, args: [Register(0x1c), Constant32(0x00000008=8)], resolved: None }
80 1c 08 00 00 00 
# 827aa Instruction { source: "__frame_pointer <- __frame_pointer Add t53", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x1c), Register(0x0c)], resolved: None }
a0 0c 1c 0c 
# 827ae Instruction { source: "Dealloc 8 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000008=8)], resolved: None }
a3 0c 08 00 00 00 
# 827b4 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 827b6 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :mul8
# Ret Some(U8)
# Arg0=x
# Arg1=y
# Var t0 (t0 Arithmetic(Multiply, Ident("x"), Ident("y"))) U8 Some([72])
# Var t1 (t1 Ident("x")) U8 Some([72])
# Var t2 (t2 Ident("y")) U8 Some([73])
# Var x (Arg0 x Number(U8)) U8 Some([72])
# Var y (Arg1 y Number(U8)) U8 Some([73])
# 827bb Instruction { source: "Save function parameter 'x' registers [0] to locals [72].", opcode: Copy8, args: [Register(0x00), Register(0x48)], resolved: None }
16 00 48 
# 827be Instruction { source: "Save function parameter 'y' registers [4] to locals [73].", opcode: Copy8, args: [Register(0x04), Register(0x49)], resolved: None }
16 04 49 
# 827c1 Instruction { source: "t1 <- x U8", opcode: Copy8, args: [Register(0x48), Register(0x48)], resolved: None }
16 48 48 
# 827c4 Instruction { source: "t2 <- y U8", opcode: Copy8, args: [Register(0x49), Register(0x49)], resolved: None }
16 49 49 
# 827c7 Instruction { source: "t0 <- t1 Multiply t2", opcode: Mul8_1, args: [Register(0x48), Register(0x49)], resolved: None }
20 48 49 
# 827ca Instruction { source: "t0 <- t1 Multiply t2", opcode: Mul8_2, args: [], resolved: None }
21 
# 827cb Instruction { source: "t0 <- t1 Multiply t2", opcode: Copy8, args: [Register(0x00), Register(0x48)], resolved: None }
16 00 48 
# 827ce Instruction { source: "return Some(t0)", opcode: Copy8, args: [Register(0x48), Register(0x00)], resolved: None }
16 48 00 
# 827d1 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 827d3 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :mul8_16
# Ret Some(U32)
# Arg0=x
# Arg1=y
# Var t0 (t0 Arithmetic(Multiply, Cast { old_type: None, new_type: Number(USIZE), value: Ident("x") }, Cast { old_type: None, new_type: Number(USIZE), value: Ident("y") })) U32 Some([76, 77, 78, 79])
# Var t1 (t1 Cast { old_type: None, new_type: Number(USIZE), value: Ident("x") }) U32 Some([76, 77, 78, 79])
# Var t2 (t2 Ident("x")) U8 Some([80])
# Var t3 (t3 Cast { old_type: None, new_type: Number(USIZE), value: Ident("y") }) U32 Some([84, 85, 86, 87])
# Var t4 (t4 Ident("y")) U8 Some([88])
# Var x (Arg0 x Number(U8)) U8 Some([80])
# Var y (Arg1 y Number(U8)) U8 Some([88])
# 827d8 Instruction { source: "Save function parameter 'x' registers [0] to locals [80].", opcode: Copy8, args: [Register(0x00), Register(0x50)], resolved: None }
16 00 50 
# 827db Instruction { source: "Save function parameter 'y' registers [4] to locals [88].", opcode: Copy8, args: [Register(0x04), Register(0x58)], resolved: None }
16 04 58 
# 827de Instruction { source: "t2 <- x U8", opcode: Copy8, args: [Register(0x50), Register(0x50)], resolved: None }
16 50 50 
# 827e1 Instruction { source: "Zero-pad for t1 U32 <- t2 U8", opcode: LoadImm32, args: [Register(0x4c), Constant32(0x00000000=0)], resolved: None }
80 4c 00 00 00 00 
# 827e7 Instruction { source: "t1 U32 <- t2 U8", opcode: Copy8, args: [Register(0x50), Register(0x4c)], resolved: None }
16 50 4c 
# 827ea Instruction { source: "t4 <- y U8", opcode: Copy8, args: [Register(0x58), Register(0x58)], resolved: None }
16 58 58 
# 827ed Instruction { source: "Zero-pad for t3 U32 <- t4 U8", opcode: LoadImm32, args: [Register(0x54), Constant32(0x00000000=0)], resolved: None }
80 54 00 00 00 00 
# 827f3 Instruction { source: "t3 U32 <- t4 U8", opcode: Copy8, args: [Register(0x58), Register(0x54)], resolved: None }
16 58 54 
# 827f6 Instruction { source: "t0 <- t1 Multiply t3", opcode: LoadImm32, args: [Register(0x00), Constant32(0x00000000=0)], resolved: None }
80 00 00 00 00 00 
# 827fc Instruction { source: "t0 <- t1 Multiply t3", opcode: Mul8_1, args: [Register(0x4c), Register(0x54)], resolved: None }
20 4c 54 
# 827ff Instruction { source: "t0 <- t1 Multiply t3", opcode: Mul8_2, args: [], resolved: None }
21 
# 82800 Instruction { source: "t0 <- t1 Multiply t3", opcode: Copy32, args: [Register(0x00), Register(0x4c)], resolved: None }
81 00 4c 
# 82803 Instruction { source: "return Some(t0)", opcode: Copy32, args: [Register(0x4c), Register(0x00)], resolved: None }
81 4c 00 
# 82806 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82808 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :print_dec32
# Ret None
# Arg0=a
# Var a (Arg0 a Number(USIZE)) U32 Some([92, 93, 94, 95])
# Var b (Local b Number(USIZE) U32) U32 Some([96, 97, 98, 99])
# Var t0 (t0 Ident("a")) U32 Some([92, 93, 94, 95])
# Var t1 (t1 Number(USIZE, 10)) U32 Some([96, 97, 98, 99])
# Var t10 (t10 Index("a", Number(U8, 0))) U8 Some([100])
# Var t11 (t11 Number(U8, 48)) U8 Some([101])
# Var t2 (t2 Ident("a")) U32 Some([92, 93, 94, 95])
# Var t3 (t3 Call(Call { function: "print_dec32", parameters: [Ident("b")] })) U8 Some([100])
# Var t4 (t4 Ident("b")) U32 Some([96, 97, 98, 99])
# Var t5 (t5 Ident("a")) U32 Some([92, 93, 94, 95])
# Var t6 (t6 Call(Call { function: "mul32_32", parameters: [Ident("b"), Number(USIZE, 10)] })) U32 Some([96, 97, 98, 99])
# Var t7 (t7 Ident("b")) U32 Some([96, 97, 98, 99])
# Var t8 (t8 Number(USIZE, 10)) U32 Some([104, 105, 106, 107])
# Var t9 (t9 Arithmetic(Add, Index("a", Number(U8, 0)), Number(U8, 48))) U8 Some([100])
# 8280d Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [92, 93, 94, 95].", opcode: Copy32, args: [Register(0x00), Register(0x5c)], resolved: None }
81 00 5c 
# 82810 Instruction { source: "t0 <- a U32", opcode: Copy32, args: [Register(0x5c), Register(0x5c)], resolved: None }
81 5c 5c 
# 82813 Instruction { source: "t1 <- 0n10/0x0000000au32 ", opcode: LoadImm32, args: [Register(0x60), Constant32(0x0000000a=10)], resolved: None }
80 60 0a 00 00 00 
# 82819 Instruction { source: "if t0 >= t1 then 'print_dec32_if_true_0_1' else 'print_dec32_if_else_0_2'", opcode: Cmp8, args: [Register(0x63), Register(0x5f)], resolved: None }
25 63 5f 
# 8281c Instruction { source: "if t0 >= t1 then 'print_dec32_if_true_0_1' else 'print_dec32_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x62), Register(0x5e)], resolved: None }
26 62 5e 
# 8281f Instruction { source: "if t0 >= t1 then 'print_dec32_if_true_0_1' else 'print_dec32_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x61), Register(0x5d)], resolved: None }
26 61 5d 
# 82822 Instruction { source: "if t0 >= t1 then 'print_dec32_if_true_0_1' else 'print_dec32_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x60), Register(0x5c)], resolved: None }
26 60 5c 
# 82825 Instruction { source: "if t0 >= t1 then 'print_dec32_if_true_0_1' else 'print_dec32_if_else_0_2'", opcode: JcImm, args: [Label24(print_dec32_if_true_0_1)], resolved: None }
41 2d 28 08 
# 82829 Instruction { source: "if t0 >= t1 then 'print_dec32_if_true_0_1' else 'print_dec32_if_else_0_2'", opcode: JmpImm, args: [Label24(print_dec32_if_else_0_2)], resolved: None }
40 1c 29 08 
# print_dec32_if_true_0_1
# 8282d Instruction { source: "t2 <- a U32", opcode: Copy32, args: [Register(0x5c), Register(0x5c)], resolved: None }
81 5c 5c 
# 82830 Instruction { source: "Arg0[a]=t2 Some(b) <= call div32_by10(t2,)", opcode: Copy32, args: [Register(0x5c), Register(0x00)], resolved: None }
81 5c 00 
# Registers used by this function: {92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 104, 105, 106, 107}
# Registers used by callee tree: {28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 156, 157, 158, 159, 160, 161, 162, 176, 177, 178, 179, 180, 184, 185, 186, 187, 188, 189, 190, 191, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241}
# Registers to save: [92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 104, 105, 106, 107]
# 82833 Instruction { source: "Saving reg0x6b before Some(b) <= call div32_by10(t2,)", opcode: Push8, args: [Register(0x6b)], resolved: None }
14 6b 
# 82835 Instruction { source: "Saving reg0x6a before Some(b) <= call div32_by10(t2,)", opcode: Push8, args: [Register(0x6a)], resolved: None }
14 6a 
# 82837 Instruction { source: "Saving reg0x69 before Some(b) <= call div32_by10(t2,)", opcode: Push8, args: [Register(0x69)], resolved: None }
14 69 
# 82839 Instruction { source: "Saving reg0x68 before Some(b) <= call div32_by10(t2,)", opcode: Push8, args: [Register(0x68)], resolved: None }
14 68 
# 8283b Instruction { source: "Saving reg0x65 before Some(b) <= call div32_by10(t2,)", opcode: Push8, args: [Register(0x65)], resolved: None }
14 65 
# 8283d Instruction { source: "Saving reg0x64 before Some(b) <= call div32_by10(t2,)", opcode: Push8, args: [Register(0x64)], resolved: None }
14 64 
# 8283f Instruction { source: "Saving reg0x63 before Some(b) <= call div32_by10(t2,)", opcode: Push8, args: [Register(0x63)], resolved: None }
14 63 
# 82841 Instruction { source: "Saving reg0x62 before Some(b) <= call div32_by10(t2,)", opcode: Push8, args: [Register(0x62)], resolved: None }
14 62 
# 82843 Instruction { source: "Saving reg0x61 before Some(b) <= call div32_by10(t2,)", opcode: Push8, args: [Register(0x61)], resolved: None }
14 61 
# 82845 Instruction { source: "Saving reg0x60 before Some(b) <= call div32_by10(t2,)", opcode: Push8, args: [Register(0x60)], resolved: None }
14 60 
# 82847 Instruction { source: "Saving reg0x5f before Some(b) <= call div32_by10(t2,)", opcode: Push8, args: [Register(0x5f)], resolved: None }
14 5f 
# 82849 Instruction { source: "Saving reg0x5e before Some(b) <= call div32_by10(t2,)", opcode: Push8, args: [Register(0x5e)], resolved: None }
14 5e 
# 8284b Instruction { source: "Saving reg0x5d before Some(b) <= call div32_by10(t2,)", opcode: Push8, args: [Register(0x5d)], resolved: None }
14 5d 
# 8284d Instruction { source: "Saving reg0x5c before Some(b) <= call div32_by10(t2,)", opcode: Push8, args: [Register(0x5c)], resolved: None }
14 5c 
# 8284f Instruction { source: "PseudoCall(Label24(:div32_by10))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82855 Instruction { source: "PseudoCall(Label24(:div32_by10))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 5f 28 08 00 
# 8285b Instruction { source: "PseudoCall(Label24(:div32_by10))", opcode: JmpImm, args: [Label24(:div32_by10)], resolved: None }
40 8c 22 08 
# 8285f Instruction { source: "PseudoCall(Label24(:div32_by10))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82865 Instruction { source: "Restoring reg0x5c after Some(b) <= call div32_by10(t2,)", opcode: Pop8, args: [Register(0x5c)], resolved: None }
15 5c 
# 82867 Instruction { source: "Restoring reg0x5d after Some(b) <= call div32_by10(t2,)", opcode: Pop8, args: [Register(0x5d)], resolved: None }
15 5d 
# 82869 Instruction { source: "Restoring reg0x5e after Some(b) <= call div32_by10(t2,)", opcode: Pop8, args: [Register(0x5e)], resolved: None }
15 5e 
# 8286b Instruction { source: "Restoring reg0x5f after Some(b) <= call div32_by10(t2,)", opcode: Pop8, args: [Register(0x5f)], resolved: None }
15 5f 
# 8286d Instruction { source: "Restoring reg0x60 after Some(b) <= call div32_by10(t2,)", opcode: Pop8, args: [Register(0x60)], resolved: None }
15 60 
# 8286f Instruction { source: "Restoring reg0x61 after Some(b) <= call div32_by10(t2,)", opcode: Pop8, args: [Register(0x61)], resolved: None }
15 61 
# 82871 Instruction { source: "Restoring reg0x62 after Some(b) <= call div32_by10(t2,)", opcode: Pop8, args: [Register(0x62)], resolved: None }
15 62 
# 82873 Instruction { source: "Restoring reg0x63 after Some(b) <= call div32_by10(t2,)", opcode: Pop8, args: [Register(0x63)], resolved: None }
15 63 
# 82875 Instruction { source: "Restoring reg0x64 after Some(b) <= call div32_by10(t2,)", opcode: Pop8, args: [Register(0x64)], resolved: None }
15 64 
# 82877 Instruction { source: "Restoring reg0x65 after Some(b) <= call div32_by10(t2,)", opcode: Pop8, args: [Register(0x65)], resolved: None }
15 65 
# 82879 Instruction { source: "Restoring reg0x68 after Some(b) <= call div32_by10(t2,)", opcode: Pop8, args: [Register(0x68)], resolved: None }
15 68 
# 8287b Instruction { source: "Restoring reg0x69 after Some(b) <= call div32_by10(t2,)", opcode: Pop8, args: [Register(0x69)], resolved: None }
15 69 
# 8287d Instruction { source: "Restoring reg0x6a after Some(b) <= call div32_by10(t2,)", opcode: Pop8, args: [Register(0x6a)], resolved: None }
15 6a 
# 8287f Instruction { source: "Restoring reg0x6b after Some(b) <= call div32_by10(t2,)", opcode: Pop8, args: [Register(0x6b)], resolved: None }
15 6b 
# 82881 Instruction { source: "Some(b) <= call div32_by10(t2,)", opcode: Copy32, args: [Register(0x00), Register(0x60)], resolved: None }
81 00 60 
# 82884 Instruction { source: "t4 <- b U32", opcode: Copy32, args: [Register(0x60), Register(0x60)], resolved: None }
81 60 60 
# 82887 Instruction { source: "Arg0[a]=t4 None <= call print_dec32(t4,)", opcode: Copy32, args: [Register(0x60), Register(0x00)], resolved: None }
81 60 00 
# Registers used by this function: {92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 104, 105, 106, 107}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 156, 157, 158, 159, 160, 161, 162, 176, 177, 178, 179, 180, 184, 185, 186, 187, 188, 189, 190, 191, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255}
# Registers to save: [92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 104, 105, 106, 107]
# 8288a Instruction { source: "Saving reg0x6b before None <= call print_dec32(t4,)", opcode: Push8, args: [Register(0x6b)], resolved: None }
14 6b 
# 8288c Instruction { source: "Saving reg0x6a before None <= call print_dec32(t4,)", opcode: Push8, args: [Register(0x6a)], resolved: None }
14 6a 
# 8288e Instruction { source: "Saving reg0x69 before None <= call print_dec32(t4,)", opcode: Push8, args: [Register(0x69)], resolved: None }
14 69 
# 82890 Instruction { source: "Saving reg0x68 before None <= call print_dec32(t4,)", opcode: Push8, args: [Register(0x68)], resolved: None }
14 68 
# 82892 Instruction { source: "Saving reg0x65 before None <= call print_dec32(t4,)", opcode: Push8, args: [Register(0x65)], resolved: None }
14 65 
# 82894 Instruction { source: "Saving reg0x64 before None <= call print_dec32(t4,)", opcode: Push8, args: [Register(0x64)], resolved: None }
14 64 
# 82896 Instruction { source: "Saving reg0x63 before None <= call print_dec32(t4,)", opcode: Push8, args: [Register(0x63)], resolved: None }
14 63 
# 82898 Instruction { source: "Saving reg0x62 before None <= call print_dec32(t4,)", opcode: Push8, args: [Register(0x62)], resolved: None }
14 62 
# 8289a Instruction { source: "Saving reg0x61 before None <= call print_dec32(t4,)", opcode: Push8, args: [Register(0x61)], resolved: None }
14 61 
# 8289c Instruction { source: "Saving reg0x60 before None <= call print_dec32(t4,)", opcode: Push8, args: [Register(0x60)], resolved: None }
14 60 
# 8289e Instruction { source: "Saving reg0x5f before None <= call print_dec32(t4,)", opcode: Push8, args: [Register(0x5f)], resolved: None }
14 5f 
# 828a0 Instruction { source: "Saving reg0x5e before None <= call print_dec32(t4,)", opcode: Push8, args: [Register(0x5e)], resolved: None }
14 5e 
# 828a2 Instruction { source: "Saving reg0x5d before None <= call print_dec32(t4,)", opcode: Push8, args: [Register(0x5d)], resolved: None }
14 5d 
# 828a4 Instruction { source: "Saving reg0x5c before None <= call print_dec32(t4,)", opcode: Push8, args: [Register(0x5c)], resolved: None }
14 5c 
# 828a6 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 828ac Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c b6 28 08 00 
# 828b2 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: JmpImm, args: [Label24(:print_dec32)], resolved: None }
40 0d 28 08 
# 828b6 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 828bc Instruction { source: "Restoring reg0x5c after None <= call print_dec32(t4,)", opcode: Pop8, args: [Register(0x5c)], resolved: None }
15 5c 
# 828be Instruction { source: "Restoring reg0x5d after None <= call print_dec32(t4,)", opcode: Pop8, args: [Register(0x5d)], resolved: None }
15 5d 
# 828c0 Instruction { source: "Restoring reg0x5e after None <= call print_dec32(t4,)", opcode: Pop8, args: [Register(0x5e)], resolved: None }
15 5e 
# 828c2 Instruction { source: "Restoring reg0x5f after None <= call print_dec32(t4,)", opcode: Pop8, args: [Register(0x5f)], resolved: None }
15 5f 
# 828c4 Instruction { source: "Restoring reg0x60 after None <= call print_dec32(t4,)", opcode: Pop8, args: [Register(0x60)], resolved: None }
15 60 
# 828c6 Instruction { source: "Restoring reg0x61 after None <= call print_dec32(t4,)", opcode: Pop8, args: [Register(0x61)], resolved: None }
15 61 
# 828c8 Instruction { source: "Restoring reg0x62 after None <= call print_dec32(t4,)", opcode: Pop8, args: [Register(0x62)], resolved: None }
15 62 
# 828ca Instruction { source: "Restoring reg0x63 after None <= call print_dec32(t4,)", opcode: Pop8, args: [Register(0x63)], resolved: None }
15 63 
# 828cc Instruction { source: "Restoring reg0x64 after None <= call print_dec32(t4,)", opcode: Pop8, args: [Register(0x64)], resolved: None }
15 64 
# 828ce Instruction { source: "Restoring reg0x65 after None <= call print_dec32(t4,)", opcode: Pop8, args: [Register(0x65)], resolved: None }
15 65 
# 828d0 Instruction { source: "Restoring reg0x68 after None <= call print_dec32(t4,)", opcode: Pop8, args: [Register(0x68)], resolved: None }
15 68 
# 828d2 Instruction { source: "Restoring reg0x69 after None <= call print_dec32(t4,)", opcode: Pop8, args: [Register(0x69)], resolved: None }
15 69 
# 828d4 Instruction { source: "Restoring reg0x6a after None <= call print_dec32(t4,)", opcode: Pop8, args: [Register(0x6a)], resolved: None }
15 6a 
# 828d6 Instruction { source: "Restoring reg0x6b after None <= call print_dec32(t4,)", opcode: Pop8, args: [Register(0x6b)], resolved: None }
15 6b 
# 828d8 Instruction { source: "t5 <- a U32", opcode: Copy32, args: [Register(0x5c), Register(0x5c)], resolved: None }
81 5c 5c 
# 828db Instruction { source: "t7 <- b U32", opcode: Copy32, args: [Register(0x60), Register(0x60)], resolved: None }
81 60 60 
# 828de Instruction { source: "t8 <- 0n10/0x0000000au32 ", opcode: LoadImm32, args: [Register(0x68), Constant32(0x0000000a=10)], resolved: None }
80 68 0a 00 00 00 
# 828e4 Instruction { source: "Arg0[a]=t7 Some(t6) <= call mul32_32(t7,t8,)", opcode: Copy32, args: [Register(0x60), Register(0x00)], resolved: None }
81 60 00 
# 828e7 Instruction { source: "Arg1[b]=t8 Some(t6) <= call mul32_32(t7,t8,)", opcode: Copy32, args: [Register(0x68), Register(0x04)], resolved: None }
81 68 04 
# Registers used by this function: {92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 104, 105, 106, 107}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255}
# Registers to save: []
# 828ea Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 828f0 Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c fa 28 08 00 
# 828f6 Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: JmpImm, args: [Label24(:mul32_32)], resolved: None }
40 10 25 08 
# 828fa Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82900 Instruction { source: "Some(t6) <= call mul32_32(t7,t8,)", opcode: Copy32, args: [Register(0x00), Register(0x60)], resolved: None }
81 00 60 
# 82903 Instruction { source: "a <- t5 Subtract t6", opcode: Copy32, args: [Register(0x60), Register(0x00)], resolved: None }
81 60 00 
# 82906 Instruction { source: "a <- t5 Subtract t6", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 82908 Instruction { source: "a <- t5 Subtract t6", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 8290a Instruction { source: "a <- t5 Subtract t6", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 8290c Instruction { source: "a <- t5 Subtract t6", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 8290e Instruction { source: "a <- t5 Subtract t6", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 82914 Instruction { source: "a <- t5 Subtract t6", opcode: Add32NoCarryIn, args: [Register(0x5c), Register(0x00), Register(0x5c)], resolved: None }
a0 5c 00 5c 
# 82918 Instruction { source: "goto print_dec32_if_end_0", opcode: JmpImm, args: [Label24(print_dec32_if_end_0)], resolved: None }
40 1c 29 08 
# print_dec32_if_else_0_2
# print_dec32_if_end_0
# 8291c Instruction { source: "t10 <- a[0x00..0x01] U8", opcode: Copy8, args: [Register(0x5c), Register(0x64)], resolved: None }
16 5c 64 
# 8291f Instruction { source: "t11 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x65), Constant8(0x30=48)], resolved: None }
00 65 30 
# 82922 Instruction { source: "t9 <- t10 Add t11", opcode: Add8NoCarryIn, args: [Register(0x64), Register(0x65), Register(0x64)], resolved: None }
24 64 65 64 
# 82926 Instruction { source: "ttyout <- t9", opcode: TtyOut, args: [Register(0x64)], resolved: None }
13 64 
# 82928 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 8292a Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :print_dec32_test
# Ret Some(U8)
# Arg0=a
# Arg1=b
# Var a (Arg0 a Number(USIZE)) U32 Some([108, 109, 110, 111])
# Var b (Arg1 b Number(USIZE)) U32 Some([112, 113, 114, 115])
# Var t0 (t0 Call(Call { function: "print_dec32", parameters: [Ident("a")] })) U8 Some([116])
# Var t1 (t1 Ident("a")) U32 Some([108, 109, 110, 111])
# Var t2 (t2 Number(U8, 0)) U8 Some([116])
# 8292f Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [108, 109, 110, 111].", opcode: Copy32, args: [Register(0x00), Register(0x6c)], resolved: None }
81 00 6c 
# 82932 Instruction { source: "Save function parameter 'b' registers [4, 5, 6, 7] to locals [112, 113, 114, 115].", opcode: Copy32, args: [Register(0x04), Register(0x70)], resolved: None }
81 04 70 
# 82935 Instruction { source: "t1 <- a U32", opcode: Copy32, args: [Register(0x6c), Register(0x6c)], resolved: None }
81 6c 6c 
# 82938 Instruction { source: "Arg0[a]=t1 None <= call print_dec32(t1,)", opcode: Copy32, args: [Register(0x6c), Register(0x00)], resolved: None }
81 6c 00 
# Registers used by this function: {108, 109, 110, 111, 112, 113, 114, 115, 116}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 156, 157, 158, 159, 160, 161, 162, 176, 177, 178, 179, 180, 184, 185, 186, 187, 188, 189, 190, 191, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255}
# Registers to save: []
# 8293b Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82941 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 4b 29 08 00 
# 82947 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: JmpImm, args: [Label24(:print_dec32)], resolved: None }
40 0d 28 08 
# 8294b Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82951 Instruction { source: "t2 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x74), Constant8(0x00=0)], resolved: None }
00 74 00 
# 82954 Instruction { source: "return Some(t2)", opcode: Copy8, args: [Register(0x74), Register(0x00)], resolved: None }
16 74 00 
# 82957 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82959 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :print_dec8
# Ret None
# Arg0=a
# Var a (Arg0 a Number(U8)) U8 Some([117])
# Var b (Local b Number(U8) U8) U8 Some([118])
# Var t0 (t0 Ident("a")) U8 Some([117])
# Var t1 (t1 Number(U8, 10)) U8 Some([118])
# Var t10 (t10 Arithmetic(Add, Ident("a"), Number(U8, 48))) U8 Some([117])
# Var t11 (t11 Ident("a")) U8 Some([117])
# Var t12 (t12 Number(U8, 48)) U8 Some([118])
# Var t2 (t2 Ident("a")) U8 Some([117])
# Var t3 (t3 Number(U8, 10)) U8 Some([118])
# Var t4 (t4 Call(Call { function: "print_dec8", parameters: [Ident("b")] })) U8 Some([117])
# Var t5 (t5 Ident("b")) U8 Some([118])
# Var t6 (t6 Ident("a")) U8 Some([117])
# Var t7 (t7 Arithmetic(Multiply, Ident("b"), Number(U8, 10))) U8 Some([118])
# Var t8 (t8 Ident("b")) U8 Some([118])
# Var t9 (t9 Number(U8, 10)) U8 Some([119])
# 8295e Instruction { source: "Save function parameter 'a' registers [0] to locals [117].", opcode: Copy8, args: [Register(0x00), Register(0x75)], resolved: None }
16 00 75 
# 82961 Instruction { source: "t0 <- a U8", opcode: Copy8, args: [Register(0x75), Register(0x75)], resolved: None }
16 75 75 
# 82964 Instruction { source: "t1 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x76), Constant8(0x0a=10)], resolved: None }
00 76 0a 
# 82967 Instruction { source: "if t0 >= t1 then 'print_dec8_if_true_0_1' else 'print_dec8_if_else_0_2'", opcode: Cmp8, args: [Register(0x76), Register(0x75)], resolved: None }
25 76 75 
# 8296a Instruction { source: "if t0 >= t1 then 'print_dec8_if_true_0_1' else 'print_dec8_if_else_0_2'", opcode: JcImm, args: [Label24(print_dec8_if_true_0_1)], resolved: None }
41 72 29 08 
# 8296e Instruction { source: "if t0 >= t1 then 'print_dec8_if_true_0_1' else 'print_dec8_if_else_0_2'", opcode: JmpImm, args: [Label24(print_dec8_if_else_0_2)], resolved: None }
40 c1 29 08 
# print_dec8_if_true_0_1
# 82972 Instruction { source: "t2 <- a U8", opcode: Copy8, args: [Register(0x75), Register(0x75)], resolved: None }
16 75 75 
# 82975 Instruction { source: "t3 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x76), Constant8(0x0a=10)], resolved: None }
00 76 0a 
# 82978 Instruction { source: "b <- t2 Divide t3", opcode: Divide8, args: [Register(0x75), Register(0x76), Register(0x76)], resolved: None }
27 75 76 76 
# 8297c Instruction { source: "t5 <- b U8", opcode: Copy8, args: [Register(0x76), Register(0x76)], resolved: None }
16 76 76 
# 8297f Instruction { source: "Arg0[a]=t5 None <= call print_dec8(t5,)", opcode: Copy8, args: [Register(0x76), Register(0x00)], resolved: None }
16 76 00 
# Registers used by this function: {117, 118, 119}
# Registers used by callee tree: {117, 118, 119}
# Registers to save: [117, 118, 119]
# 82982 Instruction { source: "Saving reg0x77 before None <= call print_dec8(t5,)", opcode: Push8, args: [Register(0x77)], resolved: None }
14 77 
# 82984 Instruction { source: "Saving reg0x76 before None <= call print_dec8(t5,)", opcode: Push8, args: [Register(0x76)], resolved: None }
14 76 
# 82986 Instruction { source: "Saving reg0x75 before None <= call print_dec8(t5,)", opcode: Push8, args: [Register(0x75)], resolved: None }
14 75 
# 82988 Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8298e Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 98 29 08 00 
# 82994 Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: JmpImm, args: [Label24(:print_dec8)], resolved: None }
40 5e 29 08 
# 82998 Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8299e Instruction { source: "Restoring reg0x75 after None <= call print_dec8(t5,)", opcode: Pop8, args: [Register(0x75)], resolved: None }
15 75 
# 829a0 Instruction { source: "Restoring reg0x76 after None <= call print_dec8(t5,)", opcode: Pop8, args: [Register(0x76)], resolved: None }
15 76 
# 829a2 Instruction { source: "Restoring reg0x77 after None <= call print_dec8(t5,)", opcode: Pop8, args: [Register(0x77)], resolved: None }
15 77 
# 829a4 Instruction { source: "t6 <- a U8", opcode: Copy8, args: [Register(0x75), Register(0x75)], resolved: None }
16 75 75 
# 829a7 Instruction { source: "t8 <- b U8", opcode: Copy8, args: [Register(0x76), Register(0x76)], resolved: None }
16 76 76 
# 829aa Instruction { source: "t9 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x77), Constant8(0x0a=10)], resolved: None }
00 77 0a 
# 829ad Instruction { source: "t7 <- t8 Multiply t9", opcode: Mul8_1, args: [Register(0x76), Register(0x77)], resolved: None }
20 76 77 
# 829b0 Instruction { source: "t7 <- t8 Multiply t9", opcode: Mul8_2, args: [], resolved: None }
21 
# 829b1 Instruction { source: "t7 <- t8 Multiply t9", opcode: Copy8, args: [Register(0x00), Register(0x76)], resolved: None }
16 00 76 
# 829b4 Instruction { source: "a <- t6 Subtract t7", opcode: Copy8, args: [Register(0x76), Register(0x00)], resolved: None }
16 76 00 
# 829b7 Instruction { source: "a <- t6 Subtract t7", opcode: Negate8, args: [Register(0x00)], resolved: None }
04 00 
# 829b9 Instruction { source: "a <- t6 Subtract t7", opcode: Add8NoCarryIn, args: [Register(0x75), Register(0x00), Register(0x75)], resolved: None }
24 75 00 75 
# 829bd Instruction { source: "goto print_dec8_if_end_0", opcode: JmpImm, args: [Label24(print_dec8_if_end_0)], resolved: None }
40 c1 29 08 
# print_dec8_if_else_0_2
# print_dec8_if_end_0
# 829c1 Instruction { source: "t11 <- a U8", opcode: Copy8, args: [Register(0x75), Register(0x75)], resolved: None }
16 75 75 
# 829c4 Instruction { source: "t12 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x76), Constant8(0x30=48)], resolved: None }
00 76 30 
# 829c7 Instruction { source: "t10 <- t11 Add t12", opcode: Add8NoCarryIn, args: [Register(0x75), Register(0x76), Register(0x75)], resolved: None }
24 75 76 75 
# 829cb Instruction { source: "ttyout <- t10", opcode: TtyOut, args: [Register(0x75)], resolved: None }
13 75 
# 829cd Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 829cf Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :print_dec8_test
# Ret Some(U8)
# Arg0=a
# Arg1=b
# Var a (Arg0 a Number(U8)) U8 Some([120])
# Var b (Arg1 b Number(U8)) U8 Some([121])
# Var t0 (t0 Call(Call { function: "print_dec8", parameters: [Ident("a")] })) U8 Some([120])
# Var t1 (t1 Ident("a")) U8 Some([120])
# Var t2 (t2 Number(U8, 0)) U8 Some([120])
# 829d4 Instruction { source: "Save function parameter 'a' registers [0] to locals [120].", opcode: Copy8, args: [Register(0x00), Register(0x78)], resolved: None }
16 00 78 
# 829d7 Instruction { source: "Save function parameter 'b' registers [4] to locals [121].", opcode: Copy8, args: [Register(0x04), Register(0x79)], resolved: None }
16 04 79 
# 829da Instruction { source: "t1 <- a U8", opcode: Copy8, args: [Register(0x78), Register(0x78)], resolved: None }
16 78 78 
# 829dd Instruction { source: "Arg0[a]=t1 None <= call print_dec8(t1,)", opcode: Copy8, args: [Register(0x78), Register(0x00)], resolved: None }
16 78 00 
# Registers used by this function: {120, 121}
# Registers used by callee tree: {117, 118, 119}
# Registers to save: []
# 829e0 Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 829e6 Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c f0 29 08 00 
# 829ec Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: JmpImm, args: [Label24(:print_dec8)], resolved: None }
40 5e 29 08 
# 829f0 Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 829f6 Instruction { source: "t2 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x78), Constant8(0x00=0)], resolved: None }
00 78 00 
# 829f9 Instruction { source: "return Some(t2)", opcode: Copy8, args: [Register(0x78), Register(0x00)], resolved: None }
16 78 00 
# 829fc Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 829fe Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :print_digit
# Ret None
# Arg0=a
# Var a (Arg0 a Number(U8)) U8 Some([122])
# Var t0 (t0 Ident("a")) U8 Some([122])
# Var t1 (t1 Number(U8, 10)) U8 Some([123])
# Var t2 (t2 Arithmetic(Add, Ident("a"), Number(U8, 48))) U8 Some([122])
# Var t3 (t3 Ident("a")) U8 Some([122])
# Var t4 (t4 Number(U8, 48)) U8 Some([123])
# Var t5 (t5 Ident("a")) U8 Some([122])
# Var t6 (t6 Number(U8, 10)) U8 Some([123])
# Var t7 (t7 Ident("a")) U8 Some([122])
# Var t8 (t8 Number(U8, 65)) U8 Some([123])
# Var t9 (t9 Ident("a")) U8 Some([122])
# 82a03 Instruction { source: "Save function parameter 'a' registers [0] to locals [122].", opcode: Copy8, args: [Register(0x00), Register(0x7a)], resolved: None }
16 00 7a 
# 82a06 Instruction { source: "t0 <- a U8", opcode: Copy8, args: [Register(0x7a), Register(0x7a)], resolved: None }
16 7a 7a 
# 82a09 Instruction { source: "t1 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x7b), Constant8(0x0a=10)], resolved: None }
00 7b 0a 
# 82a0c Instruction { source: "if t0 < t1 then 'print_digit_if_true_0_1' else 'print_digit_if_else_0_2'", opcode: Cmp8, args: [Register(0x7b), Register(0x7a)], resolved: None }
25 7b 7a 
# 82a0f Instruction { source: "if t0 < t1 then 'print_digit_if_true_0_1' else 'print_digit_if_else_0_2'", opcode: JcImm, args: [Label24(print_digit_if_else_0_2)], resolved: None }
41 23 2a 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t0 < t1 then 'print_digit_if_true_0_1' else 'print_digit_if_else_0_2'", opcode: JmpImm, args: [Label24(print_digit_if_true_0_1)], resolved: None }
# print_digit_if_true_0_1
# 82a13 Instruction { source: "t3 <- a U8", opcode: Copy8, args: [Register(0x7a), Register(0x7a)], resolved: None }
16 7a 7a 
# 82a16 Instruction { source: "t4 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x7b), Constant8(0x30=48)], resolved: None }
00 7b 30 
# 82a19 Instruction { source: "t2 <- t3 Add t4", opcode: Add8NoCarryIn, args: [Register(0x7a), Register(0x7b), Register(0x7a)], resolved: None }
24 7a 7b 7a 
# 82a1d Instruction { source: "ttyout <- t2", opcode: TtyOut, args: [Register(0x7a)], resolved: None }
13 7a 
# 82a1f Instruction { source: "goto print_digit_if_end_0", opcode: JmpImm, args: [Label24(print_digit_if_end_0)], resolved: None }
40 41 2a 08 
# print_digit_if_else_0_2
# 82a23 Instruction { source: "t5 <- a U8", opcode: Copy8, args: [Register(0x7a), Register(0x7a)], resolved: None }
16 7a 7a 
# 82a26 Instruction { source: "t6 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x7b), Constant8(0x0a=10)], resolved: None }
00 7b 0a 
# 82a29 Instruction { source: "a <- t5 Subtract t6", opcode: Copy8, args: [Register(0x7b), Register(0x00)], resolved: None }
16 7b 00 
# 82a2c Instruction { source: "a <- t5 Subtract t6", opcode: Negate8, args: [Register(0x00)], resolved: None }
04 00 
# 82a2e Instruction { source: "a <- t5 Subtract t6", opcode: Add8NoCarryIn, args: [Register(0x7a), Register(0x00), Register(0x7a)], resolved: None }
24 7a 00 7a 
# 82a32 Instruction { source: "t7 <- a U8", opcode: Copy8, args: [Register(0x7a), Register(0x7a)], resolved: None }
16 7a 7a 
# 82a35 Instruction { source: "t8 <- 0n65/0x41u8 ", opcode: LoadImm8, args: [Register(0x7b), Constant8(0x41=65)], resolved: None }
00 7b 41 
# 82a38 Instruction { source: "a <- t7 Add t8", opcode: Add8NoCarryIn, args: [Register(0x7a), Register(0x7b), Register(0x7a)], resolved: None }
24 7a 7b 7a 
# 82a3c Instruction { source: "t9 <- a U8", opcode: Copy8, args: [Register(0x7a), Register(0x7a)], resolved: None }
16 7a 7a 
# 82a3f Instruction { source: "ttyout <- t9", opcode: TtyOut, args: [Register(0x7a)], resolved: None }
13 7a 
# print_digit_if_end_0
# 82a41 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82a43 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :println
# Ret None
# Arg0=buf
# Var buf (Arg0 buf Ptr(Number(U8))) U32 Some([124, 125, 126, 127])
# Var ch (Local ch Number(U8) U8) U8 Some([128])
# Var t0 (t0 Ident("buf")) U32 Some([124, 125, 126, 127])
# Var t1 (t1 Ident("ch")) U8 Some([128])
# Var t2 (t2 Number(U8, 0)) U8 Some([129])
# Var t3 (t3 Ident("ch")) U8 Some([128])
# Var t4 (t4 Ident("buf")) U32 Some([124, 125, 126, 127])
# Var t5 (t5 Number(USIZE, 1)) U32 Some([132, 133, 134, 135])
# Var t6 (t6 Ident("buf")) U32 Some([124, 125, 126, 127])
# 82a48 Instruction { source: "Save function parameter 'buf' registers [0, 1, 2, 3] to locals [124, 125, 126, 127].", opcode: Copy32, args: [Register(0x00), Register(0x7c)], resolved: None }
81 00 7c 
# 82a4b Instruction { source: "t0 <- buf U32", opcode: Copy32, args: [Register(0x7c), Register(0x7c)], resolved: None }
81 7c 7c 
# 82a4e Instruction { source: "ch <- mem[t0] U8", opcode: Load8, args: [Register(0x7c), Register(0x80)], resolved: None }
10 7c 80 
# println_while_predicate_0
# 82a51 Instruction { source: "t1 <- ch U8", opcode: Copy8, args: [Register(0x80), Register(0x80)], resolved: None }
16 80 80 
# 82a54 Instruction { source: "t2 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x81), Constant8(0x00=0)], resolved: None }
00 81 00 
# 82a57 Instruction { source: "if t1 != t2 then 'println_while_body_1' else 'println_while_end_2'", opcode: Cmp8, args: [Register(0x80), Register(0x81)], resolved: None }
25 80 81 
# 82a5a Instruction { source: "if t1 != t2 then 'println_while_body_1' else 'println_while_end_2'", opcode: JzImm, args: [Label24(println_while_end_2)], resolved: None }
42 7a 2a 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t1 != t2 then 'println_while_body_1' else 'println_while_end_2'", opcode: JmpImm, args: [Label24(println_while_body_1)], resolved: None }
# println_while_body_1
# 82a5e Instruction { source: "t3 <- ch U8", opcode: Copy8, args: [Register(0x80), Register(0x80)], resolved: None }
16 80 80 
# 82a61 Instruction { source: "ttyout <- t3", opcode: TtyOut, args: [Register(0x80)], resolved: None }
13 80 
# 82a63 Instruction { source: "t4 <- buf U32", opcode: Copy32, args: [Register(0x7c), Register(0x7c)], resolved: None }
81 7c 7c 
# 82a66 Instruction { source: "t5 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x84), Constant32(0x00000001=1)], resolved: None }
80 84 01 00 00 00 
# 82a6c Instruction { source: "buf <- t4 Add t5", opcode: Add32NoCarryIn, args: [Register(0x7c), Register(0x84), Register(0x7c)], resolved: None }
a0 7c 84 7c 
# 82a70 Instruction { source: "t6 <- buf U32", opcode: Copy32, args: [Register(0x7c), Register(0x7c)], resolved: None }
81 7c 7c 
# 82a73 Instruction { source: "ch <- mem[t6] U8", opcode: Load8, args: [Register(0x7c), Register(0x80)], resolved: None }
10 7c 80 
# 82a76 Instruction { source: "goto println_while_predicate_0", opcode: JmpImm, args: [Label24(println_while_predicate_0)], resolved: None }
40 51 2a 08 
# println_while_end_2
# 82a7a Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82a7c Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :readline
# Ret None
# Arg0=buf
# Var buf (Arg0 buf Ptr(Number(U8))) U32 Some([136, 137, 138, 139])
# Var ch (Local ch Number(U8) U8) U8 Some([140])
# Var t0 (t0 Number(U8, 0)) U8 Some([140])
# Var t1 (t1 Number(U8, 0)) U8 Some([141])
# Var t10 (t10 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Number(U8))), new_type: Number(USIZE), value: Ident("buf") }, Number(USIZE, 1)) }) U32 Some([136, 137, 138, 139])
# Var t11 (t11 Cast { old_type: Some(Ptr(Number(U8))), new_type: Number(USIZE), value: Ident("buf") }) U32 Some([136, 137, 138, 139])
# Var t12 (t12 Number(USIZE, 1)) U32 Some([144, 145, 146, 147])
# Var t2 (t2 Ident("ch")) U8 Some([140])
# Var t3 (t3 Number(U8, 13)) U8 Some([141])
# Var t4 (t4 Ident("ch")) U8 Some([140])
# Var t5 (t5 Number(U8, 10)) U8 Some([141])
# Var t6 (t6 Ident("buf")) U32 Some([136, 137, 138, 139])
# Var t7 (t7 Number(U8, 0)) U8 Some([140])
# Var t8 (t8 Ident("buf")) U32 Some([136, 137, 138, 139])
# Var t9 (t9 Ident("ch")) U8 Some([140])
# 82a81 Instruction { source: "Save function parameter 'buf' registers [0, 1, 2, 3] to locals [136, 137, 138, 139].", opcode: Copy32, args: [Register(0x00), Register(0x88)], resolved: None }
81 00 88 
# readline_while_predicate_0
# 82a84 Instruction { source: "t0 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x8c), Constant8(0x00=0)], resolved: None }
00 8c 00 
# 82a87 Instruction { source: "t1 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x8d), Constant8(0x00=0)], resolved: None }
00 8d 00 
# 82a8a Instruction { source: "if t0 == t1 then 'readline_while_body_1' else 'readline_while_end_2'", opcode: Cmp8, args: [Register(0x8c), Register(0x8d)], resolved: None }
25 8c 8d 
# 82a8d Instruction { source: "if t0 == t1 then 'readline_while_body_1' else 'readline_while_end_2'", opcode: JzImm, args: [Label24(readline_while_body_1)], resolved: None }
42 95 2a 08 
# 82a91 Instruction { source: "if t0 == t1 then 'readline_while_body_1' else 'readline_while_end_2'", opcode: JmpImm, args: [Label24(readline_while_end_2)], resolved: None }
40 00 2b 08 
# readline_while_body_1
# Registers used by this function: {136, 137, 138, 139, 140, 141, 144, 145, 146, 147}
# Registers used by callee tree: {192, 193, 194}
# Registers to save: []
# 82a95 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82a9b Instruction { source: "PseudoCall(Label24(:getchar))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c a5 2a 08 00 
# 82aa1 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: JmpImm, args: [Label24(:getchar)], resolved: None }
40 f9 22 08 
# 82aa5 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82aab Instruction { source: "Some(ch) <= call getchar()", opcode: Copy8, args: [Register(0x00), Register(0x8c)], resolved: None }
16 00 8c 
# 82aae Instruction { source: "t2 <- ch U8", opcode: Copy8, args: [Register(0x8c), Register(0x8c)], resolved: None }
16 8c 8c 
# 82ab1 Instruction { source: "t3 <- 0n13/0x0du8 ", opcode: LoadImm8, args: [Register(0x8d), Constant8(0x0d=13)], resolved: None }
00 8d 0d 
# 82ab4 Instruction { source: "if t2 == t3 then 'readline_if_true_0_4' else 'readline_if_else_0_5'", opcode: Cmp8, args: [Register(0x8c), Register(0x8d)], resolved: None }
25 8c 8d 
# 82ab7 Instruction { source: "if t2 == t3 then 'readline_if_true_0_4' else 'readline_if_else_0_5'", opcode: JzImm, args: [Label24(readline_if_true_0_4)], resolved: None }
42 bf 2a 08 
# 82abb Instruction { source: "if t2 == t3 then 'readline_if_true_0_4' else 'readline_if_else_0_5'", opcode: JmpImm, args: [Label24(readline_if_else_0_5)], resolved: None }
40 c3 2a 08 
# readline_if_true_0_4
# 82abf Instruction { source: "goto readline_if_end_3", opcode: JmpImm, args: [Label24(readline_if_end_3)], resolved: None }
40 fc 2a 08 
# readline_if_else_0_5
# 82ac3 Instruction { source: "t4 <- ch U8", opcode: Copy8, args: [Register(0x8c), Register(0x8c)], resolved: None }
16 8c 8c 
# 82ac6 Instruction { source: "t5 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x8d), Constant8(0x0a=10)], resolved: None }
00 8d 0a 
# 82ac9 Instruction { source: "if t4 == t5 then 'readline_if_true_1_6' else 'readline_if_else_1_7'", opcode: Cmp8, args: [Register(0x8c), Register(0x8d)], resolved: None }
25 8c 8d 
# 82acc Instruction { source: "if t4 == t5 then 'readline_if_true_1_6' else 'readline_if_else_1_7'", opcode: JzImm, args: [Label24(readline_if_true_1_6)], resolved: None }
42 d4 2a 08 
# 82ad0 Instruction { source: "if t4 == t5 then 'readline_if_true_1_6' else 'readline_if_else_1_7'", opcode: JmpImm, args: [Label24(readline_if_else_1_7)], resolved: None }
40 e3 2a 08 
# readline_if_true_1_6
# 82ad4 Instruction { source: "t6 <- buf U32", opcode: Copy32, args: [Register(0x88), Register(0x88)], resolved: None }
81 88 88 
# 82ad7 Instruction { source: "t7 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x8c), Constant8(0x00=0)], resolved: None }
00 8c 00 
# 82ada Instruction { source: "mem[t6] <- t7 U8", opcode: Store8, args: [Register(0x8c), Register(0x88)], resolved: None }
11 8c 88 
# 82add Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82adf Instruction { source: "goto readline_if_end_3", opcode: JmpImm, args: [Label24(readline_if_end_3)], resolved: None }
40 fc 2a 08 
# readline_if_else_1_7
# 82ae3 Instruction { source: "t8 <- buf U32", opcode: Copy32, args: [Register(0x88), Register(0x88)], resolved: None }
81 88 88 
# 82ae6 Instruction { source: "t9 <- ch U8", opcode: Copy8, args: [Register(0x8c), Register(0x8c)], resolved: None }
16 8c 8c 
# 82ae9 Instruction { source: "mem[t8] <- t9 U8", opcode: Store8, args: [Register(0x8c), Register(0x88)], resolved: None }
11 8c 88 
# 82aec Instruction { source: "t11 <- buf U32", opcode: Copy32, args: [Register(0x88), Register(0x88)], resolved: None }
81 88 88 
# 82aef Instruction { source: "t12 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x90), Constant32(0x00000001=1)], resolved: None }
80 90 01 00 00 00 
# 82af5 Instruction { source: "t10 <- t11 Add t12", opcode: Add32NoCarryIn, args: [Register(0x88), Register(0x90), Register(0x88)], resolved: None }
a0 88 90 88 
# 82af9 Instruction { source: "buf <- t10 U32", opcode: Copy32, args: [Register(0x88), Register(0x88)], resolved: None }
81 88 88 
# readline_if_end_3
# 82afc Instruction { source: "goto readline_while_predicate_0", opcode: JmpImm, args: [Label24(readline_while_predicate_0)], resolved: None }
40 84 2a 08 
# readline_while_end_2
# 82b00 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82b02 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :shiftright1
# Ret Some(U32)
# Arg0=a
# Var a (Arg0 a Number(USIZE)) U32 Some([148, 149, 150, 151])
# Var t0 (t0 Arithmetic(RotateRight, Index("a", Number(U8, 0)), Number(U8, 1))) U8 Some([152])
# Var t1 (t1 Index("a", Number(U8, 0))) U8 Some([153])
# Var t10 (t10 Index("a", Number(U8, 3))) U8 Some([153])
# Var t11 (t11 Number(U8, 1)) U8 Some([152])
# Var t12 (t12 Arithmetic(And, Index("a", Number(U8, 0)), Number(U8, 127))) U8 Some([152])
# Var t13 (t13 Index("a", Number(U8, 0))) U8 Some([153])
# Var t14 (t14 Number(U8, 127)) U8 Some([152])
# Var t15 (t15 Arithmetic(Or, Index("a", Number(U8, 0)), Arithmetic(And, Index("a", Number(U8, 1)), Number(U8, 128)))) U8 Some([152])
# Var t16 (t16 Index("a", Number(U8, 0))) U8 Some([153])
# Var t17 (t17 Arithmetic(And, Index("a", Number(U8, 1)), Number(U8, 128))) U8 Some([152])
# Var t18 (t18 Index("a", Number(U8, 1))) U8 Some([152])
# Var t19 (t19 Number(U8, 128)) U8 Some([154])
# Var t2 (t2 Number(U8, 1)) U8 Some([152])
# Var t20 (t20 Arithmetic(And, Index("a", Number(U8, 1)), Number(U8, 127))) U8 Some([152])
# Var t21 (t21 Index("a", Number(U8, 1))) U8 Some([153])
# Var t22 (t22 Number(U8, 127)) U8 Some([152])
# Var t23 (t23 Arithmetic(Or, Index("a", Number(U8, 1)), Arithmetic(And, Index("a", Number(U8, 2)), Number(U8, 128)))) U8 Some([152])
# Var t24 (t24 Index("a", Number(U8, 1))) U8 Some([153])
# Var t25 (t25 Arithmetic(And, Index("a", Number(U8, 2)), Number(U8, 128))) U8 Some([152])
# Var t26 (t26 Index("a", Number(U8, 2))) U8 Some([152])
# Var t27 (t27 Number(U8, 128)) U8 Some([154])
# Var t28 (t28 Arithmetic(And, Index("a", Number(U8, 2)), Number(U8, 127))) U8 Some([152])
# Var t29 (t29 Index("a", Number(U8, 2))) U8 Some([153])
# Var t3 (t3 Arithmetic(RotateRight, Index("a", Number(U8, 1)), Number(U8, 1))) U8 Some([152])
# Var t30 (t30 Number(U8, 127)) U8 Some([152])
# Var t31 (t31 Arithmetic(Or, Index("a", Number(U8, 2)), Arithmetic(And, Index("a", Number(U8, 3)), Number(U8, 128)))) U8 Some([152])
# Var t32 (t32 Index("a", Number(U8, 2))) U8 Some([153])
# Var t33 (t33 Arithmetic(And, Index("a", Number(U8, 3)), Number(U8, 128))) U8 Some([152])
# Var t34 (t34 Index("a", Number(U8, 3))) U8 Some([152])
# Var t35 (t35 Number(U8, 128)) U8 Some([154])
# Var t36 (t36 Arithmetic(And, Index("a", Number(U8, 3)), Number(U8, 127))) U8 Some([152])
# Var t37 (t37 Index("a", Number(U8, 3))) U8 Some([153])
# Var t38 (t38 Number(U8, 127)) U8 Some([152])
# Var t39 (t39 Ident("a")) U32 Some([148, 149, 150, 151])
# Var t4 (t4 Index("a", Number(U8, 1))) U8 Some([153])
# Var t5 (t5 Number(U8, 1)) U8 Some([152])
# Var t6 (t6 Arithmetic(RotateRight, Index("a", Number(U8, 2)), Number(U8, 1))) U8 Some([152])
# Var t7 (t7 Index("a", Number(U8, 2))) U8 Some([153])
# Var t8 (t8 Number(U8, 1)) U8 Some([152])
# Var t9 (t9 Arithmetic(RotateRight, Index("a", Number(U8, 3)), Number(U8, 1))) U8 Some([152])
# 82b07 Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [148, 149, 150, 151].", opcode: Copy32, args: [Register(0x00), Register(0x94)], resolved: None }
81 00 94 
# 82b0a Instruction { source: "t1 <- a[0x00..0x01] U8", opcode: Copy8, args: [Register(0x94), Register(0x99)], resolved: None }
16 94 99 
# 82b0d Instruction { source: "t2 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x98), Constant8(0x01=1)], resolved: None }
00 98 01 
# 82b10 Instruction { source: "t0 <- t1 RotateRight t2", opcode: Shift8, args: [Constant8(0x04=4), Register(0x98), Register(0x99), Register(0x98)], resolved: None }
36 04 98 99 98 
# 82b15 Instruction { source: "a[0x00..0x01] <- t0 U8", opcode: Copy8, args: [Register(0x98), Register(0x94)], resolved: None }
16 98 94 
# 82b18 Instruction { source: "t4 <- a[0x01..0x02] U8", opcode: Copy8, args: [Register(0x95), Register(0x99)], resolved: None }
16 95 99 
# 82b1b Instruction { source: "t5 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x98), Constant8(0x01=1)], resolved: None }
00 98 01 
# 82b1e Instruction { source: "t3 <- t4 RotateRight t5", opcode: Shift8, args: [Constant8(0x04=4), Register(0x98), Register(0x99), Register(0x98)], resolved: None }
36 04 98 99 98 
# 82b23 Instruction { source: "a[0x01..0x02] <- t3 U8", opcode: Copy8, args: [Register(0x98), Register(0x95)], resolved: None }
16 98 95 
# 82b26 Instruction { source: "t7 <- a[0x02..0x03] U8", opcode: Copy8, args: [Register(0x96), Register(0x99)], resolved: None }
16 96 99 
# 82b29 Instruction { source: "t8 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x98), Constant8(0x01=1)], resolved: None }
00 98 01 
# 82b2c Instruction { source: "t6 <- t7 RotateRight t8", opcode: Shift8, args: [Constant8(0x04=4), Register(0x98), Register(0x99), Register(0x98)], resolved: None }
36 04 98 99 98 
# 82b31 Instruction { source: "a[0x02..0x03] <- t6 U8", opcode: Copy8, args: [Register(0x98), Register(0x96)], resolved: None }
16 98 96 
# 82b34 Instruction { source: "t10 <- a[0x03..0x04] U8", opcode: Copy8, args: [Register(0x97), Register(0x99)], resolved: None }
16 97 99 
# 82b37 Instruction { source: "t11 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x98), Constant8(0x01=1)], resolved: None }
00 98 01 
# 82b3a Instruction { source: "t9 <- t10 RotateRight t11", opcode: Shift8, args: [Constant8(0x04=4), Register(0x98), Register(0x99), Register(0x98)], resolved: None }
36 04 98 99 98 
# 82b3f Instruction { source: "a[0x03..0x04] <- t9 U8", opcode: Copy8, args: [Register(0x98), Register(0x97)], resolved: None }
16 98 97 
# 82b42 Instruction { source: "t13 <- a[0x00..0x01] U8", opcode: Copy8, args: [Register(0x94), Register(0x99)], resolved: None }
16 94 99 
# 82b45 Instruction { source: "t14 <- 0n127/0x7fu8 ", opcode: LoadImm8, args: [Register(0x98), Constant8(0x7f=127)], resolved: None }
00 98 7f 
# 82b48 Instruction { source: "t12 <- t13 BitwiseAnd t14", opcode: And8, args: [Register(0x99), Register(0x98), Register(0x98)], resolved: None }
33 99 98 98 
# 82b4c Instruction { source: "a[0x00..0x01] <- t12 U8", opcode: Copy8, args: [Register(0x98), Register(0x94)], resolved: None }
16 98 94 
# 82b4f Instruction { source: "t16 <- a[0x00..0x01] U8", opcode: Copy8, args: [Register(0x94), Register(0x99)], resolved: None }
16 94 99 
# 82b52 Instruction { source: "t18 <- a[0x01..0x02] U8", opcode: Copy8, args: [Register(0x95), Register(0x98)], resolved: None }
16 95 98 
# 82b55 Instruction { source: "t19 <- 0n128/0x80u8 ", opcode: LoadImm8, args: [Register(0x9a), Constant8(0x80=128)], resolved: None }
00 9a 80 
# 82b58 Instruction { source: "t17 <- t18 BitwiseAnd t19", opcode: And8, args: [Register(0x98), Register(0x9a), Register(0x98)], resolved: None }
33 98 9a 98 
# 82b5c Instruction { source: "t15 <- t16 BitwiseOr t17", opcode: Or8, args: [Register(0x99), Register(0x98), Register(0x98)], resolved: None }
34 99 98 98 
# 82b60 Instruction { source: "a[0x00..0x01] <- t15 U8", opcode: Copy8, args: [Register(0x98), Register(0x94)], resolved: None }
16 98 94 
# 82b63 Instruction { source: "t21 <- a[0x01..0x02] U8", opcode: Copy8, args: [Register(0x95), Register(0x99)], resolved: None }
16 95 99 
# 82b66 Instruction { source: "t22 <- 0n127/0x7fu8 ", opcode: LoadImm8, args: [Register(0x98), Constant8(0x7f=127)], resolved: None }
00 98 7f 
# 82b69 Instruction { source: "t20 <- t21 BitwiseAnd t22", opcode: And8, args: [Register(0x99), Register(0x98), Register(0x98)], resolved: None }
33 99 98 98 
# 82b6d Instruction { source: "a[0x01..0x02] <- t20 U8", opcode: Copy8, args: [Register(0x98), Register(0x95)], resolved: None }
16 98 95 
# 82b70 Instruction { source: "t24 <- a[0x01..0x02] U8", opcode: Copy8, args: [Register(0x95), Register(0x99)], resolved: None }
16 95 99 
# 82b73 Instruction { source: "t26 <- a[0x02..0x03] U8", opcode: Copy8, args: [Register(0x96), Register(0x98)], resolved: None }
16 96 98 
# 82b76 Instruction { source: "t27 <- 0n128/0x80u8 ", opcode: LoadImm8, args: [Register(0x9a), Constant8(0x80=128)], resolved: None }
00 9a 80 
# 82b79 Instruction { source: "t25 <- t26 BitwiseAnd t27", opcode: And8, args: [Register(0x98), Register(0x9a), Register(0x98)], resolved: None }
33 98 9a 98 
# 82b7d Instruction { source: "t23 <- t24 BitwiseOr t25", opcode: Or8, args: [Register(0x99), Register(0x98), Register(0x98)], resolved: None }
34 99 98 98 
# 82b81 Instruction { source: "a[0x01..0x02] <- t23 U8", opcode: Copy8, args: [Register(0x98), Register(0x95)], resolved: None }
16 98 95 
# 82b84 Instruction { source: "t29 <- a[0x02..0x03] U8", opcode: Copy8, args: [Register(0x96), Register(0x99)], resolved: None }
16 96 99 
# 82b87 Instruction { source: "t30 <- 0n127/0x7fu8 ", opcode: LoadImm8, args: [Register(0x98), Constant8(0x7f=127)], resolved: None }
00 98 7f 
# 82b8a Instruction { source: "t28 <- t29 BitwiseAnd t30", opcode: And8, args: [Register(0x99), Register(0x98), Register(0x98)], resolved: None }
33 99 98 98 
# 82b8e Instruction { source: "a[0x02..0x03] <- t28 U8", opcode: Copy8, args: [Register(0x98), Register(0x96)], resolved: None }
16 98 96 
# 82b91 Instruction { source: "t32 <- a[0x02..0x03] U8", opcode: Copy8, args: [Register(0x96), Register(0x99)], resolved: None }
16 96 99 
# 82b94 Instruction { source: "t34 <- a[0x03..0x04] U8", opcode: Copy8, args: [Register(0x97), Register(0x98)], resolved: None }
16 97 98 
# 82b97 Instruction { source: "t35 <- 0n128/0x80u8 ", opcode: LoadImm8, args: [Register(0x9a), Constant8(0x80=128)], resolved: None }
00 9a 80 
# 82b9a Instruction { source: "t33 <- t34 BitwiseAnd t35", opcode: And8, args: [Register(0x98), Register(0x9a), Register(0x98)], resolved: None }
33 98 9a 98 
# 82b9e Instruction { source: "t31 <- t32 BitwiseOr t33", opcode: Or8, args: [Register(0x99), Register(0x98), Register(0x98)], resolved: None }
34 99 98 98 
# 82ba2 Instruction { source: "a[0x02..0x03] <- t31 U8", opcode: Copy8, args: [Register(0x98), Register(0x96)], resolved: None }
16 98 96 
# 82ba5 Instruction { source: "t37 <- a[0x03..0x04] U8", opcode: Copy8, args: [Register(0x97), Register(0x99)], resolved: None }
16 97 99 
# 82ba8 Instruction { source: "t38 <- 0n127/0x7fu8 ", opcode: LoadImm8, args: [Register(0x98), Constant8(0x7f=127)], resolved: None }
00 98 7f 
# 82bab Instruction { source: "t36 <- t37 BitwiseAnd t38", opcode: And8, args: [Register(0x99), Register(0x98), Register(0x98)], resolved: None }
33 99 98 98 
# 82baf Instruction { source: "a[0x03..0x04] <- t36 U8", opcode: Copy8, args: [Register(0x98), Register(0x97)], resolved: None }
16 98 97 
# 82bb2 Instruction { source: "t39 <- a U32", opcode: Copy32, args: [Register(0x94), Register(0x94)], resolved: None }
81 94 94 
# 82bb5 Instruction { source: "return Some(t39)", opcode: Copy32, args: [Register(0x94), Register(0x00)], resolved: None }
81 94 00 
# 82bb8 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82bba Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :shiftright3
# Ret Some(U32)
# Arg0=a
# Var a (Arg0 a Number(USIZE)) U32 Some([156, 157, 158, 159])
# Var t0 (t0 Arithmetic(RotateRight, Index("a", Number(U8, 0)), Number(U8, 3))) U8 Some([160])
# Var t1 (t1 Index("a", Number(U8, 0))) U8 Some([161])
# Var t10 (t10 Index("a", Number(U8, 3))) U8 Some([161])
# Var t11 (t11 Number(U8, 3)) U8 Some([160])
# Var t12 (t12 Arithmetic(And, Index("a", Number(U8, 0)), Number(U8, 31))) U8 Some([160])
# Var t13 (t13 Index("a", Number(U8, 0))) U8 Some([161])
# Var t14 (t14 Number(U8, 31)) U8 Some([160])
# Var t15 (t15 Arithmetic(Or, Index("a", Number(U8, 0)), Arithmetic(And, Index("a", Number(U8, 1)), Number(U8, 224)))) U8 Some([160])
# Var t16 (t16 Index("a", Number(U8, 0))) U8 Some([161])
# Var t17 (t17 Arithmetic(And, Index("a", Number(U8, 1)), Number(U8, 224))) U8 Some([160])
# Var t18 (t18 Index("a", Number(U8, 1))) U8 Some([160])
# Var t19 (t19 Number(U8, 224)) U8 Some([162])
# Var t2 (t2 Number(U8, 3)) U8 Some([160])
# Var t20 (t20 Arithmetic(And, Index("a", Number(U8, 1)), Number(U8, 31))) U8 Some([160])
# Var t21 (t21 Index("a", Number(U8, 1))) U8 Some([161])
# Var t22 (t22 Number(U8, 31)) U8 Some([160])
# Var t23 (t23 Arithmetic(Or, Index("a", Number(U8, 1)), Arithmetic(And, Index("a", Number(U8, 2)), Number(U8, 224)))) U8 Some([160])
# Var t24 (t24 Index("a", Number(U8, 1))) U8 Some([161])
# Var t25 (t25 Arithmetic(And, Index("a", Number(U8, 2)), Number(U8, 224))) U8 Some([160])
# Var t26 (t26 Index("a", Number(U8, 2))) U8 Some([160])
# Var t27 (t27 Number(U8, 224)) U8 Some([162])
# Var t28 (t28 Arithmetic(And, Index("a", Number(U8, 2)), Number(U8, 31))) U8 Some([160])
# Var t29 (t29 Index("a", Number(U8, 2))) U8 Some([161])
# Var t3 (t3 Arithmetic(RotateRight, Index("a", Number(U8, 1)), Number(U8, 3))) U8 Some([160])
# Var t30 (t30 Number(U8, 31)) U8 Some([160])
# Var t31 (t31 Arithmetic(Or, Index("a", Number(U8, 2)), Arithmetic(And, Index("a", Number(U8, 3)), Number(U8, 224)))) U8 Some([160])
# Var t32 (t32 Index("a", Number(U8, 2))) U8 Some([161])
# Var t33 (t33 Arithmetic(And, Index("a", Number(U8, 3)), Number(U8, 224))) U8 Some([160])
# Var t34 (t34 Index("a", Number(U8, 3))) U8 Some([160])
# Var t35 (t35 Number(U8, 224)) U8 Some([162])
# Var t36 (t36 Arithmetic(And, Index("a", Number(U8, 3)), Number(U8, 31))) U8 Some([160])
# Var t37 (t37 Index("a", Number(U8, 3))) U8 Some([161])
# Var t38 (t38 Number(U8, 31)) U8 Some([160])
# Var t39 (t39 Ident("a")) U32 Some([156, 157, 158, 159])
# Var t4 (t4 Index("a", Number(U8, 1))) U8 Some([161])
# Var t5 (t5 Number(U8, 3)) U8 Some([160])
# Var t6 (t6 Arithmetic(RotateRight, Index("a", Number(U8, 2)), Number(U8, 3))) U8 Some([160])
# Var t7 (t7 Index("a", Number(U8, 2))) U8 Some([161])
# Var t8 (t8 Number(U8, 3)) U8 Some([160])
# Var t9 (t9 Arithmetic(RotateRight, Index("a", Number(U8, 3)), Number(U8, 3))) U8 Some([160])
# 82bbf Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [156, 157, 158, 159].", opcode: Copy32, args: [Register(0x00), Register(0x9c)], resolved: None }
81 00 9c 
# 82bc2 Instruction { source: "t1 <- a[0x00..0x01] U8", opcode: Copy8, args: [Register(0x9c), Register(0xa1)], resolved: None }
16 9c a1 
# 82bc5 Instruction { source: "t2 <- 0n3/0x03u8 ", opcode: LoadImm8, args: [Register(0xa0), Constant8(0x03=3)], resolved: None }
00 a0 03 
# 82bc8 Instruction { source: "t0 <- t1 RotateRight t2", opcode: Shift8, args: [Constant8(0x04=4), Register(0xa0), Register(0xa1), Register(0xa0)], resolved: None }
36 04 a0 a1 a0 
# 82bcd Instruction { source: "a[0x00..0x01] <- t0 U8", opcode: Copy8, args: [Register(0xa0), Register(0x9c)], resolved: None }
16 a0 9c 
# 82bd0 Instruction { source: "t4 <- a[0x01..0x02] U8", opcode: Copy8, args: [Register(0x9d), Register(0xa1)], resolved: None }
16 9d a1 
# 82bd3 Instruction { source: "t5 <- 0n3/0x03u8 ", opcode: LoadImm8, args: [Register(0xa0), Constant8(0x03=3)], resolved: None }
00 a0 03 
# 82bd6 Instruction { source: "t3 <- t4 RotateRight t5", opcode: Shift8, args: [Constant8(0x04=4), Register(0xa0), Register(0xa1), Register(0xa0)], resolved: None }
36 04 a0 a1 a0 
# 82bdb Instruction { source: "a[0x01..0x02] <- t3 U8", opcode: Copy8, args: [Register(0xa0), Register(0x9d)], resolved: None }
16 a0 9d 
# 82bde Instruction { source: "t7 <- a[0x02..0x03] U8", opcode: Copy8, args: [Register(0x9e), Register(0xa1)], resolved: None }
16 9e a1 
# 82be1 Instruction { source: "t8 <- 0n3/0x03u8 ", opcode: LoadImm8, args: [Register(0xa0), Constant8(0x03=3)], resolved: None }
00 a0 03 
# 82be4 Instruction { source: "t6 <- t7 RotateRight t8", opcode: Shift8, args: [Constant8(0x04=4), Register(0xa0), Register(0xa1), Register(0xa0)], resolved: None }
36 04 a0 a1 a0 
# 82be9 Instruction { source: "a[0x02..0x03] <- t6 U8", opcode: Copy8, args: [Register(0xa0), Register(0x9e)], resolved: None }
16 a0 9e 
# 82bec Instruction { source: "t10 <- a[0x03..0x04] U8", opcode: Copy8, args: [Register(0x9f), Register(0xa1)], resolved: None }
16 9f a1 
# 82bef Instruction { source: "t11 <- 0n3/0x03u8 ", opcode: LoadImm8, args: [Register(0xa0), Constant8(0x03=3)], resolved: None }
00 a0 03 
# 82bf2 Instruction { source: "t9 <- t10 RotateRight t11", opcode: Shift8, args: [Constant8(0x04=4), Register(0xa0), Register(0xa1), Register(0xa0)], resolved: None }
36 04 a0 a1 a0 
# 82bf7 Instruction { source: "a[0x03..0x04] <- t9 U8", opcode: Copy8, args: [Register(0xa0), Register(0x9f)], resolved: None }
16 a0 9f 
# 82bfa Instruction { source: "t13 <- a[0x00..0x01] U8", opcode: Copy8, args: [Register(0x9c), Register(0xa1)], resolved: None }
16 9c a1 
# 82bfd Instruction { source: "t14 <- 0n31/0x1fu8 ", opcode: LoadImm8, args: [Register(0xa0), Constant8(0x1f=31)], resolved: None }
00 a0 1f 
# 82c00 Instruction { source: "t12 <- t13 BitwiseAnd t14", opcode: And8, args: [Register(0xa1), Register(0xa0), Register(0xa0)], resolved: None }
33 a1 a0 a0 
# 82c04 Instruction { source: "a[0x00..0x01] <- t12 U8", opcode: Copy8, args: [Register(0xa0), Register(0x9c)], resolved: None }
16 a0 9c 
# 82c07 Instruction { source: "t16 <- a[0x00..0x01] U8", opcode: Copy8, args: [Register(0x9c), Register(0xa1)], resolved: None }
16 9c a1 
# 82c0a Instruction { source: "t18 <- a[0x01..0x02] U8", opcode: Copy8, args: [Register(0x9d), Register(0xa0)], resolved: None }
16 9d a0 
# 82c0d Instruction { source: "t19 <- 0n224/0xe0u8 ", opcode: LoadImm8, args: [Register(0xa2), Constant8(0xe0=224)], resolved: None }
00 a2 e0 
# 82c10 Instruction { source: "t17 <- t18 BitwiseAnd t19", opcode: And8, args: [Register(0xa0), Register(0xa2), Register(0xa0)], resolved: None }
33 a0 a2 a0 
# 82c14 Instruction { source: "t15 <- t16 BitwiseOr t17", opcode: Or8, args: [Register(0xa1), Register(0xa0), Register(0xa0)], resolved: None }
34 a1 a0 a0 
# 82c18 Instruction { source: "a[0x00..0x01] <- t15 U8", opcode: Copy8, args: [Register(0xa0), Register(0x9c)], resolved: None }
16 a0 9c 
# 82c1b Instruction { source: "t21 <- a[0x01..0x02] U8", opcode: Copy8, args: [Register(0x9d), Register(0xa1)], resolved: None }
16 9d a1 
# 82c1e Instruction { source: "t22 <- 0n31/0x1fu8 ", opcode: LoadImm8, args: [Register(0xa0), Constant8(0x1f=31)], resolved: None }
00 a0 1f 
# 82c21 Instruction { source: "t20 <- t21 BitwiseAnd t22", opcode: And8, args: [Register(0xa1), Register(0xa0), Register(0xa0)], resolved: None }
33 a1 a0 a0 
# 82c25 Instruction { source: "a[0x01..0x02] <- t20 U8", opcode: Copy8, args: [Register(0xa0), Register(0x9d)], resolved: None }
16 a0 9d 
# 82c28 Instruction { source: "t24 <- a[0x01..0x02] U8", opcode: Copy8, args: [Register(0x9d), Register(0xa1)], resolved: None }
16 9d a1 
# 82c2b Instruction { source: "t26 <- a[0x02..0x03] U8", opcode: Copy8, args: [Register(0x9e), Register(0xa0)], resolved: None }
16 9e a0 
# 82c2e Instruction { source: "t27 <- 0n224/0xe0u8 ", opcode: LoadImm8, args: [Register(0xa2), Constant8(0xe0=224)], resolved: None }
00 a2 e0 
# 82c31 Instruction { source: "t25 <- t26 BitwiseAnd t27", opcode: And8, args: [Register(0xa0), Register(0xa2), Register(0xa0)], resolved: None }
33 a0 a2 a0 
# 82c35 Instruction { source: "t23 <- t24 BitwiseOr t25", opcode: Or8, args: [Register(0xa1), Register(0xa0), Register(0xa0)], resolved: None }
34 a1 a0 a0 
# 82c39 Instruction { source: "a[0x01..0x02] <- t23 U8", opcode: Copy8, args: [Register(0xa0), Register(0x9d)], resolved: None }
16 a0 9d 
# 82c3c Instruction { source: "t29 <- a[0x02..0x03] U8", opcode: Copy8, args: [Register(0x9e), Register(0xa1)], resolved: None }
16 9e a1 
# 82c3f Instruction { source: "t30 <- 0n31/0x1fu8 ", opcode: LoadImm8, args: [Register(0xa0), Constant8(0x1f=31)], resolved: None }
00 a0 1f 
# 82c42 Instruction { source: "t28 <- t29 BitwiseAnd t30", opcode: And8, args: [Register(0xa1), Register(0xa0), Register(0xa0)], resolved: None }
33 a1 a0 a0 
# 82c46 Instruction { source: "a[0x02..0x03] <- t28 U8", opcode: Copy8, args: [Register(0xa0), Register(0x9e)], resolved: None }
16 a0 9e 
# 82c49 Instruction { source: "t32 <- a[0x02..0x03] U8", opcode: Copy8, args: [Register(0x9e), Register(0xa1)], resolved: None }
16 9e a1 
# 82c4c Instruction { source: "t34 <- a[0x03..0x04] U8", opcode: Copy8, args: [Register(0x9f), Register(0xa0)], resolved: None }
16 9f a0 
# 82c4f Instruction { source: "t35 <- 0n224/0xe0u8 ", opcode: LoadImm8, args: [Register(0xa2), Constant8(0xe0=224)], resolved: None }
00 a2 e0 
# 82c52 Instruction { source: "t33 <- t34 BitwiseAnd t35", opcode: And8, args: [Register(0xa0), Register(0xa2), Register(0xa0)], resolved: None }
33 a0 a2 a0 
# 82c56 Instruction { source: "t31 <- t32 BitwiseOr t33", opcode: Or8, args: [Register(0xa1), Register(0xa0), Register(0xa0)], resolved: None }
34 a1 a0 a0 
# 82c5a Instruction { source: "a[0x02..0x03] <- t31 U8", opcode: Copy8, args: [Register(0xa0), Register(0x9e)], resolved: None }
16 a0 9e 
# 82c5d Instruction { source: "t37 <- a[0x03..0x04] U8", opcode: Copy8, args: [Register(0x9f), Register(0xa1)], resolved: None }
16 9f a1 
# 82c60 Instruction { source: "t38 <- 0n31/0x1fu8 ", opcode: LoadImm8, args: [Register(0xa0), Constant8(0x1f=31)], resolved: None }
00 a0 1f 
# 82c63 Instruction { source: "t36 <- t37 BitwiseAnd t38", opcode: And8, args: [Register(0xa1), Register(0xa0), Register(0xa0)], resolved: None }
33 a1 a0 a0 
# 82c67 Instruction { source: "a[0x03..0x04] <- t36 U8", opcode: Copy8, args: [Register(0xa0), Register(0x9f)], resolved: None }
16 a0 9f 
# 82c6a Instruction { source: "t39 <- a U32", opcode: Copy32, args: [Register(0x9c), Register(0x9c)], resolved: None }
81 9c 9c 
# 82c6d Instruction { source: "return Some(t39)", opcode: Copy32, args: [Register(0x9c), Register(0x00)], resolved: None }
81 9c 00 
# 82c70 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82c72 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :stack_get
# Ret Some(U32)
# Arg0=s
# Arg1=n
# Var n (Arg1 n Number(USIZE)) U32 Some([164, 165, 166, 167])
# Var s (Arg0 s Ptr(Struct("Stack"))) U32 Some([168, 169, 170, 171])
# Var t0 (t0 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Array(Number(USIZE), 16)), value: Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") } }) U32 Some([168, 169, 170, 171])
# Var t1 (t1 Index("values", Ident("n"))) U32 Some([164, 165, 166, 167])
# Var t2 (t2 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Number(USIZE))), new_type: Number(USIZE), value: Ident("values") }, Arithmetic(Multiply, Ident("n"), Number(USIZE, 4))) }) U32 Some([164, 165, 166, 167])
# Var t3 (t3 Cast { old_type: Some(Ptr(Number(USIZE))), new_type: Number(USIZE), value: Ident("values") }) U32 Some([168, 169, 170, 171])
# Var t4 (t4 Arithmetic(Multiply, Ident("n"), Number(USIZE, 4))) U32 Some([164, 165, 166, 167])
# Var t5 (t5 Ident("n")) U32 Some([164, 165, 166, 167])
# Var t6 (t6 Number(USIZE, 4)) U32 Some([172, 173, 174, 175])
# Var values (Local values Ptr(Number(USIZE)) U32) U32 Some([168, 169, 170, 171])
# 82c77 Instruction { source: "Save function parameter 's' registers [0, 1, 2, 3] to locals [168, 169, 170, 171].", opcode: Copy32, args: [Register(0x00), Register(0xa8)], resolved: None }
81 00 a8 
# 82c7a Instruction { source: "Save function parameter 'n' registers [4, 5, 6, 7] to locals [164, 165, 166, 167].", opcode: Copy32, args: [Register(0x04), Register(0xa4)], resolved: None }
81 04 a4 
# 82c7d Instruction { source: "t0 <- s U32", opcode: Copy32, args: [Register(0xa8), Register(0xa8)], resolved: None }
81 a8 a8 
# 82c80 Instruction { source: "values <- t0 U32", opcode: Copy32, args: [Register(0xa8), Register(0xa8)], resolved: None }
81 a8 a8 
# 82c83 Instruction { source: "t3 <- values U32", opcode: Copy32, args: [Register(0xa8), Register(0xa8)], resolved: None }
81 a8 a8 
# 82c86 Instruction { source: "t5 <- n U32", opcode: Copy32, args: [Register(0xa4), Register(0xa4)], resolved: None }
81 a4 a4 
# 82c89 Instruction { source: "t6 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0xac), Constant32(0x00000004=4)], resolved: None }
80 ac 04 00 00 00 
# 82c8f Instruction { source: "t4 <- t5 Multiply t6", opcode: LoadImm32, args: [Register(0x00), Constant32(0x00000000=0)], resolved: None }
80 00 00 00 00 00 
# 82c95 Instruction { source: "t4 <- t5 Multiply t6", opcode: Mul8_1, args: [Register(0xa4), Register(0xac)], resolved: None }
20 a4 ac 
# 82c98 Instruction { source: "t4 <- t5 Multiply t6", opcode: Mul8_2, args: [], resolved: None }
21 
# 82c99 Instruction { source: "t4 <- t5 Multiply t6", opcode: Copy32, args: [Register(0x00), Register(0xa4)], resolved: None }
81 00 a4 
# 82c9c Instruction { source: "t2 <- t3 Add t4", opcode: Add32NoCarryIn, args: [Register(0xa8), Register(0xa4), Register(0xa4)], resolved: None }
a0 a8 a4 a4 
# 82ca0 Instruction { source: "t1 <- mem[t2] U32", opcode: Load32, args: [Register(0xa4), Register(0xa4)], resolved: None }
90 a4 a4 
# 82ca3 Instruction { source: "return Some(t1)", opcode: Copy32, args: [Register(0xa4), Register(0x00)], resolved: None }
81 a4 00 
# 82ca6 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82ca8 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :stack_init
# Ret None
# Arg0=s
# Var s (Arg0 s Ptr(Struct("Stack"))) U32 Some([176, 177, 178, 179])
# Var t0 (t0 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 64)) }) U32 Some([176, 177, 178, 179])
# Var t1 (t1 Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }) U32 Some([176, 177, 178, 179])
# Var t2 (t2 Number(USIZE, 64)) U32 Some([180, 181, 182, 183])
# Var t3 (t3 Number(USIZE, 0)) U32 Some([180, 181, 182, 183])
# 82cad Instruction { source: "Save function parameter 's' registers [0, 1, 2, 3] to locals [176, 177, 178, 179].", opcode: Copy32, args: [Register(0x00), Register(0xb0)], resolved: None }
81 00 b0 
# 82cb0 Instruction { source: "t1 <- s U32", opcode: Copy32, args: [Register(0xb0), Register(0xb0)], resolved: None }
81 b0 b0 
# 82cb3 Instruction { source: "t2 <- 0n64/0x00000040u32 ", opcode: LoadImm32, args: [Register(0xb4), Constant32(0x00000040=64)], resolved: None }
80 b4 40 00 00 00 
# 82cb9 Instruction { source: "t0 <- t1 Add t2", opcode: Add32NoCarryIn, args: [Register(0xb0), Register(0xb4), Register(0xb0)], resolved: None }
a0 b0 b4 b0 
# 82cbd Instruction { source: "t3 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0xb4), Constant32(0x00000000=0)], resolved: None }
80 b4 00 00 00 00 
# 82cc3 Instruction { source: "mem[t0] <- t3 U32", opcode: Store32_1, args: [Register(0xb4), Register(0xb0)], resolved: None }
92 b4 b0 
# 82cc6 Instruction { source: "mem[t0] <- t3 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 82cc7 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82cc9 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :stack_pop
# Ret Some(U32)
# Arg0=s
# Var s (Arg0 s Ptr(Struct("Stack"))) U32 Some([184, 185, 186, 187])
# Var t0 (t0 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 64)) }) U32 Some([188, 189, 190, 191])
# Var t1 (t1 Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }) U32 Some([184, 185, 186, 187])
# Var t10 (t10 Index("values", PtrFieldDeref("s", "first_free"))) U32 Some([184, 185, 186, 187])
# Var t11 (t11 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Number(USIZE))), new_type: Number(USIZE), value: Ident("values") }, Arithmetic(Multiply, PtrFieldDeref("s", "first_free"), Number(USIZE, 4))) }) U32 Some([184, 185, 186, 187])
# Var t12 (t12 Cast { old_type: Some(Ptr(Number(USIZE))), new_type: Number(USIZE), value: Ident("values") }) U32 Some([188, 189, 190, 191])
# Var t13 (t13 Arithmetic(Multiply, PtrFieldDeref("s", "first_free"), Number(USIZE, 4))) U32 Some([184, 185, 186, 187])
# Var t14 (t14 PtrFieldDeref("s", "first_free")) U32 Some([184, 185, 186, 187])
# Var t15 (t15 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 64)) }) U32 Some([184, 185, 186, 187])
# Var t16 (t16 Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }) U32 Some([184, 185, 186, 187])
# Var t17 (t17 Number(USIZE, 64)) U32 Some([192, 193, 194, 195])
# Var t18 (t18 Number(USIZE, 4)) U32 Some([192, 193, 194, 195])
# Var t2 (t2 Number(USIZE, 64)) U32 Some([188, 189, 190, 191])
# Var t3 (t3 Arithmetic(Subtract, PtrFieldDeref("s", "first_free"), Number(U8, 1))) U32 Some([192, 193, 194, 195])
# Var t4 (t4 PtrFieldDeref("s", "first_free")) U32 Some([192, 193, 194, 195])
# Var t5 (t5 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 64)) }) U32 Some([192, 193, 194, 195])
# Var t6 (t6 Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }) U32 Some([184, 185, 186, 187])
# Var t7 (t7 Number(USIZE, 64)) U32 Some([192, 193, 194, 195])
# Var t8 (t8 Number(USIZE, 1)) U32 Some([196, 197, 198, 199])
# Var t9 (t9 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Array(Number(USIZE), 16)), value: Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") } }) U32 Some([184, 185, 186, 187])
# Var values (Local values Ptr(Number(USIZE)) U32) U32 Some([188, 189, 190, 191])
# 82cce Instruction { source: "Save function parameter 's' registers [0, 1, 2, 3] to locals [184, 185, 186, 187].", opcode: Copy32, args: [Register(0x00), Register(0xb8)], resolved: None }
81 00 b8 
# 82cd1 Instruction { source: "t1 <- s U32", opcode: Copy32, args: [Register(0xb8), Register(0xb8)], resolved: None }
81 b8 b8 
# 82cd4 Instruction { source: "t2 <- 0n64/0x00000040u32 ", opcode: LoadImm32, args: [Register(0xbc), Constant32(0x00000040=64)], resolved: None }
80 bc 40 00 00 00 
# 82cda Instruction { source: "t0 <- t1 Add t2", opcode: Add32NoCarryIn, args: [Register(0xb8), Register(0xbc), Register(0xbc)], resolved: None }
a0 b8 bc bc 
# 82cde Instruction { source: "t6 <- s U32", opcode: Copy32, args: [Register(0xb8), Register(0xb8)], resolved: None }
81 b8 b8 
# 82ce1 Instruction { source: "t7 <- 0n64/0x00000040u32 ", opcode: LoadImm32, args: [Register(0xc0), Constant32(0x00000040=64)], resolved: None }
80 c0 40 00 00 00 
# 82ce7 Instruction { source: "t5 <- t6 Add t7", opcode: Add32NoCarryIn, args: [Register(0xb8), Register(0xc0), Register(0xc0)], resolved: None }
a0 b8 c0 c0 
# 82ceb Instruction { source: "t4 <- mem[t5] U32", opcode: Load32, args: [Register(0xc0), Register(0xc0)], resolved: None }
90 c0 c0 
# 82cee Instruction { source: "t8 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0xc4), Constant32(0x00000001=1)], resolved: None }
80 c4 01 00 00 00 
# 82cf4 Instruction { source: "t3 <- t4 Subtract t8", opcode: Copy32, args: [Register(0xc4), Register(0x00)], resolved: None }
81 c4 00 
# 82cf7 Instruction { source: "t3 <- t4 Subtract t8", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 82cf9 Instruction { source: "t3 <- t4 Subtract t8", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 82cfb Instruction { source: "t3 <- t4 Subtract t8", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 82cfd Instruction { source: "t3 <- t4 Subtract t8", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 82cff Instruction { source: "t3 <- t4 Subtract t8", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 82d05 Instruction { source: "t3 <- t4 Subtract t8", opcode: Add32NoCarryIn, args: [Register(0xc0), Register(0x00), Register(0xc0)], resolved: None }
a0 c0 00 c0 
# 82d09 Instruction { source: "mem[t0] <- t3 U32", opcode: Store32_1, args: [Register(0xc0), Register(0xbc)], resolved: None }
92 c0 bc 
# 82d0c Instruction { source: "mem[t0] <- t3 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 82d0d Instruction { source: "t9 <- s U32", opcode: Copy32, args: [Register(0xb8), Register(0xb8)], resolved: None }
81 b8 b8 
# 82d10 Instruction { source: "values <- t9 U32", opcode: Copy32, args: [Register(0xb8), Register(0xbc)], resolved: None }
81 b8 bc 
# 82d13 Instruction { source: "t12 <- values U32", opcode: Copy32, args: [Register(0xbc), Register(0xbc)], resolved: None }
81 bc bc 
# 82d16 Instruction { source: "t16 <- s U32", opcode: Copy32, args: [Register(0xb8), Register(0xb8)], resolved: None }
81 b8 b8 
# 82d19 Instruction { source: "t17 <- 0n64/0x00000040u32 ", opcode: LoadImm32, args: [Register(0xc0), Constant32(0x00000040=64)], resolved: None }
80 c0 40 00 00 00 
# 82d1f Instruction { source: "t15 <- t16 Add t17", opcode: Add32NoCarryIn, args: [Register(0xb8), Register(0xc0), Register(0xb8)], resolved: None }
a0 b8 c0 b8 
# 82d23 Instruction { source: "t14 <- mem[t15] U32", opcode: Load32, args: [Register(0xb8), Register(0xb8)], resolved: None }
90 b8 b8 
# 82d26 Instruction { source: "t18 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0xc0), Constant32(0x00000004=4)], resolved: None }
80 c0 04 00 00 00 
# 82d2c Instruction { source: "t13 <- t14 Multiply t18", opcode: LoadImm32, args: [Register(0x00), Constant32(0x00000000=0)], resolved: None }
80 00 00 00 00 00 
# 82d32 Instruction { source: "t13 <- t14 Multiply t18", opcode: Mul8_1, args: [Register(0xb8), Register(0xc0)], resolved: None }
20 b8 c0 
# 82d35 Instruction { source: "t13 <- t14 Multiply t18", opcode: Mul8_2, args: [], resolved: None }
21 
# 82d36 Instruction { source: "t13 <- t14 Multiply t18", opcode: Copy32, args: [Register(0x00), Register(0xb8)], resolved: None }
81 00 b8 
# 82d39 Instruction { source: "t11 <- t12 Add t13", opcode: Add32NoCarryIn, args: [Register(0xbc), Register(0xb8), Register(0xb8)], resolved: None }
a0 bc b8 b8 
# 82d3d Instruction { source: "t10 <- mem[t11] U32", opcode: Load32, args: [Register(0xb8), Register(0xb8)], resolved: None }
90 b8 b8 
# 82d40 Instruction { source: "return Some(t10)", opcode: Copy32, args: [Register(0xb8), Register(0x00)], resolved: None }
81 b8 00 
# 82d43 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82d45 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :stack_push
# Ret None
# Arg0=s
# Arg1=n
# Var n (Arg1 n Number(USIZE)) U32 Some([200, 201, 202, 203])
# Var s (Arg0 s Ptr(Struct("Stack"))) U32 Some([204, 205, 206, 207])
# Var t0 (t0 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Array(Number(USIZE), 16)), value: Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") } }) U32 Some([204, 205, 206, 207])
# Var t1 (t1 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Number(USIZE))), new_type: Number(USIZE), value: Ident("values") }, Arithmetic(Multiply, PtrFieldDeref("s", "first_free"), Number(USIZE, 4))) }) U32 Some([208, 209, 210, 211])
# Var t10 (t10 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 64)) }) U32 Some([200, 201, 202, 203])
# Var t11 (t11 Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }) U32 Some([200, 201, 202, 203])
# Var t12 (t12 Number(USIZE, 64)) U32 Some([208, 209, 210, 211])
# Var t13 (t13 Arithmetic(Add, PtrFieldDeref("s", "first_free"), Number(U8, 1))) U32 Some([204, 205, 206, 207])
# Var t14 (t14 PtrFieldDeref("s", "first_free")) U32 Some([204, 205, 206, 207])
# Var t15 (t15 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 64)) }) U32 Some([204, 205, 206, 207])
# Var t16 (t16 Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }) U32 Some([204, 205, 206, 207])
# Var t17 (t17 Number(USIZE, 64)) U32 Some([208, 209, 210, 211])
# Var t18 (t18 Number(USIZE, 1)) U32 Some([208, 209, 210, 211])
# Var t2 (t2 Cast { old_type: Some(Ptr(Number(USIZE))), new_type: Number(USIZE), value: Ident("values") }) U32 Some([208, 209, 210, 211])
# Var t3 (t3 Arithmetic(Multiply, PtrFieldDeref("s", "first_free"), Number(USIZE, 4))) U32 Some([212, 213, 214, 215])
# Var t4 (t4 PtrFieldDeref("s", "first_free")) U32 Some([212, 213, 214, 215])
# Var t5 (t5 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 64)) }) U32 Some([212, 213, 214, 215])
# Var t6 (t6 Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }) U32 Some([204, 205, 206, 207])
# Var t7 (t7 Number(USIZE, 64)) U32 Some([212, 213, 214, 215])
# Var t8 (t8 Number(USIZE, 4)) U32 Some([216, 217, 218, 219])
# Var t9 (t9 Ident("n")) U32 Some([200, 201, 202, 203])
# Var values (Local values Ptr(Number(USIZE)) U32) U32 Some([208, 209, 210, 211])
# 82d4a Instruction { source: "Save function parameter 's' registers [0, 1, 2, 3] to locals [204, 205, 206, 207].", opcode: Copy32, args: [Register(0x00), Register(0xcc)], resolved: None }
81 00 cc 
# 82d4d Instruction { source: "Save function parameter 'n' registers [4, 5, 6, 7] to locals [200, 201, 202, 203].", opcode: Copy32, args: [Register(0x04), Register(0xc8)], resolved: None }
81 04 c8 
# 82d50 Instruction { source: "t0 <- s U32", opcode: Copy32, args: [Register(0xcc), Register(0xcc)], resolved: None }
81 cc cc 
# 82d53 Instruction { source: "values <- t0 U32", opcode: Copy32, args: [Register(0xcc), Register(0xd0)], resolved: None }
81 cc d0 
# 82d56 Instruction { source: "t2 <- values U32", opcode: Copy32, args: [Register(0xd0), Register(0xd0)], resolved: None }
81 d0 d0 
# 82d59 Instruction { source: "t6 <- s U32", opcode: Copy32, args: [Register(0xcc), Register(0xcc)], resolved: None }
81 cc cc 
# 82d5c Instruction { source: "t7 <- 0n64/0x00000040u32 ", opcode: LoadImm32, args: [Register(0xd4), Constant32(0x00000040=64)], resolved: None }
80 d4 40 00 00 00 
# 82d62 Instruction { source: "t5 <- t6 Add t7", opcode: Add32NoCarryIn, args: [Register(0xcc), Register(0xd4), Register(0xd4)], resolved: None }
a0 cc d4 d4 
# 82d66 Instruction { source: "t4 <- mem[t5] U32", opcode: Load32, args: [Register(0xd4), Register(0xd4)], resolved: None }
90 d4 d4 
# 82d69 Instruction { source: "t8 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0xd8), Constant32(0x00000004=4)], resolved: None }
80 d8 04 00 00 00 
# 82d6f Instruction { source: "t3 <- t4 Multiply t8", opcode: LoadImm32, args: [Register(0x00), Constant32(0x00000000=0)], resolved: None }
80 00 00 00 00 00 
# 82d75 Instruction { source: "t3 <- t4 Multiply t8", opcode: Mul8_1, args: [Register(0xd4), Register(0xd8)], resolved: None }
20 d4 d8 
# 82d78 Instruction { source: "t3 <- t4 Multiply t8", opcode: Mul8_2, args: [], resolved: None }
21 
# 82d79 Instruction { source: "t3 <- t4 Multiply t8", opcode: Copy32, args: [Register(0x00), Register(0xd4)], resolved: None }
81 00 d4 
# 82d7c Instruction { source: "t1 <- t2 Add t3", opcode: Add32NoCarryIn, args: [Register(0xd0), Register(0xd4), Register(0xd0)], resolved: None }
a0 d0 d4 d0 
# 82d80 Instruction { source: "t9 <- n U32", opcode: Copy32, args: [Register(0xc8), Register(0xc8)], resolved: None }
81 c8 c8 
# 82d83 Instruction { source: "mem[t1] <- t9 U32", opcode: Store32_1, args: [Register(0xc8), Register(0xd0)], resolved: None }
92 c8 d0 
# 82d86 Instruction { source: "mem[t1] <- t9 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 82d87 Instruction { source: "t11 <- s U32", opcode: Copy32, args: [Register(0xcc), Register(0xc8)], resolved: None }
81 cc c8 
# 82d8a Instruction { source: "t12 <- 0n64/0x00000040u32 ", opcode: LoadImm32, args: [Register(0xd0), Constant32(0x00000040=64)], resolved: None }
80 d0 40 00 00 00 
# 82d90 Instruction { source: "t10 <- t11 Add t12", opcode: Add32NoCarryIn, args: [Register(0xc8), Register(0xd0), Register(0xc8)], resolved: None }
a0 c8 d0 c8 
# 82d94 Instruction { source: "t16 <- s U32", opcode: Copy32, args: [Register(0xcc), Register(0xcc)], resolved: None }
81 cc cc 
# 82d97 Instruction { source: "t17 <- 0n64/0x00000040u32 ", opcode: LoadImm32, args: [Register(0xd0), Constant32(0x00000040=64)], resolved: None }
80 d0 40 00 00 00 
# 82d9d Instruction { source: "t15 <- t16 Add t17", opcode: Add32NoCarryIn, args: [Register(0xcc), Register(0xd0), Register(0xcc)], resolved: None }
a0 cc d0 cc 
# 82da1 Instruction { source: "t14 <- mem[t15] U32", opcode: Load32, args: [Register(0xcc), Register(0xcc)], resolved: None }
90 cc cc 
# 82da4 Instruction { source: "t18 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0xd0), Constant32(0x00000001=1)], resolved: None }
80 d0 01 00 00 00 
# 82daa Instruction { source: "t13 <- t14 Add t18", opcode: Add32NoCarryIn, args: [Register(0xcc), Register(0xd0), Register(0xcc)], resolved: None }
a0 cc d0 cc 
# 82dae Instruction { source: "mem[t10] <- t13 U32", opcode: Store32_1, args: [Register(0xcc), Register(0xc8)], resolved: None }
92 cc c8 
# 82db1 Instruction { source: "mem[t10] <- t13 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 82db2 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82db4 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :test_add_U64
# Ret Some(U32)
# Arg0=a
# Arg1=b
# Var a (Arg0 a Ptr(Struct("U64"))) U32 Some([220, 221, 222, 223])
# Var b (Arg1 b Ptr(Struct("U64"))) U32 Some([224, 225, 226, 227])
# Var c (Local c Struct("U64") Static(524552)) Static(524552) None
# Var t0 (t0 Call(Call { function: "add_U64", parameters: [Ident("a"), Ident("b"), AddressOf(Ident("c"))] })) U8 Some([228])
# Var t1 (t1 Ident("a")) U32 Some([220, 221, 222, 223])
# Var t2 (t2 Ident("b")) U32 Some([224, 225, 226, 227])
# Var t3 (t3 AddressOf(Ident("c"))) U32 Some([232, 233, 234, 235])
# Var t4 (static "c") U32 Some([232, 233, 234, 235])
# Var t5 (t5 AddressOf(Ident("c"))) U32 Some([220, 221, 222, 223])
# Var t6 (static "c") U32 Some([220, 221, 222, 223])
# 82db9 Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [220, 221, 222, 223].", opcode: Copy32, args: [Register(0x00), Register(0xdc)], resolved: None }
81 00 dc 
# 82dbc Instruction { source: "Save function parameter 'b' registers [4, 5, 6, 7] to locals [224, 225, 226, 227].", opcode: Copy32, args: [Register(0x04), Register(0xe0)], resolved: None }
81 04 e0 
# 82dbf Instruction { source: "t1 <- a U32", opcode: Copy32, args: [Register(0xdc), Register(0xdc)], resolved: None }
81 dc dc 
# 82dc2 Instruction { source: "t2 <- b U32", opcode: Copy32, args: [Register(0xe0), Register(0xe0)], resolved: None }
81 e0 e0 
# 82dc5 Instruction { source: "t4 <- 0n524552/0x00080108u32 ", opcode: LoadImm32, args: [Register(0xe8), Constant32(0x00080108=524552)], resolved: None }
80 e8 08 01 08 00 
# 82dcb Instruction { source: "t3 <- t4 U32", opcode: Copy32, args: [Register(0xe8), Register(0xe8)], resolved: None }
81 e8 e8 
# 82dce Instruction { source: "Arg0[a]=t1 None <= call add_U64(t1,t2,t3,)", opcode: Copy32, args: [Register(0xdc), Register(0x00)], resolved: None }
81 dc 00 
# 82dd1 Instruction { source: "Arg1[b]=t2 None <= call add_U64(t1,t2,t3,)", opcode: Copy32, args: [Register(0xe0), Register(0x04)], resolved: None }
81 e0 04 
# 82dd4 Instruction { source: "Arg2[c]=t3 None <= call add_U64(t1,t2,t3,)", opcode: Copy32, args: [Register(0xe8), Register(0x08)], resolved: None }
81 e8 08 
# Registers used by this function: {220, 221, 222, 223, 224, 225, 226, 227, 228, 232, 233, 234, 235}
# Registers used by callee tree: {80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107}
# Registers to save: []
# 82dd7 Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82ddd Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c e7 2d 08 00 
# 82de3 Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: JmpImm, args: [Label24(:add_U64)], resolved: None }
40 24 1d 08 
# 82de7 Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82ded Instruction { source: "t6 <- 0n524552/0x00080108u32 ", opcode: LoadImm32, args: [Register(0xdc), Constant32(0x00080108=524552)], resolved: None }
80 dc 08 01 08 00 
# 82df3 Instruction { source: "t5 <- t6 U32", opcode: Copy32, args: [Register(0xdc), Register(0xdc)], resolved: None }
81 dc dc 
# 82df6 Instruction { source: "return Some(t5)", opcode: Copy32, args: [Register(0xdc), Register(0x00)], resolved: None }
81 dc 00 
# 82df9 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82dfb Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :test_echoline
# Ret Some(U8)
# Var __frame_pointer (__frame_pointer) U32 Some([12, 13, 14, 15])
# Var buf (Local buf Array(Number(U8), 20) FrameOffset(0)) FrameOffset(0) None
# Var t0 (Stack size negated) U32 Some([236, 237, 238, 239])
# Var t1 (t1 Call(Call { function: "readline", parameters: [AddressOf(Index("buf", Number(U8, 0)))] })) U8 Some([240])
# Var t10 (t10 Ident("__frame_pointer")) U32 Some([244, 245, 246, 247])
# Var t11 (t11 Cast { old_type: Some(Number(U8)), new_type: Number(USIZE), value: Number(U8, 0) }) U32 Some([236, 237, 238, 239])
# Var t12 (t12 Number(U8, 0)) U8 Some([248])
# Var t13 (t13 Number(U8, 0)) U8 Some([248])
# Var t14 (Stack size) U32 Some([252, 253, 254, 255])
# Var t2 (t2 AddressOf(Index("buf", Number(U8, 0)))) U32 Some([236, 237, 238, 239])
# Var t3 (t3 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Ident("__frame_pointer"), Cast { old_type: Some(Number(U8)), new_type: Number(USIZE), value: Number(U8, 0) }) }) U32 Some([236, 237, 238, 239])
# Var t4 (t4 Ident("__frame_pointer")) U32 Some([244, 245, 246, 247])
# Var t5 (t5 Cast { old_type: Some(Number(U8)), new_type: Number(USIZE), value: Number(U8, 0) }) U32 Some([236, 237, 238, 239])
# Var t6 (t6 Number(U8, 0)) U8 Some([248])
# Var t7 (t7 Call(Call { function: "println", parameters: [AddressOf(Index("buf", Number(U8, 0)))] })) U8 Some([240])
# Var t8 (t8 AddressOf(Index("buf", Number(U8, 0)))) U32 Some([236, 237, 238, 239])
# Var t9 (t9 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Ident("__frame_pointer"), Cast { old_type: Some(Number(U8)), new_type: Number(USIZE), value: Number(U8, 0) }) }) U32 Some([236, 237, 238, 239])
# 82e00 Instruction { source: "reserve 20 bytes of stack space for locals", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xffffffec=4294967276)], resolved: None }
a3 0c ec ff ff ff 
# 82e06 Instruction { source: "t0 <- 0xffffffecu32 ", opcode: LoadImm32, args: [Register(0xec), Constant32(0xffffffec=4294967276)], resolved: None }
80 ec ec ff ff ff 
# 82e0c Instruction { source: "__frame_pointer <- __frame_pointer Add t0", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0xec), Register(0x0c)], resolved: None }
a0 0c ec 0c 
# 82e10 Instruction { source: "t4 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0xf4)], resolved: None }
81 0c f4 
# 82e13 Instruction { source: "t6 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xf8), Constant8(0x00=0)], resolved: None }
00 f8 00 
# 82e16 Instruction { source: "Zero-pad for t5 U32 <- t6 U8", opcode: LoadImm32, args: [Register(0xec), Constant32(0x00000000=0)], resolved: None }
80 ec 00 00 00 00 
# 82e1c Instruction { source: "t5 U32 <- t6 U8", opcode: Copy8, args: [Register(0xf8), Register(0xec)], resolved: None }
16 f8 ec 
# 82e1f Instruction { source: "t3 <- t4 Add t5", opcode: Add32NoCarryIn, args: [Register(0xf4), Register(0xec), Register(0xec)], resolved: None }
a0 f4 ec ec 
# 82e23 Instruction { source: "t2 <- t3 U32", opcode: Copy32, args: [Register(0xec), Register(0xec)], resolved: None }
81 ec ec 
# 82e26 Instruction { source: "Arg0[buf]=t2 None <= call readline(t2,)", opcode: Copy32, args: [Register(0xec), Register(0x00)], resolved: None }
81 ec 00 
# Registers used by this function: {236, 237, 238, 239, 240, 244, 245, 246, 247, 248, 252, 253, 254, 255}
# Registers used by callee tree: {136, 137, 138, 139, 140, 141, 144, 145, 146, 147, 192, 193, 194}
# Registers to save: []
# 82e29 Instruction { source: "PseudoCall(Label24(:readline))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82e2f Instruction { source: "PseudoCall(Label24(:readline))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 39 2e 08 00 
# 82e35 Instruction { source: "PseudoCall(Label24(:readline))", opcode: JmpImm, args: [Label24(:readline)], resolved: None }
40 81 2a 08 
# 82e39 Instruction { source: "PseudoCall(Label24(:readline))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82e3f Instruction { source: "t10 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0xf4)], resolved: None }
81 0c f4 
# 82e42 Instruction { source: "t12 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xf8), Constant8(0x00=0)], resolved: None }
00 f8 00 
# 82e45 Instruction { source: "Zero-pad for t11 U32 <- t12 U8", opcode: LoadImm32, args: [Register(0xec), Constant32(0x00000000=0)], resolved: None }
80 ec 00 00 00 00 
# 82e4b Instruction { source: "t11 U32 <- t12 U8", opcode: Copy8, args: [Register(0xf8), Register(0xec)], resolved: None }
16 f8 ec 
# 82e4e Instruction { source: "t9 <- t10 Add t11", opcode: Add32NoCarryIn, args: [Register(0xf4), Register(0xec), Register(0xec)], resolved: None }
a0 f4 ec ec 
# 82e52 Instruction { source: "t8 <- t9 U32", opcode: Copy32, args: [Register(0xec), Register(0xec)], resolved: None }
81 ec ec 
# 82e55 Instruction { source: "Arg0[buf]=t8 None <= call println(t8,)", opcode: Copy32, args: [Register(0xec), Register(0x00)], resolved: None }
81 ec 00 
# Registers used by this function: {236, 237, 238, 239, 240, 244, 245, 246, 247, 248, 252, 253, 254, 255}
# Registers used by callee tree: {124, 125, 126, 127, 128, 129, 132, 133, 134, 135}
# Registers to save: []
# 82e58 Instruction { source: "PseudoCall(Label24(:println))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82e5e Instruction { source: "PseudoCall(Label24(:println))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 68 2e 08 00 
# 82e64 Instruction { source: "PseudoCall(Label24(:println))", opcode: JmpImm, args: [Label24(:println)], resolved: None }
40 48 2a 08 
# 82e68 Instruction { source: "PseudoCall(Label24(:println))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82e6e Instruction { source: "t13 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xf8), Constant8(0x00=0)], resolved: None }
00 f8 00 
# 82e71 Instruction { source: "t14 <- 0n20/0x00000014u32 ", opcode: LoadImm32, args: [Register(0xfc), Constant32(0x00000014=20)], resolved: None }
80 fc 14 00 00 00 
# 82e77 Instruction { source: "__frame_pointer <- __frame_pointer Add t14", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0xfc), Register(0x0c)], resolved: None }
a0 0c fc 0c 
# 82e7b Instruction { source: "return Some(t13)", opcode: Copy8, args: [Register(0xf8), Register(0x00)], resolved: None }
16 f8 00 
# 82e7e Instruction { source: "Dealloc 20 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000014=20)], resolved: None }
a3 0c 14 00 00 00 
# 82e84 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82e86 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :test_mul32_64
# Ret Some(U32)
# Arg0=a
# Arg1=b
# Var a (Arg0 a Number(USIZE)) U32 Some([16, 17, 18, 19])
# Var b (Arg1 b Number(USIZE)) U32 Some([20, 21, 22, 23])
# Var c (Local c Struct("U64") Static(524560)) Static(524560) None
# Var t0 (t0 Call(Call { function: "mul32_64", parameters: [Ident("a"), Ident("b"), AddressOf(Ident("c"))] })) U8 Some([24])
# Var t1 (t1 Ident("a")) U32 Some([16, 17, 18, 19])
# Var t2 (t2 Ident("b")) U32 Some([20, 21, 22, 23])
# Var t3 (t3 AddressOf(Ident("c"))) U32 Some([28, 29, 30, 31])
# Var t4 (static "c") U32 Some([28, 29, 30, 31])
# Var t5 (t5 AddressOf(Ident("c"))) U32 Some([16, 17, 18, 19])
# Var t6 (static "c") U32 Some([16, 17, 18, 19])
# 82e8b Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [16, 17, 18, 19].", opcode: Copy32, args: [Register(0x00), Register(0x10)], resolved: None }
81 00 10 
# 82e8e Instruction { source: "Save function parameter 'b' registers [4, 5, 6, 7] to locals [20, 21, 22, 23].", opcode: Copy32, args: [Register(0x04), Register(0x14)], resolved: None }
81 04 14 
# 82e91 Instruction { source: "t1 <- a U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 82e94 Instruction { source: "t2 <- b U32", opcode: Copy32, args: [Register(0x14), Register(0x14)], resolved: None }
81 14 14 
# 82e97 Instruction { source: "t4 <- 0n524560/0x00080110u32 ", opcode: LoadImm32, args: [Register(0x1c), Constant32(0x00080110=524560)], resolved: None }
80 1c 10 01 08 00 
# 82e9d Instruction { source: "t3 <- t4 U32", opcode: Copy32, args: [Register(0x1c), Register(0x1c)], resolved: None }
81 1c 1c 
# 82ea0 Instruction { source: "Arg0[a]=t1 None <= call mul32_64(t1,t2,t3,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# 82ea3 Instruction { source: "Arg1[b]=t2 None <= call mul32_64(t1,t2,t3,)", opcode: Copy32, args: [Register(0x14), Register(0x04)], resolved: None }
81 14 04 
# 82ea6 Instruction { source: "Arg2[c]=t3 None <= call mul32_64(t1,t2,t3,)", opcode: Copy32, args: [Register(0x1c), Register(0x08)], resolved: None }
81 1c 08 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 28, 29, 30, 31}
# Registers used by callee tree: {28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 65, 68, 69, 70, 71, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 236, 237, 238, 239, 240, 241}
# Registers to save: [28, 29, 30, 31]
# 82ea9 Instruction { source: "Saving reg0x1f before None <= call mul32_64(t1,t2,t3,)", opcode: Push8, args: [Register(0x1f)], resolved: None }
14 1f 
# 82eab Instruction { source: "Saving reg0x1e before None <= call mul32_64(t1,t2,t3,)", opcode: Push8, args: [Register(0x1e)], resolved: None }
14 1e 
# 82ead Instruction { source: "Saving reg0x1d before None <= call mul32_64(t1,t2,t3,)", opcode: Push8, args: [Register(0x1d)], resolved: None }
14 1d 
# 82eaf Instruction { source: "Saving reg0x1c before None <= call mul32_64(t1,t2,t3,)", opcode: Push8, args: [Register(0x1c)], resolved: None }
14 1c 
# 82eb1 Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82eb7 Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c c1 2e 08 00 
# 82ebd Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: JmpImm, args: [Label24(:mul32_64)], resolved: None }
40 d9 25 08 
# 82ec1 Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82ec7 Instruction { source: "Restoring reg0x1c after None <= call mul32_64(t1,t2,t3,)", opcode: Pop8, args: [Register(0x1c)], resolved: None }
15 1c 
# 82ec9 Instruction { source: "Restoring reg0x1d after None <= call mul32_64(t1,t2,t3,)", opcode: Pop8, args: [Register(0x1d)], resolved: None }
15 1d 
# 82ecb Instruction { source: "Restoring reg0x1e after None <= call mul32_64(t1,t2,t3,)", opcode: Pop8, args: [Register(0x1e)], resolved: None }
15 1e 
# 82ecd Instruction { source: "Restoring reg0x1f after None <= call mul32_64(t1,t2,t3,)", opcode: Pop8, args: [Register(0x1f)], resolved: None }
15 1f 
# 82ecf Instruction { source: "t6 <- 0n524560/0x00080110u32 ", opcode: LoadImm32, args: [Register(0x10), Constant32(0x00080110=524560)], resolved: None }
80 10 10 01 08 00 
# 82ed5 Instruction { source: "t5 <- t6 U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 82ed8 Instruction { source: "return Some(t5)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# 82edb Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82edd Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
