v2.0 raw
# ImageBaseAddress=0x00081400
# entry
# 81400 Instruction { source: "Initialzing flags and internal regs.", opcode: Init, args: [], resolved: None }
0f 
# 81401 Instruction { source: "Initialzing stack register to 0x000ffffc.", opcode: LoadImm32, args: [Register(0x0c), Constant32(0x000ffffc=1048572)], resolved: None }
80 0c fc ff 0f 00 
# 81407 Instruction { source: "PseudoCall(Label24(:main))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8140d Instruction { source: "PseudoCall(Label24(:main))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 17 14 08 00 
# 81413 Instruction { source: "PseudoCall(Label24(:main))", opcode: JmpImm, args: [Label24(:main)], resolved: None }
40 47 22 08 
# 81417 Instruction { source: "PseudoCall(Label24(:main))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8141d Instruction { source: "Halting after return from entry function.", opcode: Halt, args: [Constant32(0x00000000=0)], resolved: None }
ff 00 00 00 00 
# :RpnCalc_handle
# Ret Some(U8)
# Arg0=c
# Arg1=ch
# Var a (Local a Number(USIZE) U32) U32 Some([16, 17, 18, 19])
# Var b (Local b Number(USIZE) U32) U32 Some([20, 21, 22, 23])
# Var c (Arg0 c Ptr(Struct("RpnCalc"))) U32 Some([24, 25, 26, 27])
# Var ch (Arg1 ch Number(U8)) U8 Some([28])
# Var diff (Local diff Number(USIZE) U32) U32 Some([16, 17, 18, 19])
# Var i (Local i Number(U8) U8) U8 Some([29])
# Var product (Local product Number(USIZE) U32) U32 Some([16, 17, 18, 19])
# Var quotient (Local quotient Number(USIZE) U32) U32 Some([16, 17, 18, 19])
# Var stack (Local stack Ptr(Struct("Stack")) U32) U32 Some([32, 33, 34, 35])
# Var stack_count (Local stack_count Number(U8) U8) U8 Some([36])
# Var stack_count_usize (Local stack_count_usize Number(USIZE) U32) U32 Some([40, 41, 42, 43])
# Var stack_needed (Local stack_needed Number(U8) U8) U8 Some([44])
# Var sum (Local sum Number(USIZE) U32) U32 Some([16, 17, 18, 19])
# Var t0 (t0 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Struct("Stack")), value: Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") } }) U32 Some([16, 17, 18, 19])
# Var t1 (t1 Ident("ch")) U8 Some([28])
# Var t10 (t10 Number(U8, 115)) U8 Some([36])
# Var t100 (t100 Number(U8, 58)) U8 Some([45])
# Var t101 (t101 Call(Call { function: "print_dec32", parameters: [Call(Call { function: "stack_get", parameters: [Ident("stack"), Cast { old_type: None, new_type: Number(USIZE), value: Ident("i") }] })] })) U8 Some([29])
# Var t102 (t102 Call(Call { function: "stack_get", parameters: [Ident("stack"), Cast { old_type: None, new_type: Number(USIZE), value: Ident("i") }] })) U32 Some([20, 21, 22, 23])
# Var t103 (t103 Ident("stack")) U32 Some([20, 21, 22, 23])
# Var t104 (t104 Cast { old_type: None, new_type: Number(USIZE), value: Ident("i") }) U32 Some([24, 25, 26, 27])
# Var t105 (t105 Ident("i")) U8 Some([29])
# Var t106 (t106 Number(U8, 10)) U8 Some([45])
# Var t107 (t107 Ident("i")) U8 Some([29])
# Var t108 (t108 Number(U8, 1)) U8 Some([45])
# Var t109 (t109 Ident("ch")) U8 Some([29])
# Var t11 (t11 Ident("stack_needed")) U8 Some([36])
# Var t110 (t110 Number(U8, 57)) U8 Some([45])
# Var t111 (t111 Ident("ch")) U8 Some([29])
# Var t112 (t112 Number(U8, 48)) U8 Some([45])
# Var t113 (t113 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 72)) }) U32 Some([16, 17, 18, 19])
# Var t114 (t114 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([16, 17, 18, 19])
# Var t115 (t115 Number(USIZE, 72)) U32 Some([20, 21, 22, 23])
# Var t116 (t116 Number(U8, 1)) U8 Some([45])
# Var t117 (t117 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 68)) }) U32 Some([16, 17, 18, 19])
# Var t118 (t118 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([16, 17, 18, 19])
# Var t119 (t119 Number(USIZE, 68)) U32 Some([20, 21, 22, 23])
# Var t12 (t12 Number(U8, 0)) U8 Some([46])
# Var t120 (t120 Call(Call { function: "mul32_32", parameters: [PtrFieldDeref("c", "num"), Number(USIZE, 10)] })) U32 Some([20, 21, 22, 23])
# Var t121 (t121 PtrFieldDeref("c", "num")) U32 Some([20, 21, 22, 23])
# Var t122 (t122 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 68)) }) U32 Some([20, 21, 22, 23])
# Var t123 (t123 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([20, 21, 22, 23])
# Var t124 (t124 Number(USIZE, 68)) U32 Some([32, 33, 34, 35])
# Var t125 (t125 Number(USIZE, 10)) U32 Some([32, 33, 34, 35])
# Var t126 (t126 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 68)) }) U32 Some([16, 17, 18, 19])
# Var t127 (t127 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([16, 17, 18, 19])
# Var t128 (t128 Number(USIZE, 68)) U32 Some([20, 21, 22, 23])
# Var t129 (t129 Arithmetic(Add, PtrFieldDeref("c", "num"), Cast { old_type: None, new_type: Number(USIZE), value: Arithmetic(Subtract, Ident("ch"), Number(U8, 48)) })) U32 Some([20, 21, 22, 23])
# Var t13 (t13 Call(Call { function: "RpnCalc_push_pending", parameters: [Ident("c")] })) U8 Some([29])
# Var t130 (t130 PtrFieldDeref("c", "num")) U32 Some([20, 21, 22, 23])
# Var t131 (t131 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 68)) }) U32 Some([20, 21, 22, 23])
# Var t132 (t132 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([20, 21, 22, 23])
# Var t133 (t133 Number(USIZE, 68)) U32 Some([24, 25, 26, 27])
# Var t134 (t134 Cast { old_type: None, new_type: Number(USIZE), value: Arithmetic(Subtract, Ident("ch"), Number(U8, 48)) }) U32 Some([24, 25, 26, 27])
# Var t135 (t135 Arithmetic(Subtract, Ident("ch"), Number(U8, 48))) U8 Some([47])
# Var t136 (t136 Ident("ch")) U8 Some([47])
# Var t137 (t137 Number(U8, 48)) U8 Some([28])
# Var t138 (t138 Number(U8, 1)) U8 Some([29])
# Var t14 (t14 Ident("c")) U32 Some([24, 25, 26, 27])
# Var t15 (t15 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("stack") }, Number(USIZE, 64)) }) U32 Some([40, 41, 42, 43])
# Var t16 (t16 Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("stack") }) U32 Some([32, 33, 34, 35])
# Var t17 (t17 Number(USIZE, 64)) U32 Some([40, 41, 42, 43])
# Var t18 (t18 Ident("stack_needed")) U8 Some([44])
# Var t19 (t19 Ident("stack_count")) U8 Some([36])
# Var t2 (t2 Number(U8, 43)) U8 Some([36])
# Var t20 (t20 Number(U8, 69)) U8 Some([29])
# Var t21 (t21 Number(U8, 82)) U8 Some([29])
# Var t22 (t22 Number(U8, 82)) U8 Some([29])
# Var t23 (t23 Number(U8, 10)) U8 Some([29])
# Var t24 (t24 Number(U8, 1)) U8 Some([29])
# Var t25 (t25 Ident("stack_needed")) U8 Some([44])
# Var t26 (t26 Number(U8, 0)) U8 Some([46])
# Var t27 (t27 Ident("stack")) U32 Some([16, 17, 18, 19])
# Var t28 (t28 Ident("stack_needed")) U8 Some([44])
# Var t29 (t29 Number(U8, 1)) U8 Some([46])
# Var t3 (t3 Ident("ch")) U8 Some([28])
# Var t30 (t30 Ident("stack")) U32 Some([20, 21, 22, 23])
# Var t31 (t31 Ident("ch")) U8 Some([28])
# Var t32 (t32 Number(U8, 43)) U8 Some([44])
# Var t33 (t33 Ident("b")) U32 Some([20, 21, 22, 23])
# Var t34 (t34 Ident("a")) U32 Some([16, 17, 18, 19])
# Var t35 (t35 Call(Call { function: "print_dec32", parameters: [Ident("sum")] })) U8 Some([29])
# Var t36 (t36 Ident("sum")) U32 Some([16, 17, 18, 19])
# Var t37 (t37 Number(U8, 10)) U8 Some([45])
# Var t38 (t38 Call(Call { function: "stack_push", parameters: [Ident("stack"), Ident("sum")] })) U8 Some([29])
# Var t39 (t39 Ident("stack")) U32 Some([20, 21, 22, 23])
# Var t4 (t4 Number(U8, 45)) U8 Some([36])
# Var t40 (t40 Ident("sum")) U32 Some([16, 17, 18, 19])
# Var t41 (t41 Ident("ch")) U8 Some([28])
# Var t42 (t42 Number(U8, 45)) U8 Some([44])
# Var t43 (t43 Ident("b")) U32 Some([20, 21, 22, 23])
# Var t44 (t44 Ident("a")) U32 Some([16, 17, 18, 19])
# Var t45 (t45 Call(Call { function: "print_dec32", parameters: [Ident("diff")] })) U8 Some([29])
# Var t46 (t46 Ident("diff")) U32 Some([16, 17, 18, 19])
# Var t47 (t47 Number(U8, 10)) U8 Some([45])
# Var t48 (t48 Call(Call { function: "stack_push", parameters: [Ident("stack"), Ident("diff")] })) U8 Some([29])
# Var t49 (t49 Ident("stack")) U32 Some([20, 21, 22, 23])
# Var t5 (t5 Ident("ch")) U8 Some([28])
# Var t50 (t50 Ident("diff")) U32 Some([16, 17, 18, 19])
# Var t51 (t51 Ident("ch")) U8 Some([28])
# Var t52 (t52 Number(U8, 42)) U8 Some([44])
# Var t53 (t53 Ident("b")) U32 Some([20, 21, 22, 23])
# Var t54 (t54 Ident("a")) U32 Some([16, 17, 18, 19])
# Var t55 (t55 Call(Call { function: "print_dec32", parameters: [Ident("product")] })) U8 Some([29])
# Var t56 (t56 Ident("product")) U32 Some([16, 17, 18, 19])
# Var t57 (t57 Number(U8, 10)) U8 Some([45])
# Var t58 (t58 Call(Call { function: "stack_push", parameters: [Ident("stack"), Ident("product")] })) U8 Some([29])
# Var t59 (t59 Ident("stack")) U32 Some([20, 21, 22, 23])
# Var t6 (t6 Number(U8, 42)) U8 Some([36])
# Var t60 (t60 Ident("product")) U32 Some([16, 17, 18, 19])
# Var t61 (t61 Ident("ch")) U8 Some([28])
# Var t62 (t62 Number(U8, 47)) U8 Some([44])
# Var t63 (t63 Ident("b")) U32 Some([20, 21, 22, 23])
# Var t64 (t64 Ident("a")) U32 Some([16, 17, 18, 19])
# Var t65 (t65 Call(Call { function: "print_dec32", parameters: [Ident("quotient")] })) U8 Some([29])
# Var t66 (t66 Ident("quotient")) U32 Some([16, 17, 18, 19])
# Var t67 (t67 Number(U8, 10)) U8 Some([45])
# Var t68 (t68 Call(Call { function: "stack_push", parameters: [Ident("stack"), Ident("quotient")] })) U8 Some([29])
# Var t69 (t69 Ident("stack")) U32 Some([20, 21, 22, 23])
# Var t7 (t7 Ident("ch")) U8 Some([28])
# Var t70 (t70 Ident("quotient")) U32 Some([16, 17, 18, 19])
# Var t71 (t71 Ident("ch")) U8 Some([28])
# Var t72 (t72 Number(U8, 115)) U8 Some([44])
# Var t73 (t73 Call(Call { function: "stack_push", parameters: [Ident("stack"), Ident("a")] })) U8 Some([29])
# Var t74 (t74 Ident("stack")) U32 Some([24, 25, 26, 27])
# Var t75 (t75 Ident("a")) U32 Some([16, 17, 18, 19])
# Var t76 (t76 Call(Call { function: "stack_push", parameters: [Ident("stack"), Ident("b")] })) U8 Some([29])
# Var t77 (t77 Ident("stack")) U32 Some([16, 17, 18, 19])
# Var t78 (t78 Ident("b")) U32 Some([20, 21, 22, 23])
# Var t79 (t79 Ident("ch")) U8 Some([29])
# Var t8 (t8 Number(U8, 47)) U8 Some([36])
# Var t80 (t80 Number(U8, 113)) U8 Some([45])
# Var t81 (t81 Number(U8, 0)) U8 Some([29])
# Var t82 (t82 Ident("ch")) U8 Some([29])
# Var t83 (t83 Number(U8, 10)) U8 Some([45])
# Var t84 (t84 Call(Call { function: "RpnCalc_push_pending", parameters: [Ident("c")] })) U8 Some([29])
# Var t85 (t85 Ident("c")) U32 Some([16, 17, 18, 19])
# Var t86 (t86 Ident("ch")) U8 Some([29])
# Var t87 (t87 Number(U8, 32)) U8 Some([45])
# Var t88 (t88 Call(Call { function: "RpnCalc_push_pending", parameters: [Ident("c")] })) U8 Some([29])
# Var t89 (t89 Ident("c")) U32 Some([16, 17, 18, 19])
# Var t9 (t9 Ident("ch")) U8 Some([28])
# Var t90 (t90 Ident("ch")) U8 Some([29])
# Var t91 (t91 Number(U8, 99)) U8 Some([45])
# Var t92 (t92 Call(Call { function: "RpnCalc_init", parameters: [Ident("c")] })) U8 Some([29])
# Var t93 (t93 Ident("c")) U32 Some([16, 17, 18, 19])
# Var t94 (t94 Ident("ch")) U8 Some([29])
# Var t95 (t95 Number(U8, 100)) U8 Some([45])
# Var t96 (t96 Ident("i")) U8 Some([29])
# Var t97 (t97 Ident("stack_count")) U8 Some([45])
# Var t98 (t98 Call(Call { function: "print_dec8", parameters: [Ident("i")] })) U8 Some([29])
# Var t99 (t99 Ident("i")) U8 Some([29])
# 81422 Instruction { source: "Save function parameter 'c' registers [0, 1, 2, 3] to locals [24, 25, 26, 27].", opcode: Copy32, args: [Register(0x00), Register(0x18)], resolved: None }
81 00 18 
# 81425 Instruction { source: "Save function parameter 'ch' registers [4] to locals [28].", opcode: Copy8, args: [Register(0x04), Register(0x1c)], resolved: None }
16 04 1c 
# 81428 Instruction { source: "t0 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x10)], resolved: None }
81 18 10 
# 8142b Instruction { source: "stack <- t0 U32", opcode: Copy32, args: [Register(0x10), Register(0x20)], resolved: None }
81 10 20 
# 8142e Instruction { source: "a <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x10), Constant8(0x00=0)], resolved: None }
00 10 00 
# 81431 Instruction { source: "b <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x14), Constant8(0x00=0)], resolved: None }
00 14 00 
# 81434 Instruction { source: "t1 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 81437 Instruction { source: "t2 <- 0n43/0x2bu8 ", opcode: LoadImm8, args: [Register(0x24), Constant8(0x2b=43)], resolved: None }
00 24 2b 
# 8143a Instruction { source: "if t1 == t2 then 'RpnCalc_handle_if_true_0_1' else 'RpnCalc_handle_if_else_0_2'", opcode: Cmp8, args: [Register(0x1c), Register(0x24)], resolved: None }
25 1c 24 
# 8143d Instruction { source: "if t1 == t2 then 'RpnCalc_handle_if_true_0_1' else 'RpnCalc_handle_if_else_0_2'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_0_1)], resolved: None }
42 45 14 08 
# 81441 Instruction { source: "if t1 == t2 then 'RpnCalc_handle_if_true_0_1' else 'RpnCalc_handle_if_else_0_2'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_0_2)], resolved: None }
40 4c 14 08 
# RpnCalc_handle_if_true_0_1
# 81445 Instruction { source: "stack_needed <- 0n2/0x02u8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x02=2)], resolved: None }
00 2c 02 
# 81448 Instruction { source: "goto RpnCalc_handle_if_end_0", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_0)], resolved: None }
40 af 14 08 
# RpnCalc_handle_if_else_0_2
# 8144c Instruction { source: "t3 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 8144f Instruction { source: "t4 <- 0n45/0x2du8 ", opcode: LoadImm8, args: [Register(0x24), Constant8(0x2d=45)], resolved: None }
00 24 2d 
# 81452 Instruction { source: "if t3 == t4 then 'RpnCalc_handle_if_true_1_3' else 'RpnCalc_handle_if_else_1_4'", opcode: Cmp8, args: [Register(0x1c), Register(0x24)], resolved: None }
25 1c 24 
# 81455 Instruction { source: "if t3 == t4 then 'RpnCalc_handle_if_true_1_3' else 'RpnCalc_handle_if_else_1_4'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_1_3)], resolved: None }
42 5d 14 08 
# 81459 Instruction { source: "if t3 == t4 then 'RpnCalc_handle_if_true_1_3' else 'RpnCalc_handle_if_else_1_4'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_1_4)], resolved: None }
40 64 14 08 
# RpnCalc_handle_if_true_1_3
# 8145d Instruction { source: "stack_needed <- 0n2/0x02u8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x02=2)], resolved: None }
00 2c 02 
# 81460 Instruction { source: "goto RpnCalc_handle_if_end_0", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_0)], resolved: None }
40 af 14 08 
# RpnCalc_handle_if_else_1_4
# 81464 Instruction { source: "t5 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 81467 Instruction { source: "t6 <- 0n42/0x2au8 ", opcode: LoadImm8, args: [Register(0x24), Constant8(0x2a=42)], resolved: None }
00 24 2a 
# 8146a Instruction { source: "if t5 == t6 then 'RpnCalc_handle_if_true_2_5' else 'RpnCalc_handle_if_else_2_6'", opcode: Cmp8, args: [Register(0x1c), Register(0x24)], resolved: None }
25 1c 24 
# 8146d Instruction { source: "if t5 == t6 then 'RpnCalc_handle_if_true_2_5' else 'RpnCalc_handle_if_else_2_6'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_2_5)], resolved: None }
42 75 14 08 
# 81471 Instruction { source: "if t5 == t6 then 'RpnCalc_handle_if_true_2_5' else 'RpnCalc_handle_if_else_2_6'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_2_6)], resolved: None }
40 7c 14 08 
# RpnCalc_handle_if_true_2_5
# 81475 Instruction { source: "stack_needed <- 0n2/0x02u8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x02=2)], resolved: None }
00 2c 02 
# 81478 Instruction { source: "goto RpnCalc_handle_if_end_0", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_0)], resolved: None }
40 af 14 08 
# RpnCalc_handle_if_else_2_6
# 8147c Instruction { source: "t7 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 8147f Instruction { source: "t8 <- 0n47/0x2fu8 ", opcode: LoadImm8, args: [Register(0x24), Constant8(0x2f=47)], resolved: None }
00 24 2f 
# 81482 Instruction { source: "if t7 == t8 then 'RpnCalc_handle_if_true_3_7' else 'RpnCalc_handle_if_else_3_8'", opcode: Cmp8, args: [Register(0x1c), Register(0x24)], resolved: None }
25 1c 24 
# 81485 Instruction { source: "if t7 == t8 then 'RpnCalc_handle_if_true_3_7' else 'RpnCalc_handle_if_else_3_8'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_3_7)], resolved: None }
42 8d 14 08 
# 81489 Instruction { source: "if t7 == t8 then 'RpnCalc_handle_if_true_3_7' else 'RpnCalc_handle_if_else_3_8'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_3_8)], resolved: None }
40 94 14 08 
# RpnCalc_handle_if_true_3_7
# 8148d Instruction { source: "stack_needed <- 0n2/0x02u8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x02=2)], resolved: None }
00 2c 02 
# 81490 Instruction { source: "goto RpnCalc_handle_if_end_0", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_0)], resolved: None }
40 af 14 08 
# RpnCalc_handle_if_else_3_8
# 81494 Instruction { source: "t9 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 81497 Instruction { source: "t10 <- 0n115/0x73u8 ", opcode: LoadImm8, args: [Register(0x24), Constant8(0x73=115)], resolved: None }
00 24 73 
# 8149a Instruction { source: "if t9 == t10 then 'RpnCalc_handle_if_true_4_9' else 'RpnCalc_handle_if_else_4_10'", opcode: Cmp8, args: [Register(0x1c), Register(0x24)], resolved: None }
25 1c 24 
# 8149d Instruction { source: "if t9 == t10 then 'RpnCalc_handle_if_true_4_9' else 'RpnCalc_handle_if_else_4_10'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_4_9)], resolved: None }
42 a5 14 08 
# 814a1 Instruction { source: "if t9 == t10 then 'RpnCalc_handle_if_true_4_9' else 'RpnCalc_handle_if_else_4_10'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_4_10)], resolved: None }
40 ac 14 08 
# RpnCalc_handle_if_true_4_9
# 814a5 Instruction { source: "stack_needed <- 0n2/0x02u8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x02=2)], resolved: None }
00 2c 02 
# 814a8 Instruction { source: "goto RpnCalc_handle_if_end_0", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_0)], resolved: None }
40 af 14 08 
# RpnCalc_handle_if_else_4_10
# 814ac Instruction { source: "stack_needed <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x00=0)], resolved: None }
00 2c 00 
# RpnCalc_handle_if_end_0
# 814af Instruction { source: "t11 <- stack_needed U8", opcode: Copy8, args: [Register(0x2c), Register(0x24)], resolved: None }
16 2c 24 
# 814b2 Instruction { source: "t12 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x2e), Constant8(0x00=0)], resolved: None }
00 2e 00 
# 814b5 Instruction { source: "if t11 > t12 then 'RpnCalc_handle_if_true_0_12' else 'RpnCalc_handle_if_else_0_13'", opcode: Cmp8, args: [Register(0x24), Register(0x2e)], resolved: None }
25 24 2e 
# 814b8 Instruction { source: "if t11 > t12 then 'RpnCalc_handle_if_true_0_12' else 'RpnCalc_handle_if_else_0_13'", opcode: JcImm, args: [Label24(RpnCalc_handle_if_else_0_13)], resolved: None }
41 dc 14 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t11 > t12 then 'RpnCalc_handle_if_true_0_12' else 'RpnCalc_handle_if_else_0_13'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_true_0_12)], resolved: None }
# RpnCalc_handle_if_true_0_12
# 814bc Instruction { source: "t14 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x18)], resolved: None }
81 18 18 
# 814bf Instruction { source: "Arg0[c]=t14 None <= call RpnCalc_push_pending(t14,)", opcode: Copy32, args: [Register(0x18), Register(0x00)], resolved: None }
81 18 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {60, 61, 62, 63, 64, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195}
# Registers to save: []
# 814c2 Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 814c8 Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c d2 14 08 00 
# 814ce Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: JmpImm, args: [Label24(:RpnCalc_push_pending)], resolved: None }
40 fc 1b 08 
# 814d2 Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 814d8 Instruction { source: "goto RpnCalc_handle_if_end_11", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_11)], resolved: None }
40 dc 14 08 
# RpnCalc_handle_if_else_0_13
# RpnCalc_handle_if_end_11
# 814dc Instruction { source: "t16 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x20)], resolved: None }
81 20 20 
# 814df Instruction { source: "t17 <- 0n64/0x00000040u32 ", opcode: LoadImm32, args: [Register(0x28), Constant32(0x00000040=64)], resolved: None }
80 28 40 00 00 00 
# 814e5 Instruction { source: "t15 <- t16 Add t17", opcode: Add32NoCarryIn, args: [Register(0x20), Register(0x28), Register(0x28)], resolved: None }
a0 20 28 28 
# 814e9 Instruction { source: "stack_count_usize <- mem[t15] U32", opcode: Load32, args: [Register(0x28), Register(0x28)], resolved: None }
90 28 28 
# 814ec Instruction { source: "stack_count <- stack_count_usize[0x00..0x01] U8", opcode: Copy8, args: [Register(0x28), Register(0x24)], resolved: None }
16 28 24 
# 814ef Instruction { source: "t18 <- stack_needed U8", opcode: Copy8, args: [Register(0x2c), Register(0x2c)], resolved: None }
16 2c 2c 
# 814f2 Instruction { source: "t19 <- stack_count U8", opcode: Copy8, args: [Register(0x24), Register(0x24)], resolved: None }
16 24 24 
# 814f5 Instruction { source: "if t18 > t19 then 'RpnCalc_handle_if_true_0_15' else 'RpnCalc_handle_if_else_0_16'", opcode: Cmp8, args: [Register(0x2c), Register(0x24)], resolved: None }
25 2c 24 
# 814f8 Instruction { source: "if t18 > t19 then 'RpnCalc_handle_if_true_0_15' else 'RpnCalc_handle_if_else_0_16'", opcode: JcImm, args: [Label24(RpnCalc_handle_if_else_0_16)], resolved: None }
41 1c 15 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t18 > t19 then 'RpnCalc_handle_if_true_0_15' else 'RpnCalc_handle_if_else_0_16'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_true_0_15)], resolved: None }
# RpnCalc_handle_if_true_0_15
# 814fc Instruction { source: "t20 <- 0n69/0x45u8 ", opcode: LoadImm8, args: [Register(0x1d), Constant8(0x45=69)], resolved: None }
00 1d 45 
# 814ff Instruction { source: "ttyout <- t20", opcode: TtyOut, args: [Register(0x1d)], resolved: None }
13 1d 
# 81501 Instruction { source: "t21 <- 0n82/0x52u8 ", opcode: LoadImm8, args: [Register(0x1d), Constant8(0x52=82)], resolved: None }
00 1d 52 
# 81504 Instruction { source: "ttyout <- t21", opcode: TtyOut, args: [Register(0x1d)], resolved: None }
13 1d 
# 81506 Instruction { source: "t22 <- 0n82/0x52u8 ", opcode: LoadImm8, args: [Register(0x1d), Constant8(0x52=82)], resolved: None }
00 1d 52 
# 81509 Instruction { source: "ttyout <- t22", opcode: TtyOut, args: [Register(0x1d)], resolved: None }
13 1d 
# 8150b Instruction { source: "t23 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x1d), Constant8(0x0a=10)], resolved: None }
00 1d 0a 
# 8150e Instruction { source: "ttyout <- t23", opcode: TtyOut, args: [Register(0x1d)], resolved: None }
13 1d 
# 81510 Instruction { source: "t24 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x1d), Constant8(0x01=1)], resolved: None }
00 1d 01 
# 81513 Instruction { source: "return Some(t24)", opcode: Copy8, args: [Register(0x1d), Register(0x00)], resolved: None }
16 1d 00 
# 81516 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81518 Instruction { source: "goto RpnCalc_handle_if_end_14", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_14)], resolved: None }
40 1c 15 08 
# RpnCalc_handle_if_else_0_16
# RpnCalc_handle_if_end_14
# 8151c Instruction { source: "t25 <- stack_needed U8", opcode: Copy8, args: [Register(0x2c), Register(0x2c)], resolved: None }
16 2c 2c 
# 8151f Instruction { source: "t26 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x2e), Constant8(0x00=0)], resolved: None }
00 2e 00 
# 81522 Instruction { source: "if t25 > t26 then 'RpnCalc_handle_if_true_0_18' else 'RpnCalc_handle_if_else_0_19'", opcode: Cmp8, args: [Register(0x2c), Register(0x2e)], resolved: None }
25 2c 2e 
# 81525 Instruction { source: "if t25 > t26 then 'RpnCalc_handle_if_true_0_18' else 'RpnCalc_handle_if_else_0_19'", opcode: JcImm, args: [Label24(RpnCalc_handle_if_else_0_19)], resolved: None }
41 4c 15 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t25 > t26 then 'RpnCalc_handle_if_true_0_18' else 'RpnCalc_handle_if_else_0_19'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_true_0_18)], resolved: None }
# RpnCalc_handle_if_true_0_18
# 81529 Instruction { source: "t27 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x10)], resolved: None }
81 20 10 
# 8152c Instruction { source: "Arg0[s]=t27 Some(a) <= call stack_pop(t27,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175}
# Registers to save: []
# 8152f Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81535 Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 3f 15 08 00 
# 8153b Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: JmpImm, args: [Label24(:stack_pop)], resolved: None }
40 48 2b 08 
# 8153f Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81545 Instruction { source: "Some(a) <= call stack_pop(t27,)", opcode: Copy32, args: [Register(0x00), Register(0x10)], resolved: None }
81 00 10 
# 81548 Instruction { source: "goto RpnCalc_handle_if_end_17", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_17)], resolved: None }
40 4c 15 08 
# RpnCalc_handle_if_else_0_19
# RpnCalc_handle_if_end_17
# 8154c Instruction { source: "t28 <- stack_needed U8", opcode: Copy8, args: [Register(0x2c), Register(0x2c)], resolved: None }
16 2c 2c 
# 8154f Instruction { source: "t29 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x2e), Constant8(0x01=1)], resolved: None }
00 2e 01 
# 81552 Instruction { source: "if t28 > t29 then 'RpnCalc_handle_if_true_0_21' else 'RpnCalc_handle_if_else_0_22'", opcode: Cmp8, args: [Register(0x2c), Register(0x2e)], resolved: None }
25 2c 2e 
# 81555 Instruction { source: "if t28 > t29 then 'RpnCalc_handle_if_true_0_21' else 'RpnCalc_handle_if_else_0_22'", opcode: JcImm, args: [Label24(RpnCalc_handle_if_else_0_22)], resolved: None }
41 7c 15 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t28 > t29 then 'RpnCalc_handle_if_true_0_21' else 'RpnCalc_handle_if_else_0_22'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_true_0_21)], resolved: None }
# RpnCalc_handle_if_true_0_21
# 81559 Instruction { source: "t30 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x14)], resolved: None }
81 20 14 
# 8155c Instruction { source: "Arg0[s]=t30 Some(b) <= call stack_pop(t30,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175}
# Registers to save: []
# 8155f Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81565 Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 6f 15 08 00 
# 8156b Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: JmpImm, args: [Label24(:stack_pop)], resolved: None }
40 48 2b 08 
# 8156f Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81575 Instruction { source: "Some(b) <= call stack_pop(t30,)", opcode: Copy32, args: [Register(0x00), Register(0x14)], resolved: None }
81 00 14 
# 81578 Instruction { source: "goto RpnCalc_handle_if_end_20", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_20)], resolved: None }
40 7c 15 08 
# RpnCalc_handle_if_else_0_22
# RpnCalc_handle_if_end_20
# 8157c Instruction { source: "t31 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 8157f Instruction { source: "t32 <- 0n43/0x2bu8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x2b=43)], resolved: None }
00 2c 2b 
# 81582 Instruction { source: "if t31 == t32 then 'RpnCalc_handle_if_true_0_24' else 'RpnCalc_handle_if_else_0_25'", opcode: Cmp8, args: [Register(0x1c), Register(0x2c)], resolved: None }
25 1c 2c 
# 81585 Instruction { source: "if t31 == t32 then 'RpnCalc_handle_if_true_0_24' else 'RpnCalc_handle_if_else_0_25'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_0_24)], resolved: None }
42 8d 15 08 
# 81589 Instruction { source: "if t31 == t32 then 'RpnCalc_handle_if_true_0_24' else 'RpnCalc_handle_if_else_0_25'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_0_25)], resolved: None }
40 32 16 08 
# RpnCalc_handle_if_true_0_24
# 8158d Instruction { source: "t33 <- b U32", opcode: Copy32, args: [Register(0x14), Register(0x14)], resolved: None }
81 14 14 
# 81590 Instruction { source: "t34 <- a U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 81593 Instruction { source: "sum <- t33 Add t34", opcode: Add32NoCarryIn, args: [Register(0x14), Register(0x10), Register(0x10)], resolved: None }
a0 14 10 10 
# 81597 Instruction { source: "t36 <- sum U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 8159a Instruction { source: "Arg0[a]=t36 None <= call print_dec32(t36,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 160, 161, 162, 163, 164, 168, 169, 170, 171, 172, 173, 174, 175, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 252, 253, 254, 255}
# Registers to save: [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 36, 40, 44, 45, 46, 47]
# 8159d Instruction { source: "Saving reg0x2f before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x2f)], resolved: None }
14 2f 
# 8159f Instruction { source: "Saving reg0x2e before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x2e)], resolved: None }
14 2e 
# 815a1 Instruction { source: "Saving reg0x2d before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x2d)], resolved: None }
14 2d 
# 815a3 Instruction { source: "Saving reg0x2c before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x2c)], resolved: None }
14 2c 
# 815a5 Instruction { source: "Saving reg0x28 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x28)], resolved: None }
14 28 
# 815a7 Instruction { source: "Saving reg0x24 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x24)], resolved: None }
14 24 
# 815a9 Instruction { source: "Saving reg0x20 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x20)], resolved: None }
14 20 
# 815ab Instruction { source: "Saving reg0x1d before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x1d)], resolved: None }
14 1d 
# 815ad Instruction { source: "Saving reg0x1c before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x1c)], resolved: None }
14 1c 
# 815af Instruction { source: "Saving reg0x1b before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x1b)], resolved: None }
14 1b 
# 815b1 Instruction { source: "Saving reg0x1a before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x1a)], resolved: None }
14 1a 
# 815b3 Instruction { source: "Saving reg0x19 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x19)], resolved: None }
14 19 
# 815b5 Instruction { source: "Saving reg0x18 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x18)], resolved: None }
14 18 
# 815b7 Instruction { source: "Saving reg0x17 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x17)], resolved: None }
14 17 
# 815b9 Instruction { source: "Saving reg0x16 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x16)], resolved: None }
14 16 
# 815bb Instruction { source: "Saving reg0x15 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x15)], resolved: None }
14 15 
# 815bd Instruction { source: "Saving reg0x14 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x14)], resolved: None }
14 14 
# 815bf Instruction { source: "Saving reg0x13 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x13)], resolved: None }
14 13 
# 815c1 Instruction { source: "Saving reg0x12 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x12)], resolved: None }
14 12 
# 815c3 Instruction { source: "Saving reg0x11 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x11)], resolved: None }
14 11 
# 815c5 Instruction { source: "Saving reg0x10 before None <= call print_dec32(t36,)", opcode: Push8, args: [Register(0x10)], resolved: None }
14 10 
# 815c7 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 815cd Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c d7 15 08 00 
# 815d3 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: JmpImm, args: [Label24(:print_dec32)], resolved: None }
40 22 27 08 
# 815d7 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 815dd Instruction { source: "Restoring reg0x10 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x10)], resolved: None }
15 10 
# 815df Instruction { source: "Restoring reg0x11 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x11)], resolved: None }
15 11 
# 815e1 Instruction { source: "Restoring reg0x12 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x12)], resolved: None }
15 12 
# 815e3 Instruction { source: "Restoring reg0x13 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x13)], resolved: None }
15 13 
# 815e5 Instruction { source: "Restoring reg0x14 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x14)], resolved: None }
15 14 
# 815e7 Instruction { source: "Restoring reg0x15 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x15)], resolved: None }
15 15 
# 815e9 Instruction { source: "Restoring reg0x16 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x16)], resolved: None }
15 16 
# 815eb Instruction { source: "Restoring reg0x17 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x17)], resolved: None }
15 17 
# 815ed Instruction { source: "Restoring reg0x18 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x18)], resolved: None }
15 18 
# 815ef Instruction { source: "Restoring reg0x19 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x19)], resolved: None }
15 19 
# 815f1 Instruction { source: "Restoring reg0x1a after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x1a)], resolved: None }
15 1a 
# 815f3 Instruction { source: "Restoring reg0x1b after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x1b)], resolved: None }
15 1b 
# 815f5 Instruction { source: "Restoring reg0x1c after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x1c)], resolved: None }
15 1c 
# 815f7 Instruction { source: "Restoring reg0x1d after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x1d)], resolved: None }
15 1d 
# 815f9 Instruction { source: "Restoring reg0x20 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x20)], resolved: None }
15 20 
# 815fb Instruction { source: "Restoring reg0x24 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x24)], resolved: None }
15 24 
# 815fd Instruction { source: "Restoring reg0x28 after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x28)], resolved: None }
15 28 
# 815ff Instruction { source: "Restoring reg0x2c after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x2c)], resolved: None }
15 2c 
# 81601 Instruction { source: "Restoring reg0x2d after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x2d)], resolved: None }
15 2d 
# 81603 Instruction { source: "Restoring reg0x2e after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x2e)], resolved: None }
15 2e 
# 81605 Instruction { source: "Restoring reg0x2f after None <= call print_dec32(t36,)", opcode: Pop8, args: [Register(0x2f)], resolved: None }
15 2f 
# 81607 Instruction { source: "t37 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x0a=10)], resolved: None }
00 2d 0a 
# 8160a Instruction { source: "ttyout <- t37", opcode: TtyOut, args: [Register(0x2d)], resolved: None }
13 2d 
# 8160c Instruction { source: "t39 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x14)], resolved: None }
81 20 14 
# 8160f Instruction { source: "t40 <- sum U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 81612 Instruction { source: "Arg0[s]=t39 None <= call stack_push(t39,t40,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# 81615 Instruction { source: "Arg1[n]=t40 None <= call stack_push(t39,t40,)", opcode: Copy32, args: [Register(0x10), Register(0x04)], resolved: None }
81 10 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195}
# Registers to save: []
# 81618 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8161e Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 28 16 08 00 
# 81624 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 c4 2b 08 
# 81628 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8162e Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 ac 1b 08 
# RpnCalc_handle_if_else_0_25
# 81632 Instruction { source: "t41 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 81635 Instruction { source: "t42 <- 0n45/0x2du8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x2d=45)], resolved: None }
00 2c 2d 
# 81638 Instruction { source: "if t41 == t42 then 'RpnCalc_handle_if_true_1_26' else 'RpnCalc_handle_if_else_1_27'", opcode: Cmp8, args: [Register(0x1c), Register(0x2c)], resolved: None }
25 1c 2c 
# 8163b Instruction { source: "if t41 == t42 then 'RpnCalc_handle_if_true_1_26' else 'RpnCalc_handle_if_else_1_27'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_1_26)], resolved: None }
42 43 16 08 
# 8163f Instruction { source: "if t41 == t42 then 'RpnCalc_handle_if_true_1_26' else 'RpnCalc_handle_if_else_1_27'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_1_27)], resolved: None }
40 f9 16 08 
# RpnCalc_handle_if_true_1_26
# 81643 Instruction { source: "t43 <- b U32", opcode: Copy32, args: [Register(0x14), Register(0x14)], resolved: None }
81 14 14 
# 81646 Instruction { source: "t44 <- a U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 81649 Instruction { source: "diff <- t43 Subtract t44", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# 8164c Instruction { source: "diff <- t43 Subtract t44", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 8164e Instruction { source: "diff <- t43 Subtract t44", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 81650 Instruction { source: "diff <- t43 Subtract t44", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 81652 Instruction { source: "diff <- t43 Subtract t44", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 81654 Instruction { source: "diff <- t43 Subtract t44", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 8165a Instruction { source: "diff <- t43 Subtract t44", opcode: Add32NoCarryIn, args: [Register(0x14), Register(0x00), Register(0x10)], resolved: None }
a0 14 00 10 
# 8165e Instruction { source: "t46 <- diff U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 81661 Instruction { source: "Arg0[a]=t46 None <= call print_dec32(t46,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 160, 161, 162, 163, 164, 168, 169, 170, 171, 172, 173, 174, 175, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 252, 253, 254, 255}
# Registers to save: [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 36, 40, 44, 45, 46, 47]
# 81664 Instruction { source: "Saving reg0x2f before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x2f)], resolved: None }
14 2f 
# 81666 Instruction { source: "Saving reg0x2e before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x2e)], resolved: None }
14 2e 
# 81668 Instruction { source: "Saving reg0x2d before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x2d)], resolved: None }
14 2d 
# 8166a Instruction { source: "Saving reg0x2c before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x2c)], resolved: None }
14 2c 
# 8166c Instruction { source: "Saving reg0x28 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x28)], resolved: None }
14 28 
# 8166e Instruction { source: "Saving reg0x24 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x24)], resolved: None }
14 24 
# 81670 Instruction { source: "Saving reg0x20 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x20)], resolved: None }
14 20 
# 81672 Instruction { source: "Saving reg0x1d before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x1d)], resolved: None }
14 1d 
# 81674 Instruction { source: "Saving reg0x1c before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x1c)], resolved: None }
14 1c 
# 81676 Instruction { source: "Saving reg0x1b before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x1b)], resolved: None }
14 1b 
# 81678 Instruction { source: "Saving reg0x1a before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x1a)], resolved: None }
14 1a 
# 8167a Instruction { source: "Saving reg0x19 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x19)], resolved: None }
14 19 
# 8167c Instruction { source: "Saving reg0x18 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x18)], resolved: None }
14 18 
# 8167e Instruction { source: "Saving reg0x17 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x17)], resolved: None }
14 17 
# 81680 Instruction { source: "Saving reg0x16 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x16)], resolved: None }
14 16 
# 81682 Instruction { source: "Saving reg0x15 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x15)], resolved: None }
14 15 
# 81684 Instruction { source: "Saving reg0x14 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x14)], resolved: None }
14 14 
# 81686 Instruction { source: "Saving reg0x13 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x13)], resolved: None }
14 13 
# 81688 Instruction { source: "Saving reg0x12 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x12)], resolved: None }
14 12 
# 8168a Instruction { source: "Saving reg0x11 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x11)], resolved: None }
14 11 
# 8168c Instruction { source: "Saving reg0x10 before None <= call print_dec32(t46,)", opcode: Push8, args: [Register(0x10)], resolved: None }
14 10 
# 8168e Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81694 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 9e 16 08 00 
# 8169a Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: JmpImm, args: [Label24(:print_dec32)], resolved: None }
40 22 27 08 
# 8169e Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 816a4 Instruction { source: "Restoring reg0x10 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x10)], resolved: None }
15 10 
# 816a6 Instruction { source: "Restoring reg0x11 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x11)], resolved: None }
15 11 
# 816a8 Instruction { source: "Restoring reg0x12 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x12)], resolved: None }
15 12 
# 816aa Instruction { source: "Restoring reg0x13 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x13)], resolved: None }
15 13 
# 816ac Instruction { source: "Restoring reg0x14 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x14)], resolved: None }
15 14 
# 816ae Instruction { source: "Restoring reg0x15 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x15)], resolved: None }
15 15 
# 816b0 Instruction { source: "Restoring reg0x16 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x16)], resolved: None }
15 16 
# 816b2 Instruction { source: "Restoring reg0x17 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x17)], resolved: None }
15 17 
# 816b4 Instruction { source: "Restoring reg0x18 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x18)], resolved: None }
15 18 
# 816b6 Instruction { source: "Restoring reg0x19 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x19)], resolved: None }
15 19 
# 816b8 Instruction { source: "Restoring reg0x1a after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x1a)], resolved: None }
15 1a 
# 816ba Instruction { source: "Restoring reg0x1b after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x1b)], resolved: None }
15 1b 
# 816bc Instruction { source: "Restoring reg0x1c after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x1c)], resolved: None }
15 1c 
# 816be Instruction { source: "Restoring reg0x1d after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x1d)], resolved: None }
15 1d 
# 816c0 Instruction { source: "Restoring reg0x20 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x20)], resolved: None }
15 20 
# 816c2 Instruction { source: "Restoring reg0x24 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x24)], resolved: None }
15 24 
# 816c4 Instruction { source: "Restoring reg0x28 after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x28)], resolved: None }
15 28 
# 816c6 Instruction { source: "Restoring reg0x2c after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x2c)], resolved: None }
15 2c 
# 816c8 Instruction { source: "Restoring reg0x2d after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x2d)], resolved: None }
15 2d 
# 816ca Instruction { source: "Restoring reg0x2e after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x2e)], resolved: None }
15 2e 
# 816cc Instruction { source: "Restoring reg0x2f after None <= call print_dec32(t46,)", opcode: Pop8, args: [Register(0x2f)], resolved: None }
15 2f 
# 816ce Instruction { source: "t47 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x0a=10)], resolved: None }
00 2d 0a 
# 816d1 Instruction { source: "ttyout <- t47", opcode: TtyOut, args: [Register(0x2d)], resolved: None }
13 2d 
# 816d3 Instruction { source: "t49 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x14)], resolved: None }
81 20 14 
# 816d6 Instruction { source: "t50 <- diff U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 816d9 Instruction { source: "Arg0[s]=t49 None <= call stack_push(t49,t50,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# 816dc Instruction { source: "Arg1[n]=t50 None <= call stack_push(t49,t50,)", opcode: Copy32, args: [Register(0x10), Register(0x04)], resolved: None }
81 10 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195}
# Registers to save: []
# 816df Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 816e5 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c ef 16 08 00 
# 816eb Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 c4 2b 08 
# 816ef Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 816f5 Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 ac 1b 08 
# RpnCalc_handle_if_else_1_27
# 816f9 Instruction { source: "t51 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 816fc Instruction { source: "t52 <- 0n42/0x2au8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x2a=42)], resolved: None }
00 2c 2a 
# 816ff Instruction { source: "if t51 == t52 then 'RpnCalc_handle_if_true_2_28' else 'RpnCalc_handle_if_else_2_29'", opcode: Cmp8, args: [Register(0x1c), Register(0x2c)], resolved: None }
25 1c 2c 
# 81702 Instruction { source: "if t51 == t52 then 'RpnCalc_handle_if_true_2_28' else 'RpnCalc_handle_if_else_2_29'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_2_28)], resolved: None }
42 0a 17 08 
# 81706 Instruction { source: "if t51 == t52 then 'RpnCalc_handle_if_true_2_28' else 'RpnCalc_handle_if_else_2_29'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_2_29)], resolved: None }
40 ca 17 08 
# RpnCalc_handle_if_true_2_28
# 8170a Instruction { source: "t53 <- b U32", opcode: Copy32, args: [Register(0x14), Register(0x14)], resolved: None }
81 14 14 
# 8170d Instruction { source: "t54 <- a U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 81710 Instruction { source: "Arg0[a]=t53 Some(product) <= call mul32_32(t53,t54,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# 81713 Instruction { source: "Arg1[b]=t54 Some(product) <= call mul32_32(t53,t54,)", opcode: Copy32, args: [Register(0x10), Register(0x04)], resolved: None }
81 10 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250}
# Registers to save: []
# 81716 Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8171c Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 26 17 08 00 
# 81722 Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: JmpImm, args: [Label24(:mul32_32)], resolved: None }
40 25 24 08 
# 81726 Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8172c Instruction { source: "Some(product) <= call mul32_32(t53,t54,)", opcode: Copy32, args: [Register(0x00), Register(0x10)], resolved: None }
81 00 10 
# 8172f Instruction { source: "t56 <- product U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 81732 Instruction { source: "Arg0[a]=t56 None <= call print_dec32(t56,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 160, 161, 162, 163, 164, 168, 169, 170, 171, 172, 173, 174, 175, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 252, 253, 254, 255}
# Registers to save: [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 36, 40, 44, 45, 46, 47]
# 81735 Instruction { source: "Saving reg0x2f before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x2f)], resolved: None }
14 2f 
# 81737 Instruction { source: "Saving reg0x2e before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x2e)], resolved: None }
14 2e 
# 81739 Instruction { source: "Saving reg0x2d before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x2d)], resolved: None }
14 2d 
# 8173b Instruction { source: "Saving reg0x2c before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x2c)], resolved: None }
14 2c 
# 8173d Instruction { source: "Saving reg0x28 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x28)], resolved: None }
14 28 
# 8173f Instruction { source: "Saving reg0x24 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x24)], resolved: None }
14 24 
# 81741 Instruction { source: "Saving reg0x20 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x20)], resolved: None }
14 20 
# 81743 Instruction { source: "Saving reg0x1d before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x1d)], resolved: None }
14 1d 
# 81745 Instruction { source: "Saving reg0x1c before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x1c)], resolved: None }
14 1c 
# 81747 Instruction { source: "Saving reg0x1b before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x1b)], resolved: None }
14 1b 
# 81749 Instruction { source: "Saving reg0x1a before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x1a)], resolved: None }
14 1a 
# 8174b Instruction { source: "Saving reg0x19 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x19)], resolved: None }
14 19 
# 8174d Instruction { source: "Saving reg0x18 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x18)], resolved: None }
14 18 
# 8174f Instruction { source: "Saving reg0x17 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x17)], resolved: None }
14 17 
# 81751 Instruction { source: "Saving reg0x16 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x16)], resolved: None }
14 16 
# 81753 Instruction { source: "Saving reg0x15 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x15)], resolved: None }
14 15 
# 81755 Instruction { source: "Saving reg0x14 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x14)], resolved: None }
14 14 
# 81757 Instruction { source: "Saving reg0x13 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x13)], resolved: None }
14 13 
# 81759 Instruction { source: "Saving reg0x12 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x12)], resolved: None }
14 12 
# 8175b Instruction { source: "Saving reg0x11 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x11)], resolved: None }
14 11 
# 8175d Instruction { source: "Saving reg0x10 before None <= call print_dec32(t56,)", opcode: Push8, args: [Register(0x10)], resolved: None }
14 10 
# 8175f Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81765 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 6f 17 08 00 
# 8176b Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: JmpImm, args: [Label24(:print_dec32)], resolved: None }
40 22 27 08 
# 8176f Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81775 Instruction { source: "Restoring reg0x10 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x10)], resolved: None }
15 10 
# 81777 Instruction { source: "Restoring reg0x11 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x11)], resolved: None }
15 11 
# 81779 Instruction { source: "Restoring reg0x12 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x12)], resolved: None }
15 12 
# 8177b Instruction { source: "Restoring reg0x13 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x13)], resolved: None }
15 13 
# 8177d Instruction { source: "Restoring reg0x14 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x14)], resolved: None }
15 14 
# 8177f Instruction { source: "Restoring reg0x15 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x15)], resolved: None }
15 15 
# 81781 Instruction { source: "Restoring reg0x16 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x16)], resolved: None }
15 16 
# 81783 Instruction { source: "Restoring reg0x17 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x17)], resolved: None }
15 17 
# 81785 Instruction { source: "Restoring reg0x18 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x18)], resolved: None }
15 18 
# 81787 Instruction { source: "Restoring reg0x19 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x19)], resolved: None }
15 19 
# 81789 Instruction { source: "Restoring reg0x1a after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x1a)], resolved: None }
15 1a 
# 8178b Instruction { source: "Restoring reg0x1b after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x1b)], resolved: None }
15 1b 
# 8178d Instruction { source: "Restoring reg0x1c after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x1c)], resolved: None }
15 1c 
# 8178f Instruction { source: "Restoring reg0x1d after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x1d)], resolved: None }
15 1d 
# 81791 Instruction { source: "Restoring reg0x20 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x20)], resolved: None }
15 20 
# 81793 Instruction { source: "Restoring reg0x24 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x24)], resolved: None }
15 24 
# 81795 Instruction { source: "Restoring reg0x28 after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x28)], resolved: None }
15 28 
# 81797 Instruction { source: "Restoring reg0x2c after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x2c)], resolved: None }
15 2c 
# 81799 Instruction { source: "Restoring reg0x2d after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x2d)], resolved: None }
15 2d 
# 8179b Instruction { source: "Restoring reg0x2e after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x2e)], resolved: None }
15 2e 
# 8179d Instruction { source: "Restoring reg0x2f after None <= call print_dec32(t56,)", opcode: Pop8, args: [Register(0x2f)], resolved: None }
15 2f 
# 8179f Instruction { source: "t57 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x0a=10)], resolved: None }
00 2d 0a 
# 817a2 Instruction { source: "ttyout <- t57", opcode: TtyOut, args: [Register(0x2d)], resolved: None }
13 2d 
# 817a4 Instruction { source: "t59 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x14)], resolved: None }
81 20 14 
# 817a7 Instruction { source: "t60 <- product U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 817aa Instruction { source: "Arg0[s]=t59 None <= call stack_push(t59,t60,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# 817ad Instruction { source: "Arg1[n]=t60 None <= call stack_push(t59,t60,)", opcode: Copy32, args: [Register(0x10), Register(0x04)], resolved: None }
81 10 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195}
# Registers to save: []
# 817b0 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 817b6 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c c0 17 08 00 
# 817bc Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 c4 2b 08 
# 817c0 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 817c6 Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 ac 1b 08 
# RpnCalc_handle_if_else_2_29
# 817ca Instruction { source: "t61 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 817cd Instruction { source: "t62 <- 0n47/0x2fu8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x2f=47)], resolved: None }
00 2c 2f 
# 817d0 Instruction { source: "if t61 == t62 then 'RpnCalc_handle_if_true_3_30' else 'RpnCalc_handle_if_else_3_31'", opcode: Cmp8, args: [Register(0x1c), Register(0x2c)], resolved: None }
25 1c 2c 
# 817d3 Instruction { source: "if t61 == t62 then 'RpnCalc_handle_if_true_3_30' else 'RpnCalc_handle_if_else_3_31'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_3_30)], resolved: None }
42 db 17 08 
# 817d7 Instruction { source: "if t61 == t62 then 'RpnCalc_handle_if_true_3_30' else 'RpnCalc_handle_if_else_3_31'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_3_31)], resolved: None }
40 ef 18 08 
# RpnCalc_handle_if_true_3_30
# 817db Instruction { source: "t63 <- b U32", opcode: Copy32, args: [Register(0x14), Register(0x14)], resolved: None }
81 14 14 
# 817de Instruction { source: "t64 <- a U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 817e1 Instruction { source: "Arg0[a]=t63 Some(quotient) <= call div32(t63,t64,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# 817e4 Instruction { source: "Arg1[b]=t64 Some(quotient) <= call div32(t63,t64,)", opcode: Copy32, args: [Register(0x10), Register(0x04)], resolved: None }
81 10 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 160, 161, 162, 163, 164, 168, 169, 170, 171, 172, 173, 174, 175, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225, 252, 253, 254, 255}
# Registers to save: [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 36, 40, 44, 45, 46, 47]
# 817e7 Instruction { source: "Saving reg0x2f before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x2f)], resolved: None }
14 2f 
# 817e9 Instruction { source: "Saving reg0x2e before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x2e)], resolved: None }
14 2e 
# 817eb Instruction { source: "Saving reg0x2d before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x2d)], resolved: None }
14 2d 
# 817ed Instruction { source: "Saving reg0x2c before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x2c)], resolved: None }
14 2c 
# 817ef Instruction { source: "Saving reg0x28 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x28)], resolved: None }
14 28 
# 817f1 Instruction { source: "Saving reg0x24 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x24)], resolved: None }
14 24 
# 817f3 Instruction { source: "Saving reg0x20 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x20)], resolved: None }
14 20 
# 817f5 Instruction { source: "Saving reg0x1d before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x1d)], resolved: None }
14 1d 
# 817f7 Instruction { source: "Saving reg0x1c before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x1c)], resolved: None }
14 1c 
# 817f9 Instruction { source: "Saving reg0x1b before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x1b)], resolved: None }
14 1b 
# 817fb Instruction { source: "Saving reg0x1a before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x1a)], resolved: None }
14 1a 
# 817fd Instruction { source: "Saving reg0x19 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x19)], resolved: None }
14 19 
# 817ff Instruction { source: "Saving reg0x18 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x18)], resolved: None }
14 18 
# 81801 Instruction { source: "Saving reg0x17 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x17)], resolved: None }
14 17 
# 81803 Instruction { source: "Saving reg0x16 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x16)], resolved: None }
14 16 
# 81805 Instruction { source: "Saving reg0x15 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x15)], resolved: None }
14 15 
# 81807 Instruction { source: "Saving reg0x14 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x14)], resolved: None }
14 14 
# 81809 Instruction { source: "Saving reg0x13 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x13)], resolved: None }
14 13 
# 8180b Instruction { source: "Saving reg0x12 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x12)], resolved: None }
14 12 
# 8180d Instruction { source: "Saving reg0x11 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x11)], resolved: None }
14 11 
# 8180f Instruction { source: "Saving reg0x10 before Some(quotient) <= call div32(t63,t64,)", opcode: Push8, args: [Register(0x10)], resolved: None }
14 10 
# 81811 Instruction { source: "PseudoCall(Label24(:div32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81817 Instruction { source: "PseudoCall(Label24(:div32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 21 18 08 00 
# 8181d Instruction { source: "PseudoCall(Label24(:div32))", opcode: JmpImm, args: [Label24(:div32)], resolved: None }
40 f5 1e 08 
# 81821 Instruction { source: "PseudoCall(Label24(:div32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81827 Instruction { source: "Restoring reg0x10 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x10)], resolved: None }
15 10 
# 81829 Instruction { source: "Restoring reg0x11 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x11)], resolved: None }
15 11 
# 8182b Instruction { source: "Restoring reg0x12 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x12)], resolved: None }
15 12 
# 8182d Instruction { source: "Restoring reg0x13 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x13)], resolved: None }
15 13 
# 8182f Instruction { source: "Restoring reg0x14 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x14)], resolved: None }
15 14 
# 81831 Instruction { source: "Restoring reg0x15 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x15)], resolved: None }
15 15 
# 81833 Instruction { source: "Restoring reg0x16 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x16)], resolved: None }
15 16 
# 81835 Instruction { source: "Restoring reg0x17 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x17)], resolved: None }
15 17 
# 81837 Instruction { source: "Restoring reg0x18 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x18)], resolved: None }
15 18 
# 81839 Instruction { source: "Restoring reg0x19 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x19)], resolved: None }
15 19 
# 8183b Instruction { source: "Restoring reg0x1a after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x1a)], resolved: None }
15 1a 
# 8183d Instruction { source: "Restoring reg0x1b after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x1b)], resolved: None }
15 1b 
# 8183f Instruction { source: "Restoring reg0x1c after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x1c)], resolved: None }
15 1c 
# 81841 Instruction { source: "Restoring reg0x1d after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x1d)], resolved: None }
15 1d 
# 81843 Instruction { source: "Restoring reg0x20 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x20)], resolved: None }
15 20 
# 81845 Instruction { source: "Restoring reg0x24 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x24)], resolved: None }
15 24 
# 81847 Instruction { source: "Restoring reg0x28 after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x28)], resolved: None }
15 28 
# 81849 Instruction { source: "Restoring reg0x2c after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x2c)], resolved: None }
15 2c 
# 8184b Instruction { source: "Restoring reg0x2d after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x2d)], resolved: None }
15 2d 
# 8184d Instruction { source: "Restoring reg0x2e after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x2e)], resolved: None }
15 2e 
# 8184f Instruction { source: "Restoring reg0x2f after Some(quotient) <= call div32(t63,t64,)", opcode: Pop8, args: [Register(0x2f)], resolved: None }
15 2f 
# 81851 Instruction { source: "Some(quotient) <= call div32(t63,t64,)", opcode: Copy32, args: [Register(0x00), Register(0x10)], resolved: None }
81 00 10 
# 81854 Instruction { source: "t66 <- quotient U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 81857 Instruction { source: "Arg0[a]=t66 None <= call print_dec32(t66,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 160, 161, 162, 163, 164, 168, 169, 170, 171, 172, 173, 174, 175, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 252, 253, 254, 255}
# Registers to save: [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 36, 40, 44, 45, 46, 47]
# 8185a Instruction { source: "Saving reg0x2f before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x2f)], resolved: None }
14 2f 
# 8185c Instruction { source: "Saving reg0x2e before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x2e)], resolved: None }
14 2e 
# 8185e Instruction { source: "Saving reg0x2d before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x2d)], resolved: None }
14 2d 
# 81860 Instruction { source: "Saving reg0x2c before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x2c)], resolved: None }
14 2c 
# 81862 Instruction { source: "Saving reg0x28 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x28)], resolved: None }
14 28 
# 81864 Instruction { source: "Saving reg0x24 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x24)], resolved: None }
14 24 
# 81866 Instruction { source: "Saving reg0x20 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x20)], resolved: None }
14 20 
# 81868 Instruction { source: "Saving reg0x1d before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x1d)], resolved: None }
14 1d 
# 8186a Instruction { source: "Saving reg0x1c before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x1c)], resolved: None }
14 1c 
# 8186c Instruction { source: "Saving reg0x1b before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x1b)], resolved: None }
14 1b 
# 8186e Instruction { source: "Saving reg0x1a before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x1a)], resolved: None }
14 1a 
# 81870 Instruction { source: "Saving reg0x19 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x19)], resolved: None }
14 19 
# 81872 Instruction { source: "Saving reg0x18 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x18)], resolved: None }
14 18 
# 81874 Instruction { source: "Saving reg0x17 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x17)], resolved: None }
14 17 
# 81876 Instruction { source: "Saving reg0x16 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x16)], resolved: None }
14 16 
# 81878 Instruction { source: "Saving reg0x15 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x15)], resolved: None }
14 15 
# 8187a Instruction { source: "Saving reg0x14 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x14)], resolved: None }
14 14 
# 8187c Instruction { source: "Saving reg0x13 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x13)], resolved: None }
14 13 
# 8187e Instruction { source: "Saving reg0x12 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x12)], resolved: None }
14 12 
# 81880 Instruction { source: "Saving reg0x11 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x11)], resolved: None }
14 11 
# 81882 Instruction { source: "Saving reg0x10 before None <= call print_dec32(t66,)", opcode: Push8, args: [Register(0x10)], resolved: None }
14 10 
# 81884 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8188a Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 94 18 08 00 
# 81890 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: JmpImm, args: [Label24(:print_dec32)], resolved: None }
40 22 27 08 
# 81894 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8189a Instruction { source: "Restoring reg0x10 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x10)], resolved: None }
15 10 
# 8189c Instruction { source: "Restoring reg0x11 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x11)], resolved: None }
15 11 
# 8189e Instruction { source: "Restoring reg0x12 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x12)], resolved: None }
15 12 
# 818a0 Instruction { source: "Restoring reg0x13 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x13)], resolved: None }
15 13 
# 818a2 Instruction { source: "Restoring reg0x14 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x14)], resolved: None }
15 14 
# 818a4 Instruction { source: "Restoring reg0x15 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x15)], resolved: None }
15 15 
# 818a6 Instruction { source: "Restoring reg0x16 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x16)], resolved: None }
15 16 
# 818a8 Instruction { source: "Restoring reg0x17 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x17)], resolved: None }
15 17 
# 818aa Instruction { source: "Restoring reg0x18 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x18)], resolved: None }
15 18 
# 818ac Instruction { source: "Restoring reg0x19 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x19)], resolved: None }
15 19 
# 818ae Instruction { source: "Restoring reg0x1a after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x1a)], resolved: None }
15 1a 
# 818b0 Instruction { source: "Restoring reg0x1b after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x1b)], resolved: None }
15 1b 
# 818b2 Instruction { source: "Restoring reg0x1c after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x1c)], resolved: None }
15 1c 
# 818b4 Instruction { source: "Restoring reg0x1d after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x1d)], resolved: None }
15 1d 
# 818b6 Instruction { source: "Restoring reg0x20 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x20)], resolved: None }
15 20 
# 818b8 Instruction { source: "Restoring reg0x24 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x24)], resolved: None }
15 24 
# 818ba Instruction { source: "Restoring reg0x28 after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x28)], resolved: None }
15 28 
# 818bc Instruction { source: "Restoring reg0x2c after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x2c)], resolved: None }
15 2c 
# 818be Instruction { source: "Restoring reg0x2d after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x2d)], resolved: None }
15 2d 
# 818c0 Instruction { source: "Restoring reg0x2e after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x2e)], resolved: None }
15 2e 
# 818c2 Instruction { source: "Restoring reg0x2f after None <= call print_dec32(t66,)", opcode: Pop8, args: [Register(0x2f)], resolved: None }
15 2f 
# 818c4 Instruction { source: "t67 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x0a=10)], resolved: None }
00 2d 0a 
# 818c7 Instruction { source: "ttyout <- t67", opcode: TtyOut, args: [Register(0x2d)], resolved: None }
13 2d 
# 818c9 Instruction { source: "t69 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x14)], resolved: None }
81 20 14 
# 818cc Instruction { source: "t70 <- quotient U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 818cf Instruction { source: "Arg0[s]=t69 None <= call stack_push(t69,t70,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# 818d2 Instruction { source: "Arg1[n]=t70 None <= call stack_push(t69,t70,)", opcode: Copy32, args: [Register(0x10), Register(0x04)], resolved: None }
81 10 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195}
# Registers to save: []
# 818d5 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 818db Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c e5 18 08 00 
# 818e1 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 c4 2b 08 
# 818e5 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 818eb Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 ac 1b 08 
# RpnCalc_handle_if_else_3_31
# 818ef Instruction { source: "t71 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1c)], resolved: None }
16 1c 1c 
# 818f2 Instruction { source: "t72 <- 0n115/0x73u8 ", opcode: LoadImm8, args: [Register(0x2c), Constant8(0x73=115)], resolved: None }
00 2c 73 
# 818f5 Instruction { source: "if t71 == t72 then 'RpnCalc_handle_if_true_4_32' else 'RpnCalc_handle_if_else_4_33'", opcode: Cmp8, args: [Register(0x1c), Register(0x2c)], resolved: None }
25 1c 2c 
# 818f8 Instruction { source: "if t71 == t72 then 'RpnCalc_handle_if_true_4_32' else 'RpnCalc_handle_if_else_4_33'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_4_32)], resolved: None }
42 00 19 08 
# 818fc Instruction { source: "if t71 == t72 then 'RpnCalc_handle_if_true_4_32' else 'RpnCalc_handle_if_else_4_33'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_4_33)], resolved: None }
40 48 19 08 
# RpnCalc_handle_if_true_4_32
# 81900 Instruction { source: "t74 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x18)], resolved: None }
81 20 18 
# 81903 Instruction { source: "t75 <- a U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 81906 Instruction { source: "Arg0[s]=t74 None <= call stack_push(t74,t75,)", opcode: Copy32, args: [Register(0x18), Register(0x00)], resolved: None }
81 18 00 
# 81909 Instruction { source: "Arg1[n]=t75 None <= call stack_push(t74,t75,)", opcode: Copy32, args: [Register(0x10), Register(0x04)], resolved: None }
81 10 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195}
# Registers to save: []
# 8190c Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81912 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 1c 19 08 00 
# 81918 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 c4 2b 08 
# 8191c Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81922 Instruction { source: "t77 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x10)], resolved: None }
81 20 10 
# 81925 Instruction { source: "t78 <- b U32", opcode: Copy32, args: [Register(0x14), Register(0x14)], resolved: None }
81 14 14 
# 81928 Instruction { source: "Arg0[s]=t77 None <= call stack_push(t77,t78,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# 8192b Instruction { source: "Arg1[n]=t78 None <= call stack_push(t77,t78,)", opcode: Copy32, args: [Register(0x14), Register(0x04)], resolved: None }
81 14 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195}
# Registers to save: []
# 8192e Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81934 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 3e 19 08 00 
# 8193a Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 c4 2b 08 
# 8193e Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81944 Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 ac 1b 08 
# RpnCalc_handle_if_else_4_33
# 81948 Instruction { source: "t79 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1d)], resolved: None }
16 1c 1d 
# 8194b Instruction { source: "t80 <- 0n113/0x71u8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x71=113)], resolved: None }
00 2d 71 
# 8194e Instruction { source: "if t79 == t80 then 'RpnCalc_handle_if_true_5_34' else 'RpnCalc_handle_if_else_5_35'", opcode: Cmp8, args: [Register(0x1d), Register(0x2d)], resolved: None }
25 1d 2d 
# 81951 Instruction { source: "if t79 == t80 then 'RpnCalc_handle_if_true_5_34' else 'RpnCalc_handle_if_else_5_35'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_5_34)], resolved: None }
42 59 19 08 
# 81955 Instruction { source: "if t79 == t80 then 'RpnCalc_handle_if_true_5_34' else 'RpnCalc_handle_if_else_5_35'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_5_35)], resolved: None }
40 65 19 08 
# RpnCalc_handle_if_true_5_34
# 81959 Instruction { source: "t81 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x1d), Constant8(0x00=0)], resolved: None }
00 1d 00 
# 8195c Instruction { source: "return Some(t81)", opcode: Copy8, args: [Register(0x1d), Register(0x00)], resolved: None }
16 1d 00 
# 8195f Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81961 Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 ac 1b 08 
# RpnCalc_handle_if_else_5_35
# 81965 Instruction { source: "t82 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1d)], resolved: None }
16 1c 1d 
# 81968 Instruction { source: "t83 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x0a=10)], resolved: None }
00 2d 0a 
# 8196b Instruction { source: "if t82 == t83 then 'RpnCalc_handle_if_true_6_36' else 'RpnCalc_handle_if_else_6_37'", opcode: Cmp8, args: [Register(0x1d), Register(0x2d)], resolved: None }
25 1d 2d 
# 8196e Instruction { source: "if t82 == t83 then 'RpnCalc_handle_if_true_6_36' else 'RpnCalc_handle_if_else_6_37'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_6_36)], resolved: None }
42 76 19 08 
# 81972 Instruction { source: "if t82 == t83 then 'RpnCalc_handle_if_true_6_36' else 'RpnCalc_handle_if_else_6_37'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_6_37)], resolved: None }
40 96 19 08 
# RpnCalc_handle_if_true_6_36
# 81976 Instruction { source: "t85 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x10)], resolved: None }
81 18 10 
# 81979 Instruction { source: "Arg0[c]=t85 None <= call RpnCalc_push_pending(t85,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {60, 61, 62, 63, 64, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195}
# Registers to save: []
# 8197c Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81982 Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 8c 19 08 00 
# 81988 Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: JmpImm, args: [Label24(:RpnCalc_push_pending)], resolved: None }
40 fc 1b 08 
# 8198c Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81992 Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 ac 1b 08 
# RpnCalc_handle_if_else_6_37
# 81996 Instruction { source: "t86 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1d)], resolved: None }
16 1c 1d 
# 81999 Instruction { source: "t87 <- 0n32/0x20u8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x20=32)], resolved: None }
00 2d 20 
# 8199c Instruction { source: "if t86 == t87 then 'RpnCalc_handle_if_true_7_38' else 'RpnCalc_handle_if_else_7_39'", opcode: Cmp8, args: [Register(0x1d), Register(0x2d)], resolved: None }
25 1d 2d 
# 8199f Instruction { source: "if t86 == t87 then 'RpnCalc_handle_if_true_7_38' else 'RpnCalc_handle_if_else_7_39'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_7_38)], resolved: None }
42 a7 19 08 
# 819a3 Instruction { source: "if t86 == t87 then 'RpnCalc_handle_if_true_7_38' else 'RpnCalc_handle_if_else_7_39'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_7_39)], resolved: None }
40 c7 19 08 
# RpnCalc_handle_if_true_7_38
# 819a7 Instruction { source: "t89 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x10)], resolved: None }
81 18 10 
# 819aa Instruction { source: "Arg0[c]=t89 None <= call RpnCalc_push_pending(t89,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {60, 61, 62, 63, 64, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195}
# Registers to save: []
# 819ad Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 819b3 Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c bd 19 08 00 
# 819b9 Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: JmpImm, args: [Label24(:RpnCalc_push_pending)], resolved: None }
40 fc 1b 08 
# 819bd Instruction { source: "PseudoCall(Label24(:RpnCalc_push_pending))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 819c3 Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 ac 1b 08 
# RpnCalc_handle_if_else_7_39
# 819c7 Instruction { source: "t90 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1d)], resolved: None }
16 1c 1d 
# 819ca Instruction { source: "t91 <- 0n99/0x63u8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x63=99)], resolved: None }
00 2d 63 
# 819cd Instruction { source: "if t90 == t91 then 'RpnCalc_handle_if_true_8_40' else 'RpnCalc_handle_if_else_8_41'", opcode: Cmp8, args: [Register(0x1d), Register(0x2d)], resolved: None }
25 1d 2d 
# 819d0 Instruction { source: "if t90 == t91 then 'RpnCalc_handle_if_true_8_40' else 'RpnCalc_handle_if_else_8_41'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_8_40)], resolved: None }
42 d8 19 08 
# 819d4 Instruction { source: "if t90 == t91 then 'RpnCalc_handle_if_true_8_40' else 'RpnCalc_handle_if_else_8_41'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_8_41)], resolved: None }
40 f8 19 08 
# RpnCalc_handle_if_true_8_40
# 819d8 Instruction { source: "t93 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x10)], resolved: None }
81 18 10 
# 819db Instruction { source: "Arg0[c]=t93 None <= call RpnCalc_init(t93,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {48, 49, 50, 51, 52, 53, 54, 55, 56, 152, 153, 154, 155, 156, 157, 158, 159}
# Registers to save: []
# 819de Instruction { source: "PseudoCall(Label24(:RpnCalc_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 819e4 Instruction { source: "PseudoCall(Label24(:RpnCalc_init))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c ee 19 08 00 
# 819ea Instruction { source: "PseudoCall(Label24(:RpnCalc_init))", opcode: JmpImm, args: [Label24(:RpnCalc_init)], resolved: None }
40 b9 1b 08 
# 819ee Instruction { source: "PseudoCall(Label24(:RpnCalc_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 819f4 Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 ac 1b 08 
# RpnCalc_handle_if_else_8_41
# 819f8 Instruction { source: "t94 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1d)], resolved: None }
16 1c 1d 
# 819fb Instruction { source: "t95 <- 0n100/0x64u8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x64=100)], resolved: None }
00 2d 64 
# 819fe Instruction { source: "if t94 == t95 then 'RpnCalc_handle_if_true_9_42' else 'RpnCalc_handle_if_else_9_43'", opcode: Cmp8, args: [Register(0x1d), Register(0x2d)], resolved: None }
25 1d 2d 
# 81a01 Instruction { source: "if t94 == t95 then 'RpnCalc_handle_if_true_9_42' else 'RpnCalc_handle_if_else_9_43'", opcode: JzImm, args: [Label24(RpnCalc_handle_if_true_9_42)], resolved: None }
42 09 1a 08 
# 81a05 Instruction { source: "if t94 == t95 then 'RpnCalc_handle_if_true_9_42' else 'RpnCalc_handle_if_else_9_43'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_9_43)], resolved: None }
40 ec 1a 08 
# RpnCalc_handle_if_true_9_42
# 81a09 Instruction { source: "i <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x1d), Constant8(0x00=0)], resolved: None }
00 1d 00 
# RpnCalc_handle_while_predicate_44
# 81a0c Instruction { source: "t96 <- i U8", opcode: Copy8, args: [Register(0x1d), Register(0x1d)], resolved: None }
16 1d 1d 
# 81a0f Instruction { source: "t97 <- stack_count U8", opcode: Copy8, args: [Register(0x24), Register(0x2d)], resolved: None }
16 24 2d 
# 81a12 Instruction { source: "if t96 < t97 then 'RpnCalc_handle_while_body_45' else 'RpnCalc_handle_while_end_46'", opcode: Cmp8, args: [Register(0x2d), Register(0x1d)], resolved: None }
25 2d 1d 
# 81a15 Instruction { source: "if t96 < t97 then 'RpnCalc_handle_while_body_45' else 'RpnCalc_handle_while_end_46'", opcode: JcImm, args: [Label24(RpnCalc_handle_while_end_46)], resolved: None }
41 e8 1a 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t96 < t97 then 'RpnCalc_handle_while_body_45' else 'RpnCalc_handle_while_end_46'", opcode: JmpImm, args: [Label24(RpnCalc_handle_while_body_45)], resolved: None }
# RpnCalc_handle_while_body_45
# 81a19 Instruction { source: "t99 <- i U8", opcode: Copy8, args: [Register(0x1d), Register(0x1d)], resolved: None }
16 1d 1d 
# 81a1c Instruction { source: "Arg0[a]=t99 None <= call print_dec8(t99,)", opcode: Copy8, args: [Register(0x1d), Register(0x00)], resolved: None }
16 1d 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {101, 102, 103}
# Registers to save: []
# 81a1f Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81a25 Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 2f 1a 08 00 
# 81a2b Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: JmpImm, args: [Label24(:print_dec8)], resolved: None }
40 90 28 08 
# 81a2f Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81a35 Instruction { source: "t100 <- 0n58/0x3au8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x3a=58)], resolved: None }
00 2d 3a 
# 81a38 Instruction { source: "ttyout <- t100", opcode: TtyOut, args: [Register(0x2d)], resolved: None }
13 2d 
# 81a3a Instruction { source: "t103 <- stack U32", opcode: Copy32, args: [Register(0x20), Register(0x14)], resolved: None }
81 20 14 
# 81a3d Instruction { source: "t105 <- i U8", opcode: Copy8, args: [Register(0x1d), Register(0x1d)], resolved: None }
16 1d 1d 
# 81a40 Instruction { source: "Zero-pad for t104 U32 <- t105 U8", opcode: LoadImm32, args: [Register(0x18), Constant32(0x00000000=0)], resolved: None }
80 18 00 00 00 00 
# 81a46 Instruction { source: "t104 U32 <- t105 U8", opcode: Copy8, args: [Register(0x1d), Register(0x18)], resolved: None }
16 1d 18 
# 81a49 Instruction { source: "Arg0[s]=t103 Some(t102) <= call stack_get(t103,t104,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# 81a4c Instruction { source: "Arg1[n]=t104 Some(t102) <= call stack_get(t103,t104,)", opcode: Copy32, args: [Register(0x18), Register(0x04)], resolved: None }
81 18 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151}
# Registers to save: []
# 81a4f Instruction { source: "PseudoCall(Label24(:stack_get))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81a55 Instruction { source: "PseudoCall(Label24(:stack_get))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 5f 1a 08 00 
# 81a5b Instruction { source: "PseudoCall(Label24(:stack_get))", opcode: JmpImm, args: [Label24(:stack_get)], resolved: None }
40 f1 2a 08 
# 81a5f Instruction { source: "PseudoCall(Label24(:stack_get))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81a65 Instruction { source: "Some(t102) <= call stack_get(t103,t104,)", opcode: Copy32, args: [Register(0x00), Register(0x14)], resolved: None }
81 00 14 
# 81a68 Instruction { source: "Arg0[a]=t102 None <= call print_dec32(t102,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 160, 161, 162, 163, 164, 168, 169, 170, 171, 172, 173, 174, 175, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 252, 253, 254, 255}
# Registers to save: [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 36, 40, 44, 45, 46, 47]
# 81a6b Instruction { source: "Saving reg0x2f before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x2f)], resolved: None }
14 2f 
# 81a6d Instruction { source: "Saving reg0x2e before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x2e)], resolved: None }
14 2e 
# 81a6f Instruction { source: "Saving reg0x2d before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x2d)], resolved: None }
14 2d 
# 81a71 Instruction { source: "Saving reg0x2c before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x2c)], resolved: None }
14 2c 
# 81a73 Instruction { source: "Saving reg0x28 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x28)], resolved: None }
14 28 
# 81a75 Instruction { source: "Saving reg0x24 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x24)], resolved: None }
14 24 
# 81a77 Instruction { source: "Saving reg0x20 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x20)], resolved: None }
14 20 
# 81a79 Instruction { source: "Saving reg0x1d before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x1d)], resolved: None }
14 1d 
# 81a7b Instruction { source: "Saving reg0x1c before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x1c)], resolved: None }
14 1c 
# 81a7d Instruction { source: "Saving reg0x1b before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x1b)], resolved: None }
14 1b 
# 81a7f Instruction { source: "Saving reg0x1a before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x1a)], resolved: None }
14 1a 
# 81a81 Instruction { source: "Saving reg0x19 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x19)], resolved: None }
14 19 
# 81a83 Instruction { source: "Saving reg0x18 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x18)], resolved: None }
14 18 
# 81a85 Instruction { source: "Saving reg0x17 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x17)], resolved: None }
14 17 
# 81a87 Instruction { source: "Saving reg0x16 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x16)], resolved: None }
14 16 
# 81a89 Instruction { source: "Saving reg0x15 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x15)], resolved: None }
14 15 
# 81a8b Instruction { source: "Saving reg0x14 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x14)], resolved: None }
14 14 
# 81a8d Instruction { source: "Saving reg0x13 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x13)], resolved: None }
14 13 
# 81a8f Instruction { source: "Saving reg0x12 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x12)], resolved: None }
14 12 
# 81a91 Instruction { source: "Saving reg0x11 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x11)], resolved: None }
14 11 
# 81a93 Instruction { source: "Saving reg0x10 before None <= call print_dec32(t102,)", opcode: Push8, args: [Register(0x10)], resolved: None }
14 10 
# 81a95 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81a9b Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c a5 1a 08 00 
# 81aa1 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: JmpImm, args: [Label24(:print_dec32)], resolved: None }
40 22 27 08 
# 81aa5 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81aab Instruction { source: "Restoring reg0x10 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x10)], resolved: None }
15 10 
# 81aad Instruction { source: "Restoring reg0x11 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x11)], resolved: None }
15 11 
# 81aaf Instruction { source: "Restoring reg0x12 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x12)], resolved: None }
15 12 
# 81ab1 Instruction { source: "Restoring reg0x13 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x13)], resolved: None }
15 13 
# 81ab3 Instruction { source: "Restoring reg0x14 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x14)], resolved: None }
15 14 
# 81ab5 Instruction { source: "Restoring reg0x15 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x15)], resolved: None }
15 15 
# 81ab7 Instruction { source: "Restoring reg0x16 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x16)], resolved: None }
15 16 
# 81ab9 Instruction { source: "Restoring reg0x17 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x17)], resolved: None }
15 17 
# 81abb Instruction { source: "Restoring reg0x18 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x18)], resolved: None }
15 18 
# 81abd Instruction { source: "Restoring reg0x19 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x19)], resolved: None }
15 19 
# 81abf Instruction { source: "Restoring reg0x1a after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x1a)], resolved: None }
15 1a 
# 81ac1 Instruction { source: "Restoring reg0x1b after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x1b)], resolved: None }
15 1b 
# 81ac3 Instruction { source: "Restoring reg0x1c after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x1c)], resolved: None }
15 1c 
# 81ac5 Instruction { source: "Restoring reg0x1d after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x1d)], resolved: None }
15 1d 
# 81ac7 Instruction { source: "Restoring reg0x20 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x20)], resolved: None }
15 20 
# 81ac9 Instruction { source: "Restoring reg0x24 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x24)], resolved: None }
15 24 
# 81acb Instruction { source: "Restoring reg0x28 after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x28)], resolved: None }
15 28 
# 81acd Instruction { source: "Restoring reg0x2c after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x2c)], resolved: None }
15 2c 
# 81acf Instruction { source: "Restoring reg0x2d after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x2d)], resolved: None }
15 2d 
# 81ad1 Instruction { source: "Restoring reg0x2e after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x2e)], resolved: None }
15 2e 
# 81ad3 Instruction { source: "Restoring reg0x2f after None <= call print_dec32(t102,)", opcode: Pop8, args: [Register(0x2f)], resolved: None }
15 2f 
# 81ad5 Instruction { source: "t106 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x0a=10)], resolved: None }
00 2d 0a 
# 81ad8 Instruction { source: "ttyout <- t106", opcode: TtyOut, args: [Register(0x2d)], resolved: None }
13 2d 
# 81ada Instruction { source: "t107 <- i U8", opcode: Copy8, args: [Register(0x1d), Register(0x1d)], resolved: None }
16 1d 1d 
# 81add Instruction { source: "t108 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x01=1)], resolved: None }
00 2d 01 
# 81ae0 Instruction { source: "i <- t107 Add t108", opcode: Add8NoCarryIn, args: [Register(0x1d), Register(0x2d), Register(0x1d)], resolved: None }
24 1d 2d 1d 
# 81ae4 Instruction { source: "goto RpnCalc_handle_while_predicate_44", opcode: JmpImm, args: [Label24(RpnCalc_handle_while_predicate_44)], resolved: None }
40 0c 1a 08 
# RpnCalc_handle_while_end_46
# 81ae8 Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 ac 1b 08 
# RpnCalc_handle_if_else_9_43
# 81aec Instruction { source: "t109 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1d)], resolved: None }
16 1c 1d 
# 81aef Instruction { source: "t110 <- 0n57/0x39u8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x39=57)], resolved: None }
00 2d 39 
# 81af2 Instruction { source: "if t109 <= t110 then 'RpnCalc_handle_if_true_10_47' else 'RpnCalc_handle_if_else_10_48'", opcode: Cmp8, args: [Register(0x1d), Register(0x2d)], resolved: None }
25 1d 2d 
# 81af5 Instruction { source: "if t109 <= t110 then 'RpnCalc_handle_if_true_10_47' else 'RpnCalc_handle_if_else_10_48'", opcode: JcImm, args: [Label24(RpnCalc_handle_if_true_10_47)], resolved: None }
41 fd 1a 08 
# 81af9 Instruction { source: "if t109 <= t110 then 'RpnCalc_handle_if_true_10_47' else 'RpnCalc_handle_if_else_10_48'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_10_48)], resolved: None }
40 ac 1b 08 
# RpnCalc_handle_if_true_10_47
# 81afd Instruction { source: "t111 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x1d)], resolved: None }
16 1c 1d 
# 81b00 Instruction { source: "t112 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x30=48)], resolved: None }
00 2d 30 
# 81b03 Instruction { source: "if t111 >= t112 then 'RpnCalc_handle_if_true_0_50' else 'RpnCalc_handle_if_else_0_51'", opcode: Cmp8, args: [Register(0x2d), Register(0x1d)], resolved: None }
25 2d 1d 
# 81b06 Instruction { source: "if t111 >= t112 then 'RpnCalc_handle_if_true_0_50' else 'RpnCalc_handle_if_else_0_51'", opcode: JcImm, args: [Label24(RpnCalc_handle_if_true_0_50)], resolved: None }
41 0e 1b 08 
# 81b0a Instruction { source: "if t111 >= t112 then 'RpnCalc_handle_if_true_0_50' else 'RpnCalc_handle_if_else_0_51'", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_else_0_51)], resolved: None }
40 a8 1b 08 
# RpnCalc_handle_if_true_0_50
# 81b0e Instruction { source: "t114 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x10)], resolved: None }
81 18 10 
# 81b11 Instruction { source: "t115 <- 0n72/0x00000048u32 ", opcode: LoadImm32, args: [Register(0x14), Constant32(0x00000048=72)], resolved: None }
80 14 48 00 00 00 
# 81b17 Instruction { source: "t113 <- t114 Add t115", opcode: Add32NoCarryIn, args: [Register(0x10), Register(0x14), Register(0x10)], resolved: None }
a0 10 14 10 
# 81b1b Instruction { source: "t116 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x2d), Constant8(0x01=1)], resolved: None }
00 2d 01 
# 81b1e Instruction { source: "mem[t113] <- t116 U8", opcode: Store8, args: [Register(0x2d), Register(0x10)], resolved: None }
11 2d 10 
# 81b21 Instruction { source: "t118 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x10)], resolved: None }
81 18 10 
# 81b24 Instruction { source: "t119 <- 0n68/0x00000044u32 ", opcode: LoadImm32, args: [Register(0x14), Constant32(0x00000044=68)], resolved: None }
80 14 44 00 00 00 
# 81b2a Instruction { source: "t117 <- t118 Add t119", opcode: Add32NoCarryIn, args: [Register(0x10), Register(0x14), Register(0x10)], resolved: None }
a0 10 14 10 
# 81b2e Instruction { source: "t123 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x14)], resolved: None }
81 18 14 
# 81b31 Instruction { source: "t124 <- 0n68/0x00000044u32 ", opcode: LoadImm32, args: [Register(0x20), Constant32(0x00000044=68)], resolved: None }
80 20 44 00 00 00 
# 81b37 Instruction { source: "t122 <- t123 Add t124", opcode: Add32NoCarryIn, args: [Register(0x14), Register(0x20), Register(0x14)], resolved: None }
a0 14 20 14 
# 81b3b Instruction { source: "t121 <- mem[t122] U32", opcode: Load32, args: [Register(0x14), Register(0x14)], resolved: None }
90 14 14 
# 81b3e Instruction { source: "t125 <- 0n10/0x0000000au32 ", opcode: LoadImm32, args: [Register(0x20), Constant32(0x0000000a=10)], resolved: None }
80 20 0a 00 00 00 
# 81b44 Instruction { source: "Arg0[a]=t121 Some(t120) <= call mul32_32(t121,t125,)", opcode: Copy32, args: [Register(0x14), Register(0x00)], resolved: None }
81 14 00 
# 81b47 Instruction { source: "Arg1[b]=t125 Some(t120) <= call mul32_32(t121,t125,)", opcode: Copy32, args: [Register(0x20), Register(0x04)], resolved: None }
81 20 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45, 46, 47}
# Registers used by callee tree: {200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250}
# Registers to save: []
# 81b4a Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81b50 Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 5a 1b 08 00 
# 81b56 Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: JmpImm, args: [Label24(:mul32_32)], resolved: None }
40 25 24 08 
# 81b5a Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81b60 Instruction { source: "Some(t120) <= call mul32_32(t121,t125,)", opcode: Copy32, args: [Register(0x00), Register(0x14)], resolved: None }
81 00 14 
# 81b63 Instruction { source: "mem[t117] <- t120 U32", opcode: Store32_1, args: [Register(0x14), Register(0x10)], resolved: None }
92 14 10 
# 81b66 Instruction { source: "mem[t117] <- t120 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 81b67 Instruction { source: "t127 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x10)], resolved: None }
81 18 10 
# 81b6a Instruction { source: "t128 <- 0n68/0x00000044u32 ", opcode: LoadImm32, args: [Register(0x14), Constant32(0x00000044=68)], resolved: None }
80 14 44 00 00 00 
# 81b70 Instruction { source: "t126 <- t127 Add t128", opcode: Add32NoCarryIn, args: [Register(0x10), Register(0x14), Register(0x10)], resolved: None }
a0 10 14 10 
# 81b74 Instruction { source: "t132 <- c U32", opcode: Copy32, args: [Register(0x18), Register(0x14)], resolved: None }
81 18 14 
# 81b77 Instruction { source: "t133 <- 0n68/0x00000044u32 ", opcode: LoadImm32, args: [Register(0x18), Constant32(0x00000044=68)], resolved: None }
80 18 44 00 00 00 
# 81b7d Instruction { source: "t131 <- t132 Add t133", opcode: Add32NoCarryIn, args: [Register(0x14), Register(0x18), Register(0x14)], resolved: None }
a0 14 18 14 
# 81b81 Instruction { source: "t130 <- mem[t131] U32", opcode: Load32, args: [Register(0x14), Register(0x14)], resolved: None }
90 14 14 
# 81b84 Instruction { source: "t136 <- ch U8", opcode: Copy8, args: [Register(0x1c), Register(0x2f)], resolved: None }
16 1c 2f 
# 81b87 Instruction { source: "t137 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x1c), Constant8(0x30=48)], resolved: None }
00 1c 30 
# 81b8a Instruction { source: "t135 <- t136 Subtract t137", opcode: Copy8, args: [Register(0x1c), Register(0x00)], resolved: None }
16 1c 00 
# 81b8d Instruction { source: "t135 <- t136 Subtract t137", opcode: Negate8, args: [Register(0x00)], resolved: None }
04 00 
# 81b8f Instruction { source: "t135 <- t136 Subtract t137", opcode: Add8NoCarryIn, args: [Register(0x2f), Register(0x00), Register(0x2f)], resolved: None }
24 2f 00 2f 
# 81b93 Instruction { source: "Zero-pad for t134 U32 <- t135 U8", opcode: LoadImm32, args: [Register(0x18), Constant32(0x00000000=0)], resolved: None }
80 18 00 00 00 00 
# 81b99 Instruction { source: "t134 U32 <- t135 U8", opcode: Copy8, args: [Register(0x2f), Register(0x18)], resolved: None }
16 2f 18 
# 81b9c Instruction { source: "t129 <- t130 Add t134", opcode: Add32NoCarryIn, args: [Register(0x14), Register(0x18), Register(0x14)], resolved: None }
a0 14 18 14 
# 81ba0 Instruction { source: "mem[t126] <- t129 U32", opcode: Store32_1, args: [Register(0x14), Register(0x10)], resolved: None }
92 14 10 
# 81ba3 Instruction { source: "mem[t126] <- t129 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 81ba4 Instruction { source: "goto RpnCalc_handle_if_end_49", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_49)], resolved: None }
40 a8 1b 08 
# RpnCalc_handle_if_else_0_51
# RpnCalc_handle_if_end_49
# 81ba8 Instruction { source: "goto RpnCalc_handle_if_end_23", opcode: JmpImm, args: [Label24(RpnCalc_handle_if_end_23)], resolved: None }
40 ac 1b 08 
# RpnCalc_handle_if_else_10_48
# RpnCalc_handle_if_end_23
# 81bac Instruction { source: "t138 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x1d), Constant8(0x01=1)], resolved: None }
00 1d 01 
# 81baf Instruction { source: "return Some(t138)", opcode: Copy8, args: [Register(0x1d), Register(0x00)], resolved: None }
16 1d 00 
# 81bb2 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81bb4 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :RpnCalc_init
# Ret None
# Arg0=c
# Var c (Arg0 c Ptr(Struct("RpnCalc"))) U32 Some([48, 49, 50, 51])
# Var s (Local s Ptr(Struct("Stack")) U32) U32 Some([52, 53, 54, 55])
# Var t0 (t0 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Struct("Stack")), value: Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") } }) U32 Some([48, 49, 50, 51])
# Var t1 (t1 Call(Call { function: "stack_init", parameters: [Ident("s")] })) U8 Some([56])
# Var t2 (t2 Ident("s")) U32 Some([52, 53, 54, 55])
# Var t3 (t3 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 68)) }) U32 Some([48, 49, 50, 51])
# Var t4 (t4 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([48, 49, 50, 51])
# Var t5 (t5 Number(USIZE, 68)) U32 Some([52, 53, 54, 55])
# Var t6 (t6 Number(USIZE, 0)) U32 Some([52, 53, 54, 55])
# 81bb9 Instruction { source: "Save function parameter 'c' registers [0, 1, 2, 3] to locals [48, 49, 50, 51].", opcode: Copy32, args: [Register(0x00), Register(0x30)], resolved: None }
81 00 30 
# 81bbc Instruction { source: "t0 <- c U32", opcode: Copy32, args: [Register(0x30), Register(0x30)], resolved: None }
81 30 30 
# 81bbf Instruction { source: "s <- t0 U32", opcode: Copy32, args: [Register(0x30), Register(0x34)], resolved: None }
81 30 34 
# 81bc2 Instruction { source: "t2 <- s U32", opcode: Copy32, args: [Register(0x34), Register(0x34)], resolved: None }
81 34 34 
# 81bc5 Instruction { source: "Arg0[s]=t2 None <= call stack_init(t2,)", opcode: Copy32, args: [Register(0x34), Register(0x00)], resolved: None }
81 34 00 
# Registers used by this function: {48, 49, 50, 51, 52, 53, 54, 55, 56}
# Registers used by callee tree: {152, 153, 154, 155, 156, 157, 158, 159}
# Registers to save: []
# 81bc8 Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81bce Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c d8 1b 08 00 
# 81bd4 Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: JmpImm, args: [Label24(:stack_init)], resolved: None }
40 27 2b 08 
# 81bd8 Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81bde Instruction { source: "t4 <- c U32", opcode: Copy32, args: [Register(0x30), Register(0x30)], resolved: None }
81 30 30 
# 81be1 Instruction { source: "t5 <- 0n68/0x00000044u32 ", opcode: LoadImm32, args: [Register(0x34), Constant32(0x00000044=68)], resolved: None }
80 34 44 00 00 00 
# 81be7 Instruction { source: "t3 <- t4 Add t5", opcode: Add32NoCarryIn, args: [Register(0x30), Register(0x34), Register(0x30)], resolved: None }
a0 30 34 30 
# 81beb Instruction { source: "t6 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x34), Constant32(0x00000000=0)], resolved: None }
80 34 00 00 00 00 
# 81bf1 Instruction { source: "mem[t3] <- t6 U32", opcode: Store32_1, args: [Register(0x34), Register(0x30)], resolved: None }
92 34 30 
# 81bf4 Instruction { source: "mem[t3] <- t6 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 81bf5 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81bf7 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :RpnCalc_push_pending
# Ret None
# Arg0=c
# Var c (Arg0 c Ptr(Struct("RpnCalc"))) U32 Some([60, 61, 62, 63])
# Var t0 (t0 PtrFieldDeref("c", "have_num")) U8 Some([64])
# Var t1 (t1 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 72)) }) U32 Some([68, 69, 70, 71])
# Var t10 (t10 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([60, 61, 62, 63])
# Var t11 (t11 Number(USIZE, 68)) U32 Some([68, 69, 70, 71])
# Var t12 (t12 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 68)) }) U32 Some([68, 69, 70, 71])
# Var t13 (t13 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([60, 61, 62, 63])
# Var t14 (t14 Number(USIZE, 68)) U32 Some([68, 69, 70, 71])
# Var t15 (t15 Number(USIZE, 0)) U32 Some([72, 73, 74, 75])
# Var t16 (t16 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 72)) }) U32 Some([60, 61, 62, 63])
# Var t17 (t17 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([60, 61, 62, 63])
# Var t18 (t18 Number(USIZE, 72)) U32 Some([68, 69, 70, 71])
# Var t19 (t19 Number(U8, 0)) U8 Some([64])
# Var t2 (t2 Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([60, 61, 62, 63])
# Var t3 (t3 Number(USIZE, 72)) U32 Some([68, 69, 70, 71])
# Var t4 (t4 Number(U8, 0)) U8 Some([76])
# Var t5 (t5 Call(Call { function: "stack_push", parameters: [AddressOf(PtrFieldDeref("c", "stack")), PtrFieldDeref("c", "num")] })) U8 Some([77])
# Var t6 (t6 AddressOf(PtrFieldDeref("c", "stack"))) U32 Some([72, 73, 74, 75])
# Var t7 (t7 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Struct("Stack")), value: Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") } }) U32 Some([60, 61, 62, 63])
# Var t8 (t8 PtrFieldDeref("c", "num")) U32 Some([68, 69, 70, 71])
# Var t9 (t9 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("RpnCalc"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 68)) }) U32 Some([68, 69, 70, 71])
# 81bfc Instruction { source: "Save function parameter 'c' registers [0, 1, 2, 3] to locals [60, 61, 62, 63].", opcode: Copy32, args: [Register(0x00), Register(0x3c)], resolved: None }
81 00 3c 
# 81bff Instruction { source: "t2 <- c U32", opcode: Copy32, args: [Register(0x3c), Register(0x3c)], resolved: None }
81 3c 3c 
# 81c02 Instruction { source: "t3 <- 0n72/0x00000048u32 ", opcode: LoadImm32, args: [Register(0x44), Constant32(0x00000048=72)], resolved: None }
80 44 48 00 00 00 
# 81c08 Instruction { source: "t1 <- t2 Add t3", opcode: Add32NoCarryIn, args: [Register(0x3c), Register(0x44), Register(0x44)], resolved: None }
a0 3c 44 44 
# 81c0c Instruction { source: "t0 <- mem[t1] U8", opcode: Load8, args: [Register(0x44), Register(0x40)], resolved: None }
10 44 40 
# 81c0f Instruction { source: "t4 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x4c), Constant8(0x00=0)], resolved: None }
00 4c 00 
# 81c12 Instruction { source: "if t0 != t4 then 'RpnCalc_push_pending_if_true_0_1' else 'RpnCalc_push_pending_if_else_0_2'", opcode: Cmp8, args: [Register(0x40), Register(0x4c)], resolved: None }
25 40 4c 
# 81c15 Instruction { source: "if t0 != t4 then 'RpnCalc_push_pending_if_true_0_1' else 'RpnCalc_push_pending_if_else_0_2'", opcode: JzImm, args: [Label24(RpnCalc_push_pending_if_else_0_2)], resolved: None }
42 79 1c 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t0 != t4 then 'RpnCalc_push_pending_if_true_0_1' else 'RpnCalc_push_pending_if_else_0_2'", opcode: JmpImm, args: [Label24(RpnCalc_push_pending_if_true_0_1)], resolved: None }
# RpnCalc_push_pending_if_true_0_1
# 81c19 Instruction { source: "t7 <- c U32", opcode: Copy32, args: [Register(0x3c), Register(0x3c)], resolved: None }
81 3c 3c 
# 81c1c Instruction { source: "t6 <- t7 U32", opcode: Copy32, args: [Register(0x3c), Register(0x48)], resolved: None }
81 3c 48 
# 81c1f Instruction { source: "t10 <- c U32", opcode: Copy32, args: [Register(0x3c), Register(0x3c)], resolved: None }
81 3c 3c 
# 81c22 Instruction { source: "t11 <- 0n68/0x00000044u32 ", opcode: LoadImm32, args: [Register(0x44), Constant32(0x00000044=68)], resolved: None }
80 44 44 00 00 00 
# 81c28 Instruction { source: "t9 <- t10 Add t11", opcode: Add32NoCarryIn, args: [Register(0x3c), Register(0x44), Register(0x44)], resolved: None }
a0 3c 44 44 
# 81c2c Instruction { source: "t8 <- mem[t9] U32", opcode: Load32, args: [Register(0x44), Register(0x44)], resolved: None }
90 44 44 
# 81c2f Instruction { source: "Arg0[s]=t6 None <= call stack_push(t6,t8,)", opcode: Copy32, args: [Register(0x48), Register(0x00)], resolved: None }
81 48 00 
# 81c32 Instruction { source: "Arg1[n]=t8 None <= call stack_push(t6,t8,)", opcode: Copy32, args: [Register(0x44), Register(0x04)], resolved: None }
81 44 04 
# Registers used by this function: {60, 61, 62, 63, 64, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77}
# Registers used by callee tree: {176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195}
# Registers to save: []
# 81c35 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81c3b Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 45 1c 08 00 
# 81c41 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 c4 2b 08 
# 81c45 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81c4b Instruction { source: "t13 <- c U32", opcode: Copy32, args: [Register(0x3c), Register(0x3c)], resolved: None }
81 3c 3c 
# 81c4e Instruction { source: "t14 <- 0n68/0x00000044u32 ", opcode: LoadImm32, args: [Register(0x44), Constant32(0x00000044=68)], resolved: None }
80 44 44 00 00 00 
# 81c54 Instruction { source: "t12 <- t13 Add t14", opcode: Add32NoCarryIn, args: [Register(0x3c), Register(0x44), Register(0x44)], resolved: None }
a0 3c 44 44 
# 81c58 Instruction { source: "t15 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x48), Constant32(0x00000000=0)], resolved: None }
80 48 00 00 00 00 
# 81c5e Instruction { source: "mem[t12] <- t15 U32", opcode: Store32_1, args: [Register(0x48), Register(0x44)], resolved: None }
92 48 44 
# 81c61 Instruction { source: "mem[t12] <- t15 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 81c62 Instruction { source: "t17 <- c U32", opcode: Copy32, args: [Register(0x3c), Register(0x3c)], resolved: None }
81 3c 3c 
# 81c65 Instruction { source: "t18 <- 0n72/0x00000048u32 ", opcode: LoadImm32, args: [Register(0x44), Constant32(0x00000048=72)], resolved: None }
80 44 48 00 00 00 
# 81c6b Instruction { source: "t16 <- t17 Add t18", opcode: Add32NoCarryIn, args: [Register(0x3c), Register(0x44), Register(0x3c)], resolved: None }
a0 3c 44 3c 
# 81c6f Instruction { source: "t19 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x40), Constant8(0x00=0)], resolved: None }
00 40 00 
# 81c72 Instruction { source: "mem[t16] <- t19 U8", opcode: Store8, args: [Register(0x40), Register(0x3c)], resolved: None }
11 40 3c 
# 81c75 Instruction { source: "goto RpnCalc_push_pending_if_end_0", opcode: JmpImm, args: [Label24(RpnCalc_push_pending_if_end_0)], resolved: None }
40 79 1c 08 
# RpnCalc_push_pending_if_else_0_2
# RpnCalc_push_pending_if_end_0
# 81c79 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81c7b Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :add_U64
# Ret None
# Arg0=a
# Arg1=b
# Arg2=c
# Var a (Arg0 a Ptr(Struct("U64"))) U32 Some([80, 81, 82, 83])
# Var b (Arg1 b Ptr(Struct("U64"))) U32 Some([84, 85, 86, 87])
# Var c (Arg2 c Ptr(Struct("U64"))) U32 Some([88, 89, 90, 91])
# Var lo (Local lo Number(USIZE) U32) U32 Some([92, 93, 94, 95])
# Var t0 (t0 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("a") } }) U32 Some([80, 81, 82, 83])
# Var t1 (t1 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 4)) }) U32 Some([96, 97, 98, 99])
# Var t10 (t10 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("b") }, Number(USIZE, 4)) }) U32 Some([100, 101, 102, 103])
# Var t11 (t11 Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("b") }) U32 Some([84, 85, 86, 87])
# Var t12 (t12 Number(USIZE, 4)) U32 Some([100, 101, 102, 103])
# Var t13 (t13 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") } }) U32 Some([88, 89, 90, 91])
# Var t14 (t14 Arithmetic(Add, PtrFieldDeref("a", "lo"), PtrFieldDeref("b", "lo"))) U32 Some([80, 81, 82, 83])
# Var t15 (t15 PtrFieldDeref("a", "lo")) U32 Some([80, 81, 82, 83])
# Var t16 (t16 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("a") } }) U32 Some([80, 81, 82, 83])
# Var t17 (t17 PtrFieldDeref("b", "lo")) U32 Some([84, 85, 86, 87])
# Var t18 (t18 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("b") } }) U32 Some([84, 85, 86, 87])
# Var t19 (t19 PtrFieldDeref("c", "lo")) U32 Some([80, 81, 82, 83])
# Var t2 (t2 Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([88, 89, 90, 91])
# Var t20 (t20 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") } }) U32 Some([80, 81, 82, 83])
# Var t21 (t21 Ident("lo")) U32 Some([84, 85, 86, 87])
# Var t22 (t22 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 4)) }) U32 Some([80, 81, 82, 83])
# Var t23 (t23 Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([80, 81, 82, 83])
# Var t24 (t24 Number(USIZE, 4)) U32 Some([84, 85, 86, 87])
# Var t25 (t25 Arithmetic(Add, PtrFieldDeref("c", "hi"), Number(USIZE, 1))) U32 Some([84, 85, 86, 87])
# Var t26 (t26 PtrFieldDeref("c", "hi")) U32 Some([84, 85, 86, 87])
# Var t27 (t27 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 4)) }) U32 Some([84, 85, 86, 87])
# Var t28 (t28 Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([84, 85, 86, 87])
# Var t29 (t29 Number(USIZE, 4)) U32 Some([88, 89, 90, 91])
# Var t3 (t3 Number(USIZE, 4)) U32 Some([96, 97, 98, 99])
# Var t30 (t30 Number(USIZE, 1)) U32 Some([88, 89, 90, 91])
# Var t4 (t4 Arithmetic(Add, PtrFieldDeref("a", "hi"), PtrFieldDeref("b", "hi"))) U32 Some([100, 101, 102, 103])
# Var t5 (t5 PtrFieldDeref("a", "hi")) U32 Some([104, 105, 106, 107])
# Var t6 (t6 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("a") }, Number(USIZE, 4)) }) U32 Some([100, 101, 102, 103])
# Var t7 (t7 Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("a") }) U32 Some([80, 81, 82, 83])
# Var t8 (t8 Number(USIZE, 4)) U32 Some([100, 101, 102, 103])
# Var t9 (t9 PtrFieldDeref("b", "hi")) U32 Some([100, 101, 102, 103])
# 81c80 Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [80, 81, 82, 83].", opcode: Copy32, args: [Register(0x00), Register(0x50)], resolved: None }
81 00 50 
# 81c83 Instruction { source: "Save function parameter 'b' registers [4, 5, 6, 7] to locals [84, 85, 86, 87].", opcode: Copy32, args: [Register(0x04), Register(0x54)], resolved: None }
81 04 54 
# 81c86 Instruction { source: "Save function parameter 'c' registers [8, 9, 10, 11] to locals [88, 89, 90, 91].", opcode: Copy32, args: [Register(0x08), Register(0x58)], resolved: None }
81 08 58 
# 81c89 Instruction { source: "t0 <- a U32", opcode: Copy32, args: [Register(0x50), Register(0x50)], resolved: None }
81 50 50 
# 81c8c Instruction { source: "lo <- mem[t0] U32", opcode: Load32, args: [Register(0x50), Register(0x5c)], resolved: None }
90 50 5c 
# 81c8f Instruction { source: "t2 <- c U32", opcode: Copy32, args: [Register(0x58), Register(0x58)], resolved: None }
81 58 58 
# 81c92 Instruction { source: "t3 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x60), Constant32(0x00000004=4)], resolved: None }
80 60 04 00 00 00 
# 81c98 Instruction { source: "t1 <- t2 Add t3", opcode: Add32NoCarryIn, args: [Register(0x58), Register(0x60), Register(0x60)], resolved: None }
a0 58 60 60 
# 81c9c Instruction { source: "t7 <- a U32", opcode: Copy32, args: [Register(0x50), Register(0x50)], resolved: None }
81 50 50 
# 81c9f Instruction { source: "t8 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x64), Constant32(0x00000004=4)], resolved: None }
80 64 04 00 00 00 
# 81ca5 Instruction { source: "t6 <- t7 Add t8", opcode: Add32NoCarryIn, args: [Register(0x50), Register(0x64), Register(0x64)], resolved: None }
a0 50 64 64 
# 81ca9 Instruction { source: "t5 <- mem[t6] U32", opcode: Load32, args: [Register(0x64), Register(0x68)], resolved: None }
90 64 68 
# 81cac Instruction { source: "t11 <- b U32", opcode: Copy32, args: [Register(0x54), Register(0x54)], resolved: None }
81 54 54 
# 81caf Instruction { source: "t12 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x64), Constant32(0x00000004=4)], resolved: None }
80 64 04 00 00 00 
# 81cb5 Instruction { source: "t10 <- t11 Add t12", opcode: Add32NoCarryIn, args: [Register(0x54), Register(0x64), Register(0x64)], resolved: None }
a0 54 64 64 
# 81cb9 Instruction { source: "t9 <- mem[t10] U32", opcode: Load32, args: [Register(0x64), Register(0x64)], resolved: None }
90 64 64 
# 81cbc Instruction { source: "t4 <- t5 Add t9", opcode: Add32NoCarryIn, args: [Register(0x68), Register(0x64), Register(0x64)], resolved: None }
a0 68 64 64 
# 81cc0 Instruction { source: "mem[t1] <- t4 U32", opcode: Store32_1, args: [Register(0x64), Register(0x60)], resolved: None }
92 64 60 
# 81cc3 Instruction { source: "mem[t1] <- t4 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 81cc4 Instruction { source: "t13 <- c U32", opcode: Copy32, args: [Register(0x58), Register(0x58)], resolved: None }
81 58 58 
# 81cc7 Instruction { source: "t16 <- a U32", opcode: Copy32, args: [Register(0x50), Register(0x50)], resolved: None }
81 50 50 
# 81cca Instruction { source: "t15 <- mem[t16] U32", opcode: Load32, args: [Register(0x50), Register(0x50)], resolved: None }
90 50 50 
# 81ccd Instruction { source: "t18 <- b U32", opcode: Copy32, args: [Register(0x54), Register(0x54)], resolved: None }
81 54 54 
# 81cd0 Instruction { source: "t17 <- mem[t18] U32", opcode: Load32, args: [Register(0x54), Register(0x54)], resolved: None }
90 54 54 
# 81cd3 Instruction { source: "t14 <- t15 Add t17", opcode: Add32NoCarryIn, args: [Register(0x50), Register(0x54), Register(0x50)], resolved: None }
a0 50 54 50 
# 81cd7 Instruction { source: "mem[t13] <- t14 U32", opcode: Store32_1, args: [Register(0x50), Register(0x58)], resolved: None }
92 50 58 
# 81cda Instruction { source: "mem[t13] <- t14 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 81cdb Instruction { source: "t20 <- c U32", opcode: Copy32, args: [Register(0x58), Register(0x50)], resolved: None }
81 58 50 
# 81cde Instruction { source: "t19 <- mem[t20] U32", opcode: Load32, args: [Register(0x50), Register(0x50)], resolved: None }
90 50 50 
# 81ce1 Instruction { source: "t21 <- lo U32", opcode: Copy32, args: [Register(0x5c), Register(0x54)], resolved: None }
81 5c 54 
# 81ce4 Instruction { source: "if t19 < t21 then 'add_U64_if_true_0_1' else 'add_U64_if_else_0_2'", opcode: Cmp8, args: [Register(0x57), Register(0x53)], resolved: None }
25 57 53 
# 81ce7 Instruction { source: "if t19 < t21 then 'add_U64_if_true_0_1' else 'add_U64_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x56), Register(0x52)], resolved: None }
26 56 52 
# 81cea Instruction { source: "if t19 < t21 then 'add_U64_if_true_0_1' else 'add_U64_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x55), Register(0x51)], resolved: None }
26 55 51 
# 81ced Instruction { source: "if t19 < t21 then 'add_U64_if_true_0_1' else 'add_U64_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x54), Register(0x50)], resolved: None }
26 54 50 
# 81cf0 Instruction { source: "if t19 < t21 then 'add_U64_if_true_0_1' else 'add_U64_if_else_0_2'", opcode: JcImm, args: [Label24(add_U64_if_else_0_2)], resolved: None }
41 23 1d 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t19 < t21 then 'add_U64_if_true_0_1' else 'add_U64_if_else_0_2'", opcode: JmpImm, args: [Label24(add_U64_if_true_0_1)], resolved: None }
# add_U64_if_true_0_1
# 81cf4 Instruction { source: "t23 <- c U32", opcode: Copy32, args: [Register(0x58), Register(0x50)], resolved: None }
81 58 50 
# 81cf7 Instruction { source: "t24 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x54), Constant32(0x00000004=4)], resolved: None }
80 54 04 00 00 00 
# 81cfd Instruction { source: "t22 <- t23 Add t24", opcode: Add32NoCarryIn, args: [Register(0x50), Register(0x54), Register(0x50)], resolved: None }
a0 50 54 50 
# 81d01 Instruction { source: "t28 <- c U32", opcode: Copy32, args: [Register(0x58), Register(0x54)], resolved: None }
81 58 54 
# 81d04 Instruction { source: "t29 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x58), Constant32(0x00000004=4)], resolved: None }
80 58 04 00 00 00 
# 81d0a Instruction { source: "t27 <- t28 Add t29", opcode: Add32NoCarryIn, args: [Register(0x54), Register(0x58), Register(0x54)], resolved: None }
a0 54 58 54 
# 81d0e Instruction { source: "t26 <- mem[t27] U32", opcode: Load32, args: [Register(0x54), Register(0x54)], resolved: None }
90 54 54 
# 81d11 Instruction { source: "t30 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x58), Constant32(0x00000001=1)], resolved: None }
80 58 01 00 00 00 
# 81d17 Instruction { source: "t25 <- t26 Add t30", opcode: Add32NoCarryIn, args: [Register(0x54), Register(0x58), Register(0x54)], resolved: None }
a0 54 58 54 
# 81d1b Instruction { source: "mem[t22] <- t25 U32", opcode: Store32_1, args: [Register(0x54), Register(0x50)], resolved: None }
92 54 50 
# 81d1e Instruction { source: "mem[t22] <- t25 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 81d1f Instruction { source: "goto add_U64_if_end_0", opcode: JmpImm, args: [Label24(add_U64_if_end_0)], resolved: None }
40 23 1d 08 
# add_U64_if_else_0_2
# add_U64_if_end_0
# 81d23 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81d25 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :div16
# Ret Some(U32)
# Arg0=a
# Arg1=b
# Var a (Arg0 a Number(USIZE)) U32 Some([108, 109, 110, 111])
# Var b (Arg1 b Number(USIZE)) U32 Some([112, 113, 114, 115])
# Var hi (Local hi Number(USIZE) U32) U32 Some([116, 117, 118, 119])
# Var lo (Local lo Number(USIZE) U32) U32 Some([120, 121, 122, 123])
# Var mid (Local mid Number(USIZE) U32) U32 Some([124, 125, 126, 127])
# Var r (Local r Number(USIZE) U32) U32 Some([120, 121, 122, 123])
# Var t0 (t0 Ident("a")) U32 Some([108, 109, 110, 111])
# Var t1 (t1 Ident("b")) U32 Some([112, 113, 114, 115])
# Var t10 (t10 Index("x", Number(U8, 2))) U8 Some([128])
# Var t11 (t11 Number(U8, 0)) U8 Some([129])
# Var t12 (t12 Ident("mid")) U32 Some([116, 117, 118, 119])
# Var t13 (t13 Number(USIZE, 1)) U32 Some([124, 125, 126, 127])
# Var t14 (t14 Index("x", Number(U8, 3))) U8 Some([128])
# Var t15 (t15 Number(U8, 0)) U8 Some([129])
# Var t16 (t16 Ident("mid")) U32 Some([116, 117, 118, 119])
# Var t17 (t17 Number(USIZE, 1)) U32 Some([124, 125, 126, 127])
# Var t18 (t18 Ident("x")) U32 Some([132, 133, 134, 135])
# Var t19 (t19 Ident("a")) U32 Some([108, 109, 110, 111])
# Var t2 (t2 Number(USIZE, 0)) U32 Some([108, 109, 110, 111])
# Var t20 (t20 Ident("mid")) U32 Some([116, 117, 118, 119])
# Var t21 (t21 Number(USIZE, 1)) U32 Some([124, 125, 126, 127])
# Var t22 (t22 Ident("x")) U32 Some([120, 121, 122, 123])
# Var t23 (t23 Ident("a")) U32 Some([108, 109, 110, 111])
# Var t24 (t24 Ident("mid")) U32 Some([108, 109, 110, 111])
# Var t25 (t25 Ident("a")) U32 Some([108, 109, 110, 111])
# Var t26 (t26 Ident("x")) U32 Some([120, 121, 122, 123])
# Var t27 (t27 Ident("r")) U32 Some([120, 121, 122, 123])
# Var t28 (t28 Ident("b")) U32 Some([112, 113, 114, 115])
# Var t29 (t29 Ident("mid")) U32 Some([108, 109, 110, 111])
# Var t3 (t3 Ident("lo")) U32 Some([120, 121, 122, 123])
# Var t30 (t30 Ident("mid")) U32 Some([120, 121, 122, 123])
# Var t31 (t31 Number(USIZE, 1)) U32 Some([124, 125, 126, 127])
# Var t32 (t32 Ident("lo")) U32 Some([108, 109, 110, 111])
# Var t4 (t4 Ident("hi")) U32 Some([116, 117, 118, 119])
# Var t5 (t5 Arithmetic(Add, Ident("lo"), Ident("hi"))) U32 Some([124, 125, 126, 127])
# Var t6 (t6 Ident("lo")) U32 Some([120, 121, 122, 123])
# Var t7 (t7 Ident("hi")) U32 Some([116, 117, 118, 119])
# Var t8 (t8 Ident("mid")) U32 Some([124, 125, 126, 127])
# Var t9 (t9 Ident("b")) U32 Some([112, 113, 114, 115])
# Var x (Local x Number(USIZE) U32) U32 Some([132, 133, 134, 135])
# 81d2a Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [108, 109, 110, 111].", opcode: Copy32, args: [Register(0x00), Register(0x6c)], resolved: None }
81 00 6c 
# 81d2d Instruction { source: "Save function parameter 'b' registers [4, 5, 6, 7] to locals [112, 113, 114, 115].", opcode: Copy32, args: [Register(0x04), Register(0x70)], resolved: None }
81 04 70 
# 81d30 Instruction { source: "t0 <- a U32", opcode: Copy32, args: [Register(0x6c), Register(0x6c)], resolved: None }
81 6c 6c 
# 81d33 Instruction { source: "t1 <- b U32", opcode: Copy32, args: [Register(0x70), Register(0x70)], resolved: None }
81 70 70 
# 81d36 Instruction { source: "if t0 < t1 then 'div16_if_true_0_1' else 'div16_if_else_0_2'", opcode: Cmp8, args: [Register(0x73), Register(0x6f)], resolved: None }
25 73 6f 
# 81d39 Instruction { source: "if t0 < t1 then 'div16_if_true_0_1' else 'div16_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x72), Register(0x6e)], resolved: None }
26 72 6e 
# 81d3c Instruction { source: "if t0 < t1 then 'div16_if_true_0_1' else 'div16_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x71), Register(0x6d)], resolved: None }
26 71 6d 
# 81d3f Instruction { source: "if t0 < t1 then 'div16_if_true_0_1' else 'div16_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x70), Register(0x6c)], resolved: None }
26 70 6c 
# 81d42 Instruction { source: "if t0 < t1 then 'div16_if_true_0_1' else 'div16_if_else_0_2'", opcode: JcImm, args: [Label24(div16_if_else_0_2)], resolved: None }
41 55 1d 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t0 < t1 then 'div16_if_true_0_1' else 'div16_if_else_0_2'", opcode: JmpImm, args: [Label24(div16_if_true_0_1)], resolved: None }
# div16_if_true_0_1
# 81d46 Instruction { source: "t2 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x6c), Constant32(0x00000000=0)], resolved: None }
80 6c 00 00 00 00 
# 81d4c Instruction { source: "return Some(t2)", opcode: Copy32, args: [Register(0x6c), Register(0x00)], resolved: None }
81 6c 00 
# 81d4f Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81d51 Instruction { source: "goto div16_if_end_0", opcode: JmpImm, args: [Label24(div16_if_end_0)], resolved: None }
40 55 1d 08 
# div16_if_else_0_2
# div16_if_end_0
# 81d55 Instruction { source: "lo <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x78), Constant32(0x00000000=0)], resolved: None }
80 78 00 00 00 00 
# 81d5b Instruction { source: "hi <- 0n65535/0x0000ffffu32 ", opcode: LoadImm32, args: [Register(0x74), Constant32(0x0000ffff=65535)], resolved: None }
80 74 ff ff 00 00 
# div16_while_predicate_3
# 81d61 Instruction { source: "t3 <- lo U32", opcode: Copy32, args: [Register(0x78), Register(0x78)], resolved: None }
81 78 78 
# 81d64 Instruction { source: "t4 <- hi U32", opcode: Copy32, args: [Register(0x74), Register(0x74)], resolved: None }
81 74 74 
# 81d67 Instruction { source: "if t3 < t4 then 'div16_while_body_4' else 'div16_while_end_5'", opcode: Cmp8, args: [Register(0x77), Register(0x7b)], resolved: None }
25 77 7b 
# 81d6a Instruction { source: "if t3 < t4 then 'div16_while_body_4' else 'div16_while_end_5'", opcode: Cmp8IfZero, args: [Register(0x76), Register(0x7a)], resolved: None }
26 76 7a 
# 81d6d Instruction { source: "if t3 < t4 then 'div16_while_body_4' else 'div16_while_end_5'", opcode: Cmp8IfZero, args: [Register(0x75), Register(0x79)], resolved: None }
26 75 79 
# 81d70 Instruction { source: "if t3 < t4 then 'div16_while_body_4' else 'div16_while_end_5'", opcode: Cmp8IfZero, args: [Register(0x74), Register(0x78)], resolved: None }
26 74 78 
# 81d73 Instruction { source: "if t3 < t4 then 'div16_while_body_4' else 'div16_while_end_5'", opcode: JcImm, args: [Label24(div16_while_end_5)], resolved: None }
41 e8 1e 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t3 < t4 then 'div16_while_body_4' else 'div16_while_end_5'", opcode: JmpImm, args: [Label24(div16_while_body_4)], resolved: None }
# div16_while_body_4
# 81d77 Instruction { source: "t6 <- lo U32", opcode: Copy32, args: [Register(0x78), Register(0x78)], resolved: None }
81 78 78 
# 81d7a Instruction { source: "t7 <- hi U32", opcode: Copy32, args: [Register(0x74), Register(0x74)], resolved: None }
81 74 74 
# 81d7d Instruction { source: "t5 <- t6 Add t7", opcode: Add32NoCarryIn, args: [Register(0x78), Register(0x74), Register(0x7c)], resolved: None }
a0 78 74 7c 
# 81d81 Instruction { source: "Arg0[a]=t5 Some(mid) <= call shiftright1(t5,)", opcode: Copy32, args: [Register(0x7c), Register(0x00)], resolved: None }
81 7c 00 
# Registers used by this function: {108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135}
# Registers used by callee tree: {132, 133, 134, 135, 136, 137, 138}
# Registers to save: [132, 133, 134, 135]
# 81d84 Instruction { source: "Saving reg0x87 before Some(mid) <= call shiftright1(t5,)", opcode: Push8, args: [Register(0x87)], resolved: None }
14 87 
# 81d86 Instruction { source: "Saving reg0x86 before Some(mid) <= call shiftright1(t5,)", opcode: Push8, args: [Register(0x86)], resolved: None }
14 86 
# 81d88 Instruction { source: "Saving reg0x85 before Some(mid) <= call shiftright1(t5,)", opcode: Push8, args: [Register(0x85)], resolved: None }
14 85 
# 81d8a Instruction { source: "Saving reg0x84 before Some(mid) <= call shiftright1(t5,)", opcode: Push8, args: [Register(0x84)], resolved: None }
14 84 
# 81d8c Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81d92 Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 9c 1d 08 00 
# 81d98 Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: JmpImm, args: [Label24(:shiftright1)], resolved: None }
40 39 2a 08 
# 81d9c Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81da2 Instruction { source: "Restoring reg0x84 after Some(mid) <= call shiftright1(t5,)", opcode: Pop8, args: [Register(0x84)], resolved: None }
15 84 
# 81da4 Instruction { source: "Restoring reg0x85 after Some(mid) <= call shiftright1(t5,)", opcode: Pop8, args: [Register(0x85)], resolved: None }
15 85 
# 81da6 Instruction { source: "Restoring reg0x86 after Some(mid) <= call shiftright1(t5,)", opcode: Pop8, args: [Register(0x86)], resolved: None }
15 86 
# 81da8 Instruction { source: "Restoring reg0x87 after Some(mid) <= call shiftright1(t5,)", opcode: Pop8, args: [Register(0x87)], resolved: None }
15 87 
# 81daa Instruction { source: "Some(mid) <= call shiftright1(t5,)", opcode: Copy32, args: [Register(0x00), Register(0x7c)], resolved: None }
81 00 7c 
# 81dad Instruction { source: "t8 <- mid U32", opcode: Copy32, args: [Register(0x7c), Register(0x7c)], resolved: None }
81 7c 7c 
# 81db0 Instruction { source: "t9 <- b U32", opcode: Copy32, args: [Register(0x70), Register(0x70)], resolved: None }
81 70 70 
# 81db3 Instruction { source: "Arg0[a]=t8 Some(x) <= call mul16_32(t8,t9,)", opcode: Copy32, args: [Register(0x7c), Register(0x00)], resolved: None }
81 7c 00 
# 81db6 Instruction { source: "Arg1[b]=t9 Some(x) <= call mul16_32(t8,t9,)", opcode: Copy32, args: [Register(0x70), Register(0x04)], resolved: None }
81 70 04 
# Registers used by this function: {108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135}
# Registers used by callee tree: {200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225}
# Registers to save: []
# 81db9 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81dbf Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c c9 1d 08 00 
# 81dc5 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: JmpImm, args: [Label24(:mul16_32)], resolved: None }
40 57 23 08 
# 81dc9 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81dcf Instruction { source: "Some(x) <= call mul16_32(t8,t9,)", opcode: Copy32, args: [Register(0x00), Register(0x84)], resolved: None }
81 00 84 
# 81dd2 Instruction { source: "t10 <- x[0x02..0x03] U8", opcode: Copy8, args: [Register(0x86), Register(0x80)], resolved: None }
16 86 80 
# 81dd5 Instruction { source: "t11 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x81), Constant8(0x00=0)], resolved: None }
00 81 00 
# 81dd8 Instruction { source: "if t10 > t11 then 'div16_if_true_0_7' else 'div16_if_else_0_8'", opcode: Cmp8, args: [Register(0x80), Register(0x81)], resolved: None }
25 80 81 
# 81ddb Instruction { source: "if t10 > t11 then 'div16_if_true_0_7' else 'div16_if_else_0_8'", opcode: JcImm, args: [Label24(div16_if_else_0_8)], resolved: None }
41 05 1e 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t10 > t11 then 'div16_if_true_0_7' else 'div16_if_else_0_8'", opcode: JmpImm, args: [Label24(div16_if_true_0_7)], resolved: None }
# div16_if_true_0_7
# 81ddf Instruction { source: "t12 <- mid U32", opcode: Copy32, args: [Register(0x7c), Register(0x74)], resolved: None }
81 7c 74 
# 81de2 Instruction { source: "t13 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x7c), Constant32(0x00000001=1)], resolved: None }
80 7c 01 00 00 00 
# 81de8 Instruction { source: "hi <- t12 Subtract t13", opcode: Copy32, args: [Register(0x7c), Register(0x00)], resolved: None }
81 7c 00 
# 81deb Instruction { source: "hi <- t12 Subtract t13", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 81ded Instruction { source: "hi <- t12 Subtract t13", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 81def Instruction { source: "hi <- t12 Subtract t13", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 81df1 Instruction { source: "hi <- t12 Subtract t13", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 81df3 Instruction { source: "hi <- t12 Subtract t13", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 81df9 Instruction { source: "hi <- t12 Subtract t13", opcode: Add32NoCarryIn, args: [Register(0x74), Register(0x00), Register(0x74)], resolved: None }
a0 74 00 74 
# 81dfd Instruction { source: "goto div16_while_predicate_3", opcode: JmpImm, args: [Label24(div16_while_predicate_3)], resolved: None }
40 61 1d 08 
# 81e01 Instruction { source: "goto div16_if_end_6", opcode: JmpImm, args: [Label24(div16_if_end_6)], resolved: None }
40 05 1e 08 
# div16_if_else_0_8
# div16_if_end_6
# 81e05 Instruction { source: "t14 <- x[0x03..0x04] U8", opcode: Copy8, args: [Register(0x87), Register(0x80)], resolved: None }
16 87 80 
# 81e08 Instruction { source: "t15 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x81), Constant8(0x00=0)], resolved: None }
00 81 00 
# 81e0b Instruction { source: "if t14 > t15 then 'div16_if_true_0_10' else 'div16_if_else_0_11'", opcode: Cmp8, args: [Register(0x80), Register(0x81)], resolved: None }
25 80 81 
# 81e0e Instruction { source: "if t14 > t15 then 'div16_if_true_0_10' else 'div16_if_else_0_11'", opcode: JcImm, args: [Label24(div16_if_else_0_11)], resolved: None }
41 38 1e 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t14 > t15 then 'div16_if_true_0_10' else 'div16_if_else_0_11'", opcode: JmpImm, args: [Label24(div16_if_true_0_10)], resolved: None }
# div16_if_true_0_10
# 81e12 Instruction { source: "t16 <- mid U32", opcode: Copy32, args: [Register(0x7c), Register(0x74)], resolved: None }
81 7c 74 
# 81e15 Instruction { source: "t17 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x7c), Constant32(0x00000001=1)], resolved: None }
80 7c 01 00 00 00 
# 81e1b Instruction { source: "hi <- t16 Subtract t17", opcode: Copy32, args: [Register(0x7c), Register(0x00)], resolved: None }
81 7c 00 
# 81e1e Instruction { source: "hi <- t16 Subtract t17", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 81e20 Instruction { source: "hi <- t16 Subtract t17", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 81e22 Instruction { source: "hi <- t16 Subtract t17", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 81e24 Instruction { source: "hi <- t16 Subtract t17", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 81e26 Instruction { source: "hi <- t16 Subtract t17", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 81e2c Instruction { source: "hi <- t16 Subtract t17", opcode: Add32NoCarryIn, args: [Register(0x74), Register(0x00), Register(0x74)], resolved: None }
a0 74 00 74 
# 81e30 Instruction { source: "goto div16_while_predicate_3", opcode: JmpImm, args: [Label24(div16_while_predicate_3)], resolved: None }
40 61 1d 08 
# 81e34 Instruction { source: "goto div16_if_end_9", opcode: JmpImm, args: [Label24(div16_if_end_9)], resolved: None }
40 38 1e 08 
# div16_if_else_0_11
# div16_if_end_9
# 81e38 Instruction { source: "t18 <- x U32", opcode: Copy32, args: [Register(0x84), Register(0x84)], resolved: None }
81 84 84 
# 81e3b Instruction { source: "t19 <- a U32", opcode: Copy32, args: [Register(0x6c), Register(0x6c)], resolved: None }
81 6c 6c 
# 81e3e Instruction { source: "if t18 > t19 then 'div16_if_true_0_13' else 'div16_if_else_0_14'", opcode: Cmp8, args: [Register(0x87), Register(0x6f)], resolved: None }
25 87 6f 
# 81e41 Instruction { source: "if t18 > t19 then 'div16_if_true_0_13' else 'div16_if_else_0_14'", opcode: Cmp8IfZero, args: [Register(0x86), Register(0x6e)], resolved: None }
26 86 6e 
# 81e44 Instruction { source: "if t18 > t19 then 'div16_if_true_0_13' else 'div16_if_else_0_14'", opcode: Cmp8IfZero, args: [Register(0x85), Register(0x6d)], resolved: None }
26 85 6d 
# 81e47 Instruction { source: "if t18 > t19 then 'div16_if_true_0_13' else 'div16_if_else_0_14'", opcode: Cmp8IfZero, args: [Register(0x84), Register(0x6c)], resolved: None }
26 84 6c 
# 81e4a Instruction { source: "if t18 > t19 then 'div16_if_true_0_13' else 'div16_if_else_0_14'", opcode: JcImm, args: [Label24(div16_if_else_0_14)], resolved: None }
41 74 1e 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t18 > t19 then 'div16_if_true_0_13' else 'div16_if_else_0_14'", opcode: JmpImm, args: [Label24(div16_if_true_0_13)], resolved: None }
# div16_if_true_0_13
# 81e4e Instruction { source: "t20 <- mid U32", opcode: Copy32, args: [Register(0x7c), Register(0x74)], resolved: None }
81 7c 74 
# 81e51 Instruction { source: "t21 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x7c), Constant32(0x00000001=1)], resolved: None }
80 7c 01 00 00 00 
# 81e57 Instruction { source: "hi <- t20 Subtract t21", opcode: Copy32, args: [Register(0x7c), Register(0x00)], resolved: None }
81 7c 00 
# 81e5a Instruction { source: "hi <- t20 Subtract t21", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 81e5c Instruction { source: "hi <- t20 Subtract t21", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 81e5e Instruction { source: "hi <- t20 Subtract t21", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 81e60 Instruction { source: "hi <- t20 Subtract t21", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 81e62 Instruction { source: "hi <- t20 Subtract t21", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 81e68 Instruction { source: "hi <- t20 Subtract t21", opcode: Add32NoCarryIn, args: [Register(0x74), Register(0x00), Register(0x74)], resolved: None }
a0 74 00 74 
# 81e6c Instruction { source: "goto div16_while_predicate_3", opcode: JmpImm, args: [Label24(div16_while_predicate_3)], resolved: None }
40 61 1d 08 
# 81e70 Instruction { source: "goto div16_if_end_12", opcode: JmpImm, args: [Label24(div16_if_end_12)], resolved: None }
40 74 1e 08 
# div16_if_else_0_14
# div16_if_end_12
# 81e74 Instruction { source: "t22 <- x U32", opcode: Copy32, args: [Register(0x84), Register(0x78)], resolved: None }
81 84 78 
# 81e77 Instruction { source: "t23 <- a U32", opcode: Copy32, args: [Register(0x6c), Register(0x6c)], resolved: None }
81 6c 6c 
# 81e7a Instruction { source: "if t22 == t23 then 'div16_if_true_0_16' else 'div16_if_else_0_17'", opcode: Cmp8, args: [Register(0x7b), Register(0x6f)], resolved: None }
25 7b 6f 
# 81e7d Instruction { source: "if t22 == t23 then 'div16_if_true_0_16' else 'div16_if_else_0_17'", opcode: Cmp8IfZero, args: [Register(0x7a), Register(0x6e)], resolved: None }
26 7a 6e 
# 81e80 Instruction { source: "if t22 == t23 then 'div16_if_true_0_16' else 'div16_if_else_0_17'", opcode: Cmp8IfZero, args: [Register(0x79), Register(0x6d)], resolved: None }
26 79 6d 
# 81e83 Instruction { source: "if t22 == t23 then 'div16_if_true_0_16' else 'div16_if_else_0_17'", opcode: Cmp8IfZero, args: [Register(0x78), Register(0x6c)], resolved: None }
26 78 6c 
# 81e86 Instruction { source: "if t22 == t23 then 'div16_if_true_0_16' else 'div16_if_else_0_17'", opcode: JzImm, args: [Label24(div16_if_true_0_16)], resolved: None }
42 8e 1e 08 
# 81e8a Instruction { source: "if t22 == t23 then 'div16_if_true_0_16' else 'div16_if_else_0_17'", opcode: JmpImm, args: [Label24(div16_if_else_0_17)], resolved: None }
40 9a 1e 08 
# div16_if_true_0_16
# 81e8e Instruction { source: "t24 <- mid U32", opcode: Copy32, args: [Register(0x7c), Register(0x6c)], resolved: None }
81 7c 6c 
# 81e91 Instruction { source: "return Some(t24)", opcode: Copy32, args: [Register(0x6c), Register(0x00)], resolved: None }
81 6c 00 
# 81e94 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81e96 Instruction { source: "goto div16_if_end_15", opcode: JmpImm, args: [Label24(div16_if_end_15)], resolved: None }
40 9a 1e 08 
# div16_if_else_0_17
# div16_if_end_15
# 81e9a Instruction { source: "t25 <- a U32", opcode: Copy32, args: [Register(0x6c), Register(0x6c)], resolved: None }
81 6c 6c 
# 81e9d Instruction { source: "t26 <- x U32", opcode: Copy32, args: [Register(0x84), Register(0x78)], resolved: None }
81 84 78 
# 81ea0 Instruction { source: "r <- t25 Subtract t26", opcode: Copy32, args: [Register(0x78), Register(0x00)], resolved: None }
81 78 00 
# 81ea3 Instruction { source: "r <- t25 Subtract t26", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 81ea5 Instruction { source: "r <- t25 Subtract t26", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 81ea7 Instruction { source: "r <- t25 Subtract t26", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 81ea9 Instruction { source: "r <- t25 Subtract t26", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 81eab Instruction { source: "r <- t25 Subtract t26", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 81eb1 Instruction { source: "r <- t25 Subtract t26", opcode: Add32NoCarryIn, args: [Register(0x6c), Register(0x00), Register(0x78)], resolved: None }
a0 6c 00 78 
# 81eb5 Instruction { source: "t27 <- r U32", opcode: Copy32, args: [Register(0x78), Register(0x78)], resolved: None }
81 78 78 
# 81eb8 Instruction { source: "t28 <- b U32", opcode: Copy32, args: [Register(0x70), Register(0x70)], resolved: None }
81 70 70 
# 81ebb Instruction { source: "if t27 < t28 then 'div16_if_true_0_19' else 'div16_if_else_0_20'", opcode: Cmp8, args: [Register(0x73), Register(0x7b)], resolved: None }
25 73 7b 
# 81ebe Instruction { source: "if t27 < t28 then 'div16_if_true_0_19' else 'div16_if_else_0_20'", opcode: Cmp8IfZero, args: [Register(0x72), Register(0x7a)], resolved: None }
26 72 7a 
# 81ec1 Instruction { source: "if t27 < t28 then 'div16_if_true_0_19' else 'div16_if_else_0_20'", opcode: Cmp8IfZero, args: [Register(0x71), Register(0x79)], resolved: None }
26 71 79 
# 81ec4 Instruction { source: "if t27 < t28 then 'div16_if_true_0_19' else 'div16_if_else_0_20'", opcode: Cmp8IfZero, args: [Register(0x70), Register(0x78)], resolved: None }
26 70 78 
# 81ec7 Instruction { source: "if t27 < t28 then 'div16_if_true_0_19' else 'div16_if_else_0_20'", opcode: JcImm, args: [Label24(div16_if_else_0_20)], resolved: None }
41 d7 1e 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t27 < t28 then 'div16_if_true_0_19' else 'div16_if_else_0_20'", opcode: JmpImm, args: [Label24(div16_if_true_0_19)], resolved: None }
# div16_if_true_0_19
# 81ecb Instruction { source: "t29 <- mid U32", opcode: Copy32, args: [Register(0x7c), Register(0x6c)], resolved: None }
81 7c 6c 
# 81ece Instruction { source: "return Some(t29)", opcode: Copy32, args: [Register(0x6c), Register(0x00)], resolved: None }
81 6c 00 
# 81ed1 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81ed3 Instruction { source: "goto div16_if_end_18", opcode: JmpImm, args: [Label24(div16_if_end_18)], resolved: None }
40 d7 1e 08 
# div16_if_else_0_20
# div16_if_end_18
# 81ed7 Instruction { source: "t30 <- mid U32", opcode: Copy32, args: [Register(0x7c), Register(0x78)], resolved: None }
81 7c 78 
# 81eda Instruction { source: "t31 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x7c), Constant32(0x00000001=1)], resolved: None }
80 7c 01 00 00 00 
# 81ee0 Instruction { source: "lo <- t30 Add t31", opcode: Add32NoCarryIn, args: [Register(0x78), Register(0x7c), Register(0x78)], resolved: None }
a0 78 7c 78 
# 81ee4 Instruction { source: "goto div16_while_predicate_3", opcode: JmpImm, args: [Label24(div16_while_predicate_3)], resolved: None }
40 61 1d 08 
# div16_while_end_5
# 81ee8 Instruction { source: "t32 <- lo U32", opcode: Copy32, args: [Register(0x78), Register(0x6c)], resolved: None }
81 78 6c 
# 81eeb Instruction { source: "return Some(t32)", opcode: Copy32, args: [Register(0x6c), Register(0x00)], resolved: None }
81 6c 00 
# 81eee Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81ef0 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :div32
# Ret Some(U32)
# Arg0=a
# Arg1=b
# Var __frame_pointer (__frame_pointer) U32 Some([12, 13, 14, 15])
# Var a (Arg0 a Number(USIZE)) U32 Some([136, 137, 138, 139])
# Var b (Arg1 b Number(USIZE)) U32 Some([140, 141, 142, 143])
# Var hi (Local hi Number(USIZE) U32) U32 Some([144, 145, 146, 147])
# Var lo (Local lo Number(USIZE) U32) U32 Some([148, 149, 150, 151])
# Var mid (Local mid Number(USIZE) U32) U32 Some([152, 153, 154, 155])
# Var r (Local r Number(USIZE) U32) U32 Some([148, 149, 150, 151])
# Var t0 (Stack size negated) U32 Some([144, 145, 146, 147])
# Var t1 (t1 Ident("a")) U32 Some([136, 137, 138, 139])
# Var t10 (t10 Arithmetic(Divide, Index("a", Number(U8, 0)), Index("b", Number(U8, 0)))) U8 Some([156])
# Var t11 (t11 Index("a", Number(U8, 0))) U8 Some([156])
# Var t12 (t12 Index("b", Number(U8, 0))) U8 Some([157])
# Var t13 (Stack size) U32 Some([136, 137, 138, 139])
# Var t14 (t14 Ident("a")) U32 Some([136, 137, 138, 139])
# Var t15 (t15 Number(USIZE, 65536)) U32 Some([144, 145, 146, 147])
# Var t16 (t16 Ident("b")) U32 Some([140, 141, 142, 143])
# Var t17 (t17 Number(USIZE, 65536)) U32 Some([144, 145, 146, 147])
# Var t18 (t18 Call(Call { function: "div16", parameters: [Ident("a"), Ident("b")] })) U32 Some([136, 137, 138, 139])
# Var t19 (t19 Ident("a")) U32 Some([136, 137, 138, 139])
# Var t2 (t2 Ident("b")) U32 Some([140, 141, 142, 143])
# Var t20 (t20 Ident("b")) U32 Some([140, 141, 142, 143])
# Var t21 (Stack size) U32 Some([140, 141, 142, 143])
# Var t22 (t22 Ident("lo")) U32 Some([148, 149, 150, 151])
# Var t23 (t23 Ident("hi")) U32 Some([144, 145, 146, 147])
# Var t24 (t24 Call(Call { function: "shiftright1", parameters: [Ident("lo")] })) U32 Some([152, 153, 154, 155])
# Var t25 (t25 Ident("lo")) U32 Some([148, 149, 150, 151])
# Var t26 (t26 Call(Call { function: "shiftright1", parameters: [Ident("hi")] })) U32 Some([160, 161, 162, 163])
# Var t27 (t27 Ident("hi")) U32 Some([144, 145, 146, 147])
# Var t28 (t28 Call(Call { function: "mul32_64", parameters: [Ident("mid"), Ident("b"), AddressOf(Ident("x64"))] })) U8 Some([164])
# Var t29 (t29 Ident("mid")) U32 Some([152, 153, 154, 155])
# Var t3 (t3 Number(USIZE, 0)) U32 Some([136, 137, 138, 139])
# Var t30 (t30 Ident("b")) U32 Some([140, 141, 142, 143])
# Var t31 (t31 AddressOf(Ident("x64"))) U32 Some([160, 161, 162, 163])
# Var t32 (t32 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([160, 161, 162, 163])
# Var t33 (t33 Ident("__frame_pointer")) U32 Some([168, 169, 170, 171])
# Var t34 (t34 Number(USIZE, 0)) U32 Some([160, 161, 162, 163])
# Var t35 (t35 LocalFieldDeref("x64", "hi")) U32 Some([160, 161, 162, 163])
# Var t36 (t36 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 4)) }) U32 Some([160, 161, 162, 163])
# Var t37 (t37 Ident("__frame_pointer")) U32 Some([168, 169, 170, 171])
# Var t38 (t38 Number(USIZE, 4)) U32 Some([160, 161, 162, 163])
# Var t39 (t39 Number(USIZE, 0)) U32 Some([172, 173, 174, 175])
# Var t4 (Stack size) U32 Some([140, 141, 142, 143])
# Var t40 (t40 Ident("mid")) U32 Some([144, 145, 146, 147])
# Var t41 (t41 Number(USIZE, 1)) U32 Some([152, 153, 154, 155])
# Var t42 (t42 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Ident("__frame_pointer") }) U32 Some([168, 169, 170, 171])
# Var t43 (t43 Ident("x")) U32 Some([160, 161, 162, 163])
# Var t44 (t44 Ident("a")) U32 Some([136, 137, 138, 139])
# Var t45 (t45 Ident("mid")) U32 Some([144, 145, 146, 147])
# Var t46 (t46 Number(USIZE, 1)) U32 Some([152, 153, 154, 155])
# Var t47 (t47 Ident("x")) U32 Some([148, 149, 150, 151])
# Var t48 (t48 Ident("a")) U32 Some([136, 137, 138, 139])
# Var t49 (t49 Ident("mid")) U32 Some([136, 137, 138, 139])
# Var t5 (t5 Ident("a")) U32 Some([136, 137, 138, 139])
# Var t50 (Stack size) U32 Some([140, 141, 142, 143])
# Var t51 (t51 Ident("a")) U32 Some([136, 137, 138, 139])
# Var t52 (t52 Ident("x")) U32 Some([148, 149, 150, 151])
# Var t53 (t53 Ident("r")) U32 Some([148, 149, 150, 151])
# Var t54 (t54 Ident("b")) U32 Some([140, 141, 142, 143])
# Var t55 (t55 Ident("mid")) U32 Some([136, 137, 138, 139])
# Var t56 (Stack size) U32 Some([140, 141, 142, 143])
# Var t57 (t57 Ident("mid")) U32 Some([148, 149, 150, 151])
# Var t58 (t58 Number(USIZE, 1)) U32 Some([152, 153, 154, 155])
# Var t59 (t59 Ident("lo")) U32 Some([136, 137, 138, 139])
# Var t6 (t6 Number(USIZE, 256)) U32 Some([144, 145, 146, 147])
# Var t60 (Stack size) U32 Some([140, 141, 142, 143])
# Var t7 (t7 Ident("b")) U32 Some([140, 141, 142, 143])
# Var t8 (t8 Number(USIZE, 256)) U32 Some([144, 145, 146, 147])
# Var t9 (t9 Cast { old_type: None, new_type: Number(USIZE), value: Arithmetic(Divide, Index("a", Number(U8, 0)), Index("b", Number(U8, 0))) }) U32 Some([140, 141, 142, 143])
# Var x (Local x Number(USIZE) U32) U32 Some([160, 161, 162, 163])
# Var x64 (Local x64 Struct("U64") FrameOffset(0)) FrameOffset(0) None
# 81ef5 Instruction { source: "reserve 8 bytes of stack space for locals", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffff8=4294967288)], resolved: None }
a3 0c f8 ff ff ff 
# 81efb Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [136, 137, 138, 139].", opcode: Copy32, args: [Register(0x00), Register(0x88)], resolved: None }
81 00 88 
# 81efe Instruction { source: "Save function parameter 'b' registers [4, 5, 6, 7] to locals [140, 141, 142, 143].", opcode: Copy32, args: [Register(0x04), Register(0x8c)], resolved: None }
81 04 8c 
# 81f01 Instruction { source: "t0 <- 0xfffffff8u32 ", opcode: LoadImm32, args: [Register(0x90), Constant32(0xfffffff8=4294967288)], resolved: None }
80 90 f8 ff ff ff 
# 81f07 Instruction { source: "__frame_pointer <- __frame_pointer Add t0", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x90), Register(0x0c)], resolved: None }
a0 0c 90 0c 
# 81f0b Instruction { source: "t1 <- a U32", opcode: Copy32, args: [Register(0x88), Register(0x88)], resolved: None }
81 88 88 
# 81f0e Instruction { source: "t2 <- b U32", opcode: Copy32, args: [Register(0x8c), Register(0x8c)], resolved: None }
81 8c 8c 
# 81f11 Instruction { source: "if t1 < t2 then 'div32_if_true_0_1' else 'div32_if_else_0_2'", opcode: Cmp8, args: [Register(0x8f), Register(0x8b)], resolved: None }
25 8f 8b 
# 81f14 Instruction { source: "if t1 < t2 then 'div32_if_true_0_1' else 'div32_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x8e), Register(0x8a)], resolved: None }
26 8e 8a 
# 81f17 Instruction { source: "if t1 < t2 then 'div32_if_true_0_1' else 'div32_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x8d), Register(0x89)], resolved: None }
26 8d 89 
# 81f1a Instruction { source: "if t1 < t2 then 'div32_if_true_0_1' else 'div32_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x8c), Register(0x88)], resolved: None }
26 8c 88 
# 81f1d Instruction { source: "if t1 < t2 then 'div32_if_true_0_1' else 'div32_if_else_0_2'", opcode: JcImm, args: [Label24(div32_if_else_0_2)], resolved: None }
41 40 1f 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t1 < t2 then 'div32_if_true_0_1' else 'div32_if_else_0_2'", opcode: JmpImm, args: [Label24(div32_if_true_0_1)], resolved: None }
# div32_if_true_0_1
# 81f21 Instruction { source: "t3 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x88), Constant32(0x00000000=0)], resolved: None }
80 88 00 00 00 00 
# 81f27 Instruction { source: "t4 <- 0n8/0x00000008u32 ", opcode: LoadImm32, args: [Register(0x8c), Constant32(0x00000008=8)], resolved: None }
80 8c 08 00 00 00 
# 81f2d Instruction { source: "__frame_pointer <- __frame_pointer Add t4", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x8c), Register(0x0c)], resolved: None }
a0 0c 8c 0c 
# 81f31 Instruction { source: "return Some(t3)", opcode: Copy32, args: [Register(0x88), Register(0x00)], resolved: None }
81 88 00 
# 81f34 Instruction { source: "Dealloc 8 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000008=8)], resolved: None }
a3 0c 08 00 00 00 
# 81f3a Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81f3c Instruction { source: "goto div32_if_end_0", opcode: JmpImm, args: [Label24(div32_if_end_0)], resolved: None }
40 40 1f 08 
# div32_if_else_0_2
# div32_if_end_0
# 81f40 Instruction { source: "t5 <- a U32", opcode: Copy32, args: [Register(0x88), Register(0x88)], resolved: None }
81 88 88 
# 81f43 Instruction { source: "t6 <- 0n256/0x00000100u32 ", opcode: LoadImm32, args: [Register(0x90), Constant32(0x00000100=256)], resolved: None }
80 90 00 01 00 00 
# 81f49 Instruction { source: "if t5 < t6 then 'div32_if_true_0_4' else 'div32_if_else_0_5'", opcode: Cmp8, args: [Register(0x93), Register(0x8b)], resolved: None }
25 93 8b 
# 81f4c Instruction { source: "if t5 < t6 then 'div32_if_true_0_4' else 'div32_if_else_0_5'", opcode: Cmp8IfZero, args: [Register(0x92), Register(0x8a)], resolved: None }
26 92 8a 
# 81f4f Instruction { source: "if t5 < t6 then 'div32_if_true_0_4' else 'div32_if_else_0_5'", opcode: Cmp8IfZero, args: [Register(0x91), Register(0x89)], resolved: None }
26 91 89 
# 81f52 Instruction { source: "if t5 < t6 then 'div32_if_true_0_4' else 'div32_if_else_0_5'", opcode: Cmp8IfZero, args: [Register(0x90), Register(0x88)], resolved: None }
26 90 88 
# 81f55 Instruction { source: "if t5 < t6 then 'div32_if_true_0_4' else 'div32_if_else_0_5'", opcode: JcImm, args: [Label24(div32_if_else_0_5)], resolved: None }
41 a2 1f 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t5 < t6 then 'div32_if_true_0_4' else 'div32_if_else_0_5'", opcode: JmpImm, args: [Label24(div32_if_true_0_4)], resolved: None }
# div32_if_true_0_4
# 81f59 Instruction { source: "t7 <- b U32", opcode: Copy32, args: [Register(0x8c), Register(0x8c)], resolved: None }
81 8c 8c 
# 81f5c Instruction { source: "t8 <- 0n256/0x00000100u32 ", opcode: LoadImm32, args: [Register(0x90), Constant32(0x00000100=256)], resolved: None }
80 90 00 01 00 00 
# 81f62 Instruction { source: "if t7 < t8 then 'div32_if_true_0_7' else 'div32_if_else_0_8'", opcode: Cmp8, args: [Register(0x93), Register(0x8f)], resolved: None }
25 93 8f 
# 81f65 Instruction { source: "if t7 < t8 then 'div32_if_true_0_7' else 'div32_if_else_0_8'", opcode: Cmp8IfZero, args: [Register(0x92), Register(0x8e)], resolved: None }
26 92 8e 
# 81f68 Instruction { source: "if t7 < t8 then 'div32_if_true_0_7' else 'div32_if_else_0_8'", opcode: Cmp8IfZero, args: [Register(0x91), Register(0x8d)], resolved: None }
26 91 8d 
# 81f6b Instruction { source: "if t7 < t8 then 'div32_if_true_0_7' else 'div32_if_else_0_8'", opcode: Cmp8IfZero, args: [Register(0x90), Register(0x8c)], resolved: None }
26 90 8c 
# 81f6e Instruction { source: "if t7 < t8 then 'div32_if_true_0_7' else 'div32_if_else_0_8'", opcode: JcImm, args: [Label24(div32_if_else_0_8)], resolved: None }
41 9e 1f 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t7 < t8 then 'div32_if_true_0_7' else 'div32_if_else_0_8'", opcode: JmpImm, args: [Label24(div32_if_true_0_7)], resolved: None }
# div32_if_true_0_7
# 81f72 Instruction { source: "t11 <- a[0x00..0x01] U8", opcode: Copy8, args: [Register(0x88), Register(0x9c)], resolved: None }
16 88 9c 
# 81f75 Instruction { source: "t12 <- b[0x00..0x01] U8", opcode: Copy8, args: [Register(0x8c), Register(0x9d)], resolved: None }
16 8c 9d 
# 81f78 Instruction { source: "t10 <- t11 Divide t12", opcode: Divide8, args: [Register(0x9c), Register(0x9d), Register(0x9c)], resolved: None }
27 9c 9d 9c 
# 81f7c Instruction { source: "Zero-pad for t9 U32 <- t10 U8", opcode: LoadImm32, args: [Register(0x8c), Constant32(0x00000000=0)], resolved: None }
80 8c 00 00 00 00 
# 81f82 Instruction { source: "t9 U32 <- t10 U8", opcode: Copy8, args: [Register(0x9c), Register(0x8c)], resolved: None }
16 9c 8c 
# 81f85 Instruction { source: "t13 <- 0n8/0x00000008u32 ", opcode: LoadImm32, args: [Register(0x88), Constant32(0x00000008=8)], resolved: None }
80 88 08 00 00 00 
# 81f8b Instruction { source: "__frame_pointer <- __frame_pointer Add t13", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x88), Register(0x0c)], resolved: None }
a0 0c 88 0c 
# 81f8f Instruction { source: "return Some(t9)", opcode: Copy32, args: [Register(0x8c), Register(0x00)], resolved: None }
81 8c 00 
# 81f92 Instruction { source: "Dealloc 8 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000008=8)], resolved: None }
a3 0c 08 00 00 00 
# 81f98 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81f9a Instruction { source: "goto div32_if_end_6", opcode: JmpImm, args: [Label24(div32_if_end_6)], resolved: None }
40 9e 1f 08 
# div32_if_else_0_8
# div32_if_end_6
# 81f9e Instruction { source: "goto div32_if_end_3", opcode: JmpImm, args: [Label24(div32_if_end_3)], resolved: None }
40 a2 1f 08 
# div32_if_else_0_5
# div32_if_end_3
# 81fa2 Instruction { source: "t14 <- a U32", opcode: Copy32, args: [Register(0x88), Register(0x88)], resolved: None }
81 88 88 
# 81fa5 Instruction { source: "t15 <- 0n65536/0x00010000u32 ", opcode: LoadImm32, args: [Register(0x90), Constant32(0x00010000=65536)], resolved: None }
80 90 00 00 01 00 
# 81fab Instruction { source: "if t14 < t15 then 'div32_if_true_0_10' else 'div32_if_else_0_11'", opcode: Cmp8, args: [Register(0x93), Register(0x8b)], resolved: None }
25 93 8b 
# 81fae Instruction { source: "if t14 < t15 then 'div32_if_true_0_10' else 'div32_if_else_0_11'", opcode: Cmp8IfZero, args: [Register(0x92), Register(0x8a)], resolved: None }
26 92 8a 
# 81fb1 Instruction { source: "if t14 < t15 then 'div32_if_true_0_10' else 'div32_if_else_0_11'", opcode: Cmp8IfZero, args: [Register(0x91), Register(0x89)], resolved: None }
26 91 89 
# 81fb4 Instruction { source: "if t14 < t15 then 'div32_if_true_0_10' else 'div32_if_else_0_11'", opcode: Cmp8IfZero, args: [Register(0x90), Register(0x88)], resolved: None }
26 90 88 
# 81fb7 Instruction { source: "if t14 < t15 then 'div32_if_true_0_10' else 'div32_if_else_0_11'", opcode: JcImm, args: [Label24(div32_if_else_0_11)], resolved: None }
41 22 20 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t14 < t15 then 'div32_if_true_0_10' else 'div32_if_else_0_11'", opcode: JmpImm, args: [Label24(div32_if_true_0_10)], resolved: None }
# div32_if_true_0_10
# 81fbb Instruction { source: "t16 <- b U32", opcode: Copy32, args: [Register(0x8c), Register(0x8c)], resolved: None }
81 8c 8c 
# 81fbe Instruction { source: "t17 <- 0n65536/0x00010000u32 ", opcode: LoadImm32, args: [Register(0x90), Constant32(0x00010000=65536)], resolved: None }
80 90 00 00 01 00 
# 81fc4 Instruction { source: "if t16 < t17 then 'div32_if_true_0_13' else 'div32_if_else_0_14'", opcode: Cmp8, args: [Register(0x93), Register(0x8f)], resolved: None }
25 93 8f 
# 81fc7 Instruction { source: "if t16 < t17 then 'div32_if_true_0_13' else 'div32_if_else_0_14'", opcode: Cmp8IfZero, args: [Register(0x92), Register(0x8e)], resolved: None }
26 92 8e 
# 81fca Instruction { source: "if t16 < t17 then 'div32_if_true_0_13' else 'div32_if_else_0_14'", opcode: Cmp8IfZero, args: [Register(0x91), Register(0x8d)], resolved: None }
26 91 8d 
# 81fcd Instruction { source: "if t16 < t17 then 'div32_if_true_0_13' else 'div32_if_else_0_14'", opcode: Cmp8IfZero, args: [Register(0x90), Register(0x8c)], resolved: None }
26 90 8c 
# 81fd0 Instruction { source: "if t16 < t17 then 'div32_if_true_0_13' else 'div32_if_else_0_14'", opcode: JcImm, args: [Label24(div32_if_else_0_14)], resolved: None }
41 1e 20 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t16 < t17 then 'div32_if_true_0_13' else 'div32_if_else_0_14'", opcode: JmpImm, args: [Label24(div32_if_true_0_13)], resolved: None }
# div32_if_true_0_13
# 81fd4 Instruction { source: "t19 <- a U32", opcode: Copy32, args: [Register(0x88), Register(0x88)], resolved: None }
81 88 88 
# 81fd7 Instruction { source: "t20 <- b U32", opcode: Copy32, args: [Register(0x8c), Register(0x8c)], resolved: None }
81 8c 8c 
# 81fda Instruction { source: "Arg0[a]=t19 Some(t18) <= call div16(t19,t20,)", opcode: Copy32, args: [Register(0x88), Register(0x00)], resolved: None }
81 88 00 
# 81fdd Instruction { source: "Arg1[b]=t20 Some(t18) <= call div16(t19,t20,)", opcode: Copy32, args: [Register(0x8c), Register(0x04)], resolved: None }
81 8c 04 
# Registers used by this function: {136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 160, 161, 162, 163, 164, 168, 169, 170, 171, 172, 173, 174, 175}
# Registers used by callee tree: {108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137, 138, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225}
# Registers to save: [136, 137, 138]
# 81fe0 Instruction { source: "Saving reg0x8a before Some(t18) <= call div16(t19,t20,)", opcode: Push8, args: [Register(0x8a)], resolved: None }
14 8a 
# 81fe2 Instruction { source: "Saving reg0x89 before Some(t18) <= call div16(t19,t20,)", opcode: Push8, args: [Register(0x89)], resolved: None }
14 89 
# 81fe4 Instruction { source: "Saving reg0x88 before Some(t18) <= call div16(t19,t20,)", opcode: Push8, args: [Register(0x88)], resolved: None }
14 88 
# 81fe6 Instruction { source: "PseudoCall(Label24(:div16))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81fec Instruction { source: "PseudoCall(Label24(:div16))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c f6 1f 08 00 
# 81ff2 Instruction { source: "PseudoCall(Label24(:div16))", opcode: JmpImm, args: [Label24(:div16)], resolved: None }
40 2a 1d 08 
# 81ff6 Instruction { source: "PseudoCall(Label24(:div16))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81ffc Instruction { source: "Restoring reg0x88 after Some(t18) <= call div16(t19,t20,)", opcode: Pop8, args: [Register(0x88)], resolved: None }
15 88 
# 81ffe Instruction { source: "Restoring reg0x89 after Some(t18) <= call div16(t19,t20,)", opcode: Pop8, args: [Register(0x89)], resolved: None }
15 89 
# 82000 Instruction { source: "Restoring reg0x8a after Some(t18) <= call div16(t19,t20,)", opcode: Pop8, args: [Register(0x8a)], resolved: None }
15 8a 
# 82002 Instruction { source: "Some(t18) <= call div16(t19,t20,)", opcode: Copy32, args: [Register(0x00), Register(0x88)], resolved: None }
81 00 88 
# 82005 Instruction { source: "t21 <- 0n8/0x00000008u32 ", opcode: LoadImm32, args: [Register(0x8c), Constant32(0x00000008=8)], resolved: None }
80 8c 08 00 00 00 
# 8200b Instruction { source: "__frame_pointer <- __frame_pointer Add t21", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x8c), Register(0x0c)], resolved: None }
a0 0c 8c 0c 
# 8200f Instruction { source: "return Some(t18)", opcode: Copy32, args: [Register(0x88), Register(0x00)], resolved: None }
81 88 00 
# 82012 Instruction { source: "Dealloc 8 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000008=8)], resolved: None }
a3 0c 08 00 00 00 
# 82018 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 8201a Instruction { source: "goto div32_if_end_12", opcode: JmpImm, args: [Label24(div32_if_end_12)], resolved: None }
40 1e 20 08 
# div32_if_else_0_14
# div32_if_end_12
# 8201e Instruction { source: "goto div32_if_end_9", opcode: JmpImm, args: [Label24(div32_if_end_9)], resolved: None }
40 22 20 08 
# div32_if_else_0_11
# div32_if_end_9
# 82022 Instruction { source: "lo <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x94), Constant32(0x00000000=0)], resolved: None }
80 94 00 00 00 00 
# 82028 Instruction { source: "hi <- 0xffffffffu32 ", opcode: LoadImm32, args: [Register(0x90), Constant32(0xffffffff=4294967295)], resolved: None }
80 90 ff ff ff ff 
# div32_while_predicate_15
# 8202e Instruction { source: "t22 <- lo U32", opcode: Copy32, args: [Register(0x94), Register(0x94)], resolved: None }
81 94 94 
# 82031 Instruction { source: "t23 <- hi U32", opcode: Copy32, args: [Register(0x90), Register(0x90)], resolved: None }
81 90 90 
# 82034 Instruction { source: "if t22 < t23 then 'div32_while_body_16' else 'div32_while_end_17'", opcode: Cmp8, args: [Register(0x93), Register(0x97)], resolved: None }
25 93 97 
# 82037 Instruction { source: "if t22 < t23 then 'div32_while_body_16' else 'div32_while_end_17'", opcode: Cmp8IfZero, args: [Register(0x92), Register(0x96)], resolved: None }
26 92 96 
# 8203a Instruction { source: "if t22 < t23 then 'div32_while_body_16' else 'div32_while_end_17'", opcode: Cmp8IfZero, args: [Register(0x91), Register(0x95)], resolved: None }
26 91 95 
# 8203d Instruction { source: "if t22 < t23 then 'div32_while_body_16' else 'div32_while_end_17'", opcode: Cmp8IfZero, args: [Register(0x90), Register(0x94)], resolved: None }
26 90 94 
# 82040 Instruction { source: "if t22 < t23 then 'div32_while_body_16' else 'div32_while_end_17'", opcode: JcImm, args: [Label24(div32_while_end_17)], resolved: None }
41 f5 21 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t22 < t23 then 'div32_while_body_16' else 'div32_while_end_17'", opcode: JmpImm, args: [Label24(div32_while_body_16)], resolved: None }
# div32_while_body_16
# 82044 Instruction { source: "t25 <- lo U32", opcode: Copy32, args: [Register(0x94), Register(0x94)], resolved: None }
81 94 94 
# 82047 Instruction { source: "Arg0[a]=t25 Some(t24) <= call shiftright1(t25,)", opcode: Copy32, args: [Register(0x94), Register(0x00)], resolved: None }
81 94 00 
# Registers used by this function: {136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 160, 161, 162, 163, 164, 168, 169, 170, 171, 172, 173, 174, 175}
# Registers used by callee tree: {132, 133, 134, 135, 136, 137, 138}
# Registers to save: [136, 137, 138]
# 8204a Instruction { source: "Saving reg0x8a before Some(t24) <= call shiftright1(t25,)", opcode: Push8, args: [Register(0x8a)], resolved: None }
14 8a 
# 8204c Instruction { source: "Saving reg0x89 before Some(t24) <= call shiftright1(t25,)", opcode: Push8, args: [Register(0x89)], resolved: None }
14 89 
# 8204e Instruction { source: "Saving reg0x88 before Some(t24) <= call shiftright1(t25,)", opcode: Push8, args: [Register(0x88)], resolved: None }
14 88 
# 82050 Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82056 Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 60 20 08 00 
# 8205c Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: JmpImm, args: [Label24(:shiftright1)], resolved: None }
40 39 2a 08 
# 82060 Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82066 Instruction { source: "Restoring reg0x88 after Some(t24) <= call shiftright1(t25,)", opcode: Pop8, args: [Register(0x88)], resolved: None }
15 88 
# 82068 Instruction { source: "Restoring reg0x89 after Some(t24) <= call shiftright1(t25,)", opcode: Pop8, args: [Register(0x89)], resolved: None }
15 89 
# 8206a Instruction { source: "Restoring reg0x8a after Some(t24) <= call shiftright1(t25,)", opcode: Pop8, args: [Register(0x8a)], resolved: None }
15 8a 
# 8206c Instruction { source: "Some(t24) <= call shiftright1(t25,)", opcode: Copy32, args: [Register(0x00), Register(0x98)], resolved: None }
81 00 98 
# 8206f Instruction { source: "t27 <- hi U32", opcode: Copy32, args: [Register(0x90), Register(0x90)], resolved: None }
81 90 90 
# 82072 Instruction { source: "Arg0[a]=t27 Some(t26) <= call shiftright1(t27,)", opcode: Copy32, args: [Register(0x90), Register(0x00)], resolved: None }
81 90 00 
# Registers used by this function: {136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 160, 161, 162, 163, 164, 168, 169, 170, 171, 172, 173, 174, 175}
# Registers used by callee tree: {132, 133, 134, 135, 136, 137, 138}
# Registers to save: [136, 137, 138]
# 82075 Instruction { source: "Saving reg0x8a before Some(t26) <= call shiftright1(t27,)", opcode: Push8, args: [Register(0x8a)], resolved: None }
14 8a 
# 82077 Instruction { source: "Saving reg0x89 before Some(t26) <= call shiftright1(t27,)", opcode: Push8, args: [Register(0x89)], resolved: None }
14 89 
# 82079 Instruction { source: "Saving reg0x88 before Some(t26) <= call shiftright1(t27,)", opcode: Push8, args: [Register(0x88)], resolved: None }
14 88 
# 8207b Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82081 Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 8b 20 08 00 
# 82087 Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: JmpImm, args: [Label24(:shiftright1)], resolved: None }
40 39 2a 08 
# 8208b Instruction { source: "PseudoCall(Label24(:shiftright1))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82091 Instruction { source: "Restoring reg0x88 after Some(t26) <= call shiftright1(t27,)", opcode: Pop8, args: [Register(0x88)], resolved: None }
15 88 
# 82093 Instruction { source: "Restoring reg0x89 after Some(t26) <= call shiftright1(t27,)", opcode: Pop8, args: [Register(0x89)], resolved: None }
15 89 
# 82095 Instruction { source: "Restoring reg0x8a after Some(t26) <= call shiftright1(t27,)", opcode: Pop8, args: [Register(0x8a)], resolved: None }
15 8a 
# 82097 Instruction { source: "Some(t26) <= call shiftright1(t27,)", opcode: Copy32, args: [Register(0x00), Register(0xa0)], resolved: None }
81 00 a0 
# 8209a Instruction { source: "mid <- t24 Add t26", opcode: Add32NoCarryIn, args: [Register(0x98), Register(0xa0), Register(0x98)], resolved: None }
a0 98 a0 98 
# 8209e Instruction { source: "t29 <- mid U32", opcode: Copy32, args: [Register(0x98), Register(0x98)], resolved: None }
81 98 98 
# 820a1 Instruction { source: "t30 <- b U32", opcode: Copy32, args: [Register(0x8c), Register(0x8c)], resolved: None }
81 8c 8c 
# 820a4 Instruction { source: "t33 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0xa8)], resolved: None }
81 0c a8 
# 820a7 Instruction { source: "t34 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0xa0), Constant32(0x00000000=0)], resolved: None }
80 a0 00 00 00 00 
# 820ad Instruction { source: "t32 <- t33 Add t34", opcode: Add32NoCarryIn, args: [Register(0xa8), Register(0xa0), Register(0xa0)], resolved: None }
a0 a8 a0 a0 
# 820b1 Instruction { source: "t31 <- t32 U32", opcode: Copy32, args: [Register(0xa0), Register(0xa0)], resolved: None }
81 a0 a0 
# 820b4 Instruction { source: "Arg0[a]=t29 None <= call mul32_64(t29,t30,t31,)", opcode: Copy32, args: [Register(0x98), Register(0x00)], resolved: None }
81 98 00 
# 820b7 Instruction { source: "Arg1[b]=t30 None <= call mul32_64(t29,t30,t31,)", opcode: Copy32, args: [Register(0x8c), Register(0x04)], resolved: None }
81 8c 04 
# 820ba Instruction { source: "Arg2[c]=t31 None <= call mul32_64(t29,t30,t31,)", opcode: Copy32, args: [Register(0xa0), Register(0x08)], resolved: None }
81 a0 08 
# Registers used by this function: {136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 160, 161, 162, 163, 164, 168, 169, 170, 171, 172, 173, 174, 175}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225, 252, 253, 254, 255}
# Registers to save: []
# 820bd Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 820c3 Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c cd 20 08 00 
# 820c9 Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: JmpImm, args: [Label24(:mul32_64)], resolved: None }
40 ee 24 08 
# 820cd Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 820d3 Instruction { source: "t37 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0xa8)], resolved: None }
81 0c a8 
# 820d6 Instruction { source: "t38 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0xa0), Constant32(0x00000004=4)], resolved: None }
80 a0 04 00 00 00 
# 820dc Instruction { source: "t36 <- t37 Add t38", opcode: Add32NoCarryIn, args: [Register(0xa8), Register(0xa0), Register(0xa0)], resolved: None }
a0 a8 a0 a0 
# 820e0 Instruction { source: "t35 <- mem[t36] U32", opcode: Load32, args: [Register(0xa0), Register(0xa0)], resolved: None }
90 a0 a0 
# 820e3 Instruction { source: "t39 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0xac), Constant32(0x00000000=0)], resolved: None }
80 ac 00 00 00 00 
# 820e9 Instruction { source: "if t35 > t39 then 'div32_if_true_0_19' else 'div32_if_else_0_20'", opcode: Cmp8, args: [Register(0xa3), Register(0xaf)], resolved: None }
25 a3 af 
# 820ec Instruction { source: "if t35 > t39 then 'div32_if_true_0_19' else 'div32_if_else_0_20'", opcode: Cmp8IfZero, args: [Register(0xa2), Register(0xae)], resolved: None }
26 a2 ae 
# 820ef Instruction { source: "if t35 > t39 then 'div32_if_true_0_19' else 'div32_if_else_0_20'", opcode: Cmp8IfZero, args: [Register(0xa1), Register(0xad)], resolved: None }
26 a1 ad 
# 820f2 Instruction { source: "if t35 > t39 then 'div32_if_true_0_19' else 'div32_if_else_0_20'", opcode: Cmp8IfZero, args: [Register(0xa0), Register(0xac)], resolved: None }
26 a0 ac 
# 820f5 Instruction { source: "if t35 > t39 then 'div32_if_true_0_19' else 'div32_if_else_0_20'", opcode: JcImm, args: [Label24(div32_if_else_0_20)], resolved: None }
41 1f 21 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t35 > t39 then 'div32_if_true_0_19' else 'div32_if_else_0_20'", opcode: JmpImm, args: [Label24(div32_if_true_0_19)], resolved: None }
# div32_if_true_0_19
# 820f9 Instruction { source: "t40 <- mid U32", opcode: Copy32, args: [Register(0x98), Register(0x90)], resolved: None }
81 98 90 
# 820fc Instruction { source: "t41 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x98), Constant32(0x00000001=1)], resolved: None }
80 98 01 00 00 00 
# 82102 Instruction { source: "hi <- t40 Subtract t41", opcode: Copy32, args: [Register(0x98), Register(0x00)], resolved: None }
81 98 00 
# 82105 Instruction { source: "hi <- t40 Subtract t41", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 82107 Instruction { source: "hi <- t40 Subtract t41", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 82109 Instruction { source: "hi <- t40 Subtract t41", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 8210b Instruction { source: "hi <- t40 Subtract t41", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 8210d Instruction { source: "hi <- t40 Subtract t41", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 82113 Instruction { source: "hi <- t40 Subtract t41", opcode: Add32NoCarryIn, args: [Register(0x90), Register(0x00), Register(0x90)], resolved: None }
a0 90 00 90 
# 82117 Instruction { source: "goto div32_while_predicate_15", opcode: JmpImm, args: [Label24(div32_while_predicate_15)], resolved: None }
40 2e 20 08 
# 8211b Instruction { source: "goto div32_if_end_18", opcode: JmpImm, args: [Label24(div32_if_end_18)], resolved: None }
40 1f 21 08 
# div32_if_else_0_20
# div32_if_end_18
# 8211f Instruction { source: "t42 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0xa8)], resolved: None }
81 0c a8 
# 82122 Instruction { source: "x <- mem[t42] U32", opcode: Load32, args: [Register(0xa8), Register(0xa0)], resolved: None }
90 a8 a0 
# 82125 Instruction { source: "t43 <- x U32", opcode: Copy32, args: [Register(0xa0), Register(0xa0)], resolved: None }
81 a0 a0 
# 82128 Instruction { source: "t44 <- a U32", opcode: Copy32, args: [Register(0x88), Register(0x88)], resolved: None }
81 88 88 
# 8212b Instruction { source: "if t43 > t44 then 'div32_if_true_0_22' else 'div32_if_else_0_23'", opcode: Cmp8, args: [Register(0xa3), Register(0x8b)], resolved: None }
25 a3 8b 
# 8212e Instruction { source: "if t43 > t44 then 'div32_if_true_0_22' else 'div32_if_else_0_23'", opcode: Cmp8IfZero, args: [Register(0xa2), Register(0x8a)], resolved: None }
26 a2 8a 
# 82131 Instruction { source: "if t43 > t44 then 'div32_if_true_0_22' else 'div32_if_else_0_23'", opcode: Cmp8IfZero, args: [Register(0xa1), Register(0x89)], resolved: None }
26 a1 89 
# 82134 Instruction { source: "if t43 > t44 then 'div32_if_true_0_22' else 'div32_if_else_0_23'", opcode: Cmp8IfZero, args: [Register(0xa0), Register(0x88)], resolved: None }
26 a0 88 
# 82137 Instruction { source: "if t43 > t44 then 'div32_if_true_0_22' else 'div32_if_else_0_23'", opcode: JcImm, args: [Label24(div32_if_else_0_23)], resolved: None }
41 61 21 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t43 > t44 then 'div32_if_true_0_22' else 'div32_if_else_0_23'", opcode: JmpImm, args: [Label24(div32_if_true_0_22)], resolved: None }
# div32_if_true_0_22
# 8213b Instruction { source: "t45 <- mid U32", opcode: Copy32, args: [Register(0x98), Register(0x90)], resolved: None }
81 98 90 
# 8213e Instruction { source: "t46 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x98), Constant32(0x00000001=1)], resolved: None }
80 98 01 00 00 00 
# 82144 Instruction { source: "hi <- t45 Subtract t46", opcode: Copy32, args: [Register(0x98), Register(0x00)], resolved: None }
81 98 00 
# 82147 Instruction { source: "hi <- t45 Subtract t46", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 82149 Instruction { source: "hi <- t45 Subtract t46", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 8214b Instruction { source: "hi <- t45 Subtract t46", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 8214d Instruction { source: "hi <- t45 Subtract t46", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 8214f Instruction { source: "hi <- t45 Subtract t46", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 82155 Instruction { source: "hi <- t45 Subtract t46", opcode: Add32NoCarryIn, args: [Register(0x90), Register(0x00), Register(0x90)], resolved: None }
a0 90 00 90 
# 82159 Instruction { source: "goto div32_while_predicate_15", opcode: JmpImm, args: [Label24(div32_while_predicate_15)], resolved: None }
40 2e 20 08 
# 8215d Instruction { source: "goto div32_if_end_21", opcode: JmpImm, args: [Label24(div32_if_end_21)], resolved: None }
40 61 21 08 
# div32_if_else_0_23
# div32_if_end_21
# 82161 Instruction { source: "t47 <- x U32", opcode: Copy32, args: [Register(0xa0), Register(0x94)], resolved: None }
81 a0 94 
# 82164 Instruction { source: "t48 <- a U32", opcode: Copy32, args: [Register(0x88), Register(0x88)], resolved: None }
81 88 88 
# 82167 Instruction { source: "if t47 == t48 then 'div32_if_true_0_25' else 'div32_if_else_0_26'", opcode: Cmp8, args: [Register(0x97), Register(0x8b)], resolved: None }
25 97 8b 
# 8216a Instruction { source: "if t47 == t48 then 'div32_if_true_0_25' else 'div32_if_else_0_26'", opcode: Cmp8IfZero, args: [Register(0x96), Register(0x8a)], resolved: None }
26 96 8a 
# 8216d Instruction { source: "if t47 == t48 then 'div32_if_true_0_25' else 'div32_if_else_0_26'", opcode: Cmp8IfZero, args: [Register(0x95), Register(0x89)], resolved: None }
26 95 89 
# 82170 Instruction { source: "if t47 == t48 then 'div32_if_true_0_25' else 'div32_if_else_0_26'", opcode: Cmp8IfZero, args: [Register(0x94), Register(0x88)], resolved: None }
26 94 88 
# 82173 Instruction { source: "if t47 == t48 then 'div32_if_true_0_25' else 'div32_if_else_0_26'", opcode: JzImm, args: [Label24(div32_if_true_0_25)], resolved: None }
42 7b 21 08 
# 82177 Instruction { source: "if t47 == t48 then 'div32_if_true_0_25' else 'div32_if_else_0_26'", opcode: JmpImm, args: [Label24(div32_if_else_0_26)], resolved: None }
40 97 21 08 
# div32_if_true_0_25
# 8217b Instruction { source: "t49 <- mid U32", opcode: Copy32, args: [Register(0x98), Register(0x88)], resolved: None }
81 98 88 
# 8217e Instruction { source: "t50 <- 0n8/0x00000008u32 ", opcode: LoadImm32, args: [Register(0x8c), Constant32(0x00000008=8)], resolved: None }
80 8c 08 00 00 00 
# 82184 Instruction { source: "__frame_pointer <- __frame_pointer Add t50", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x8c), Register(0x0c)], resolved: None }
a0 0c 8c 0c 
# 82188 Instruction { source: "return Some(t49)", opcode: Copy32, args: [Register(0x88), Register(0x00)], resolved: None }
81 88 00 
# 8218b Instruction { source: "Dealloc 8 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000008=8)], resolved: None }
a3 0c 08 00 00 00 
# 82191 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82193 Instruction { source: "goto div32_if_end_24", opcode: JmpImm, args: [Label24(div32_if_end_24)], resolved: None }
40 97 21 08 
# div32_if_else_0_26
# div32_if_end_24
# 82197 Instruction { source: "t51 <- a U32", opcode: Copy32, args: [Register(0x88), Register(0x88)], resolved: None }
81 88 88 
# 8219a Instruction { source: "t52 <- x U32", opcode: Copy32, args: [Register(0xa0), Register(0x94)], resolved: None }
81 a0 94 
# 8219d Instruction { source: "r <- t51 Subtract t52", opcode: Copy32, args: [Register(0x94), Register(0x00)], resolved: None }
81 94 00 
# 821a0 Instruction { source: "r <- t51 Subtract t52", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 821a2 Instruction { source: "r <- t51 Subtract t52", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 821a4 Instruction { source: "r <- t51 Subtract t52", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 821a6 Instruction { source: "r <- t51 Subtract t52", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 821a8 Instruction { source: "r <- t51 Subtract t52", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 821ae Instruction { source: "r <- t51 Subtract t52", opcode: Add32NoCarryIn, args: [Register(0x88), Register(0x00), Register(0x94)], resolved: None }
a0 88 00 94 
# 821b2 Instruction { source: "t53 <- r U32", opcode: Copy32, args: [Register(0x94), Register(0x94)], resolved: None }
81 94 94 
# 821b5 Instruction { source: "t54 <- b U32", opcode: Copy32, args: [Register(0x8c), Register(0x8c)], resolved: None }
81 8c 8c 
# 821b8 Instruction { source: "if t53 < t54 then 'div32_if_true_0_28' else 'div32_if_else_0_29'", opcode: Cmp8, args: [Register(0x8f), Register(0x97)], resolved: None }
25 8f 97 
# 821bb Instruction { source: "if t53 < t54 then 'div32_if_true_0_28' else 'div32_if_else_0_29'", opcode: Cmp8IfZero, args: [Register(0x8e), Register(0x96)], resolved: None }
26 8e 96 
# 821be Instruction { source: "if t53 < t54 then 'div32_if_true_0_28' else 'div32_if_else_0_29'", opcode: Cmp8IfZero, args: [Register(0x8d), Register(0x95)], resolved: None }
26 8d 95 
# 821c1 Instruction { source: "if t53 < t54 then 'div32_if_true_0_28' else 'div32_if_else_0_29'", opcode: Cmp8IfZero, args: [Register(0x8c), Register(0x94)], resolved: None }
26 8c 94 
# 821c4 Instruction { source: "if t53 < t54 then 'div32_if_true_0_28' else 'div32_if_else_0_29'", opcode: JcImm, args: [Label24(div32_if_else_0_29)], resolved: None }
41 e4 21 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t53 < t54 then 'div32_if_true_0_28' else 'div32_if_else_0_29'", opcode: JmpImm, args: [Label24(div32_if_true_0_28)], resolved: None }
# div32_if_true_0_28
# 821c8 Instruction { source: "t55 <- mid U32", opcode: Copy32, args: [Register(0x98), Register(0x88)], resolved: None }
81 98 88 
# 821cb Instruction { source: "t56 <- 0n8/0x00000008u32 ", opcode: LoadImm32, args: [Register(0x8c), Constant32(0x00000008=8)], resolved: None }
80 8c 08 00 00 00 
# 821d1 Instruction { source: "__frame_pointer <- __frame_pointer Add t56", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x8c), Register(0x0c)], resolved: None }
a0 0c 8c 0c 
# 821d5 Instruction { source: "return Some(t55)", opcode: Copy32, args: [Register(0x88), Register(0x00)], resolved: None }
81 88 00 
# 821d8 Instruction { source: "Dealloc 8 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000008=8)], resolved: None }
a3 0c 08 00 00 00 
# 821de Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 821e0 Instruction { source: "goto div32_if_end_27", opcode: JmpImm, args: [Label24(div32_if_end_27)], resolved: None }
40 e4 21 08 
# div32_if_else_0_29
# div32_if_end_27
# 821e4 Instruction { source: "t57 <- mid U32", opcode: Copy32, args: [Register(0x98), Register(0x94)], resolved: None }
81 98 94 
# 821e7 Instruction { source: "t58 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x98), Constant32(0x00000001=1)], resolved: None }
80 98 01 00 00 00 
# 821ed Instruction { source: "lo <- t57 Add t58", opcode: Add32NoCarryIn, args: [Register(0x94), Register(0x98), Register(0x94)], resolved: None }
a0 94 98 94 
# 821f1 Instruction { source: "goto div32_while_predicate_15", opcode: JmpImm, args: [Label24(div32_while_predicate_15)], resolved: None }
40 2e 20 08 
# div32_while_end_17
# 821f5 Instruction { source: "t59 <- lo U32", opcode: Copy32, args: [Register(0x94), Register(0x88)], resolved: None }
81 94 88 
# 821f8 Instruction { source: "t60 <- 0n8/0x00000008u32 ", opcode: LoadImm32, args: [Register(0x8c), Constant32(0x00000008=8)], resolved: None }
80 8c 08 00 00 00 
# 821fe Instruction { source: "__frame_pointer <- __frame_pointer Add t60", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x8c), Register(0x0c)], resolved: None }
a0 0c 8c 0c 
# 82202 Instruction { source: "return Some(t59)", opcode: Copy32, args: [Register(0x88), Register(0x00)], resolved: None }
81 88 00 
# 82205 Instruction { source: "Dealloc 8 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000008=8)], resolved: None }
a3 0c 08 00 00 00 
# 8220b Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 8220d Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :getchar
# Ret Some(U8)
# Var t0 (t0 Arithmetic(And, Ident("tty"), Number(U8, 128))) U8 Some([176])
# Var t1 (t1 Ident("tty")) U8 Some([176])
# Var t2 (t2 Number(U8, 128)) U8 Some([177])
# Var t3 (t3 Number(U8, 0)) U8 Some([177])
# Var t4 (t4 Arithmetic(And, Ident("tty"), Number(U8, 127))) U8 Some([176])
# Var t5 (t5 Ident("tty")) U8 Some([176])
# Var t6 (t6 Number(U8, 127)) U8 Some([177])
# Var tty (Local tty Number(U8) U8) U8 Some([178])
# 82212 Instruction { source: "tty <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xb2), Constant8(0x00=0)], resolved: None }
00 b2 00 
# getchar_while_predicate_0
# 82215 Instruction { source: "t1 <- tty U8", opcode: Copy8, args: [Register(0xb2), Register(0xb0)], resolved: None }
16 b2 b0 
# 82218 Instruction { source: "t2 <- 0n128/0x80u8 ", opcode: LoadImm8, args: [Register(0xb1), Constant8(0x80=128)], resolved: None }
00 b1 80 
# 8221b Instruction { source: "t0 <- t1 BitwiseAnd t2", opcode: And8, args: [Register(0xb0), Register(0xb1), Register(0xb0)], resolved: None }
33 b0 b1 b0 
# 8221f Instruction { source: "t3 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xb1), Constant8(0x00=0)], resolved: None }
00 b1 00 
# 82222 Instruction { source: "if t0 == t3 then 'getchar_while_body_1' else 'getchar_while_end_2'", opcode: Cmp8, args: [Register(0xb0), Register(0xb1)], resolved: None }
25 b0 b1 
# 82225 Instruction { source: "if t0 == t3 then 'getchar_while_body_1' else 'getchar_while_end_2'", opcode: JzImm, args: [Label24(getchar_while_body_1)], resolved: None }
42 2d 22 08 
# 82229 Instruction { source: "if t0 == t3 then 'getchar_while_body_1' else 'getchar_while_end_2'", opcode: JmpImm, args: [Label24(getchar_while_end_2)], resolved: None }
40 33 22 08 
# getchar_while_body_1
# 8222d Instruction { source: "tty <- ttyin", opcode: TtyIn, args: [Register(0xb2)], resolved: None }
12 b2 
# 8222f Instruction { source: "goto getchar_while_predicate_0", opcode: JmpImm, args: [Label24(getchar_while_predicate_0)], resolved: None }
40 15 22 08 
# getchar_while_end_2
# 82233 Instruction { source: "t5 <- tty U8", opcode: Copy8, args: [Register(0xb2), Register(0xb0)], resolved: None }
16 b2 b0 
# 82236 Instruction { source: "t6 <- 0n127/0x7fu8 ", opcode: LoadImm8, args: [Register(0xb1), Constant8(0x7f=127)], resolved: None }
00 b1 7f 
# 82239 Instruction { source: "t4 <- t5 BitwiseAnd t6", opcode: And8, args: [Register(0xb0), Register(0xb1), Register(0xb0)], resolved: None }
33 b0 b1 b0 
# 8223d Instruction { source: "return Some(t4)", opcode: Copy8, args: [Register(0xb0), Register(0x00)], resolved: None }
16 b0 00 
# 82240 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82242 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :main
# Ret Some(U8)
# Var __frame_pointer (__frame_pointer) U32 Some([12, 13, 14, 15])
# Var calc (Local calc Ptr(Struct("RpnCalc")) U32) U32 Some([180, 181, 182, 183])
# Var calcs (Local calcs Array(Struct("RpnCalc"), 8) FrameOffset(0)) FrameOffset(0) None
# Var ch (Local ch Number(U8) U8) U8 Some([184])
# Var result (Local result Number(U8) U8) U8 Some([184])
# Var t0 (Stack size negated) U32 Some([180, 181, 182, 183])
# Var t1 (t1 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Struct("RpnCalc")), value: Arithmetic(Add, Ident("__frame_pointer"), Arithmetic(Multiply, Number(USIZE, 0), Number(USIZE, 76))) }) U32 Some([180, 181, 182, 183])
# Var t10 (t10 Ident("calc")) U32 Some([180, 181, 182, 183])
# Var t11 (t11 Ident("ch")) U8 Some([184])
# Var t12 (t12 Ident("result")) U8 Some([184])
# Var t13 (t13 Number(U8, 0)) U8 Some([185])
# Var t14 (t14 Number(U8, 0)) U8 Some([186])
# Var t15 (Stack size) U32 Some([188, 189, 190, 191])
# Var t2 (t2 Ident("__frame_pointer")) U32 Some([192, 193, 194, 195])
# Var t3 (t3 Arithmetic(Multiply, Number(USIZE, 0), Number(USIZE, 76))) U32 Some([180, 181, 182, 183])
# Var t4 (t4 Number(USIZE, 0)) U32 Some([180, 181, 182, 183])
# Var t5 (t5 Number(USIZE, 76)) U32 Some([188, 189, 190, 191])
# Var t6 (t6 Call(Call { function: "RpnCalc_init", parameters: [Ident("calc")] })) U8 Some([196])
# Var t7 (t7 Ident("calc")) U32 Some([180, 181, 182, 183])
# Var t8 (t8 Number(U8, 0)) U8 Some([184])
# Var t9 (t9 Number(U8, 0)) U8 Some([185])
# 82247 Instruction { source: "reserve 608 bytes of stack space for locals", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffda0=4294966688)], resolved: None }
a3 0c a0 fd ff ff 
# 8224d Instruction { source: "t0 <- 0xfffffda0u32 ", opcode: LoadImm32, args: [Register(0xb4), Constant32(0xfffffda0=4294966688)], resolved: None }
80 b4 a0 fd ff ff 
# 82253 Instruction { source: "__frame_pointer <- __frame_pointer Add t0", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0xb4), Register(0x0c)], resolved: None }
a0 0c b4 0c 
# 82257 Instruction { source: "t2 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0xc0)], resolved: None }
81 0c c0 
# 8225a Instruction { source: "t4 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0xb4), Constant32(0x00000000=0)], resolved: None }
80 b4 00 00 00 00 
# 82260 Instruction { source: "t5 <- 0n76/0x0000004cu32 ", opcode: LoadImm32, args: [Register(0xbc), Constant32(0x0000004c=76)], resolved: None }
80 bc 4c 00 00 00 
# 82266 Instruction { source: "t3 <- t4 Multiply t5", opcode: LoadImm32, args: [Register(0x00), Constant32(0x00000000=0)], resolved: None }
80 00 00 00 00 00 
# 8226c Instruction { source: "t3 <- t4 Multiply t5", opcode: Mul8_1, args: [Register(0xb4), Register(0xbc)], resolved: None }
20 b4 bc 
# 8226f Instruction { source: "t3 <- t4 Multiply t5", opcode: Mul8_2, args: [], resolved: None }
21 
# 82270 Instruction { source: "t3 <- t4 Multiply t5", opcode: Copy32, args: [Register(0x00), Register(0xb4)], resolved: None }
81 00 b4 
# 82273 Instruction { source: "t1 <- t2 Add t3", opcode: Add32NoCarryIn, args: [Register(0xc0), Register(0xb4), Register(0xb4)], resolved: None }
a0 c0 b4 b4 
# 82277 Instruction { source: "calc <- t1 U32", opcode: Copy32, args: [Register(0xb4), Register(0xb4)], resolved: None }
81 b4 b4 
# 8227a Instruction { source: "t7 <- calc U32", opcode: Copy32, args: [Register(0xb4), Register(0xb4)], resolved: None }
81 b4 b4 
# 8227d Instruction { source: "Arg0[c]=t7 None <= call RpnCalc_init(t7,)", opcode: Copy32, args: [Register(0xb4), Register(0x00)], resolved: None }
81 b4 00 
# Registers used by this function: {180, 181, 182, 183, 184, 185, 186, 188, 189, 190, 191, 192, 193, 194, 195, 196}
# Registers used by callee tree: {48, 49, 50, 51, 52, 53, 54, 55, 56, 152, 153, 154, 155, 156, 157, 158, 159}
# Registers to save: []
# 82280 Instruction { source: "PseudoCall(Label24(:RpnCalc_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82286 Instruction { source: "PseudoCall(Label24(:RpnCalc_init))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 90 22 08 00 
# 8228c Instruction { source: "PseudoCall(Label24(:RpnCalc_init))", opcode: JmpImm, args: [Label24(:RpnCalc_init)], resolved: None }
40 b9 1b 08 
# 82290 Instruction { source: "PseudoCall(Label24(:RpnCalc_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# main_while_predicate_0
# 82296 Instruction { source: "t8 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xb8), Constant8(0x00=0)], resolved: None }
00 b8 00 
# 82299 Instruction { source: "t9 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xb9), Constant8(0x00=0)], resolved: None }
00 b9 00 
# 8229c Instruction { source: "if t8 == t9 then 'main_while_body_1' else 'main_while_end_2'", opcode: Cmp8, args: [Register(0xb8), Register(0xb9)], resolved: None }
25 b8 b9 
# 8229f Instruction { source: "if t8 == t9 then 'main_while_body_1' else 'main_while_end_2'", opcode: JzImm, args: [Label24(main_while_body_1)], resolved: None }
42 a7 22 08 
# 822a3 Instruction { source: "if t8 == t9 then 'main_while_body_1' else 'main_while_end_2'", opcode: JmpImm, args: [Label24(main_while_end_2)], resolved: None }
40 52 23 08 
# main_while_body_1
# Registers used by this function: {180, 181, 182, 183, 184, 185, 186, 188, 189, 190, 191, 192, 193, 194, 195, 196}
# Registers used by callee tree: {176, 177, 178}
# Registers to save: []
# 822a7 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 822ad Instruction { source: "PseudoCall(Label24(:getchar))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c b7 22 08 00 
# 822b3 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: JmpImm, args: [Label24(:getchar)], resolved: None }
40 12 22 08 
# 822b7 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 822bd Instruction { source: "Some(ch) <= call getchar()", opcode: Copy8, args: [Register(0x00), Register(0xb8)], resolved: None }
16 00 b8 
# 822c0 Instruction { source: "t10 <- calc U32", opcode: Copy32, args: [Register(0xb4), Register(0xb4)], resolved: None }
81 b4 b4 
# 822c3 Instruction { source: "t11 <- ch U8", opcode: Copy8, args: [Register(0xb8), Register(0xb8)], resolved: None }
16 b8 b8 
# 822c6 Instruction { source: "Arg0[c]=t10 Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Copy32, args: [Register(0xb4), Register(0x00)], resolved: None }
81 b4 00 
# 822c9 Instruction { source: "Arg1[ch]=t11 Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Copy8, args: [Register(0xb8), Register(0x04)], resolved: None }
16 b8 04 
# Registers used by this function: {180, 181, 182, 183, 184, 185, 186, 188, 189, 190, 191, 192, 193, 194, 195, 196}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 63, 64, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 252, 253, 254, 255}
# Registers to save: [180, 181, 182, 183, 184, 185, 186, 188, 189, 190, 191, 192, 193, 194, 195]
# 822cc Instruction { source: "Saving reg0xc3 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xc3)], resolved: None }
14 c3 
# 822ce Instruction { source: "Saving reg0xc2 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xc2)], resolved: None }
14 c2 
# 822d0 Instruction { source: "Saving reg0xc1 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xc1)], resolved: None }
14 c1 
# 822d2 Instruction { source: "Saving reg0xc0 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xc0)], resolved: None }
14 c0 
# 822d4 Instruction { source: "Saving reg0xbf before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xbf)], resolved: None }
14 bf 
# 822d6 Instruction { source: "Saving reg0xbe before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xbe)], resolved: None }
14 be 
# 822d8 Instruction { source: "Saving reg0xbd before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xbd)], resolved: None }
14 bd 
# 822da Instruction { source: "Saving reg0xbc before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xbc)], resolved: None }
14 bc 
# 822dc Instruction { source: "Saving reg0xba before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xba)], resolved: None }
14 ba 
# 822de Instruction { source: "Saving reg0xb9 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xb9)], resolved: None }
14 b9 
# 822e0 Instruction { source: "Saving reg0xb8 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xb8)], resolved: None }
14 b8 
# 822e2 Instruction { source: "Saving reg0xb7 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xb7)], resolved: None }
14 b7 
# 822e4 Instruction { source: "Saving reg0xb6 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xb6)], resolved: None }
14 b6 
# 822e6 Instruction { source: "Saving reg0xb5 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xb5)], resolved: None }
14 b5 
# 822e8 Instruction { source: "Saving reg0xb4 before Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Push8, args: [Register(0xb4)], resolved: None }
14 b4 
# 822ea Instruction { source: "PseudoCall(Label24(:RpnCalc_handle))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 822f0 Instruction { source: "PseudoCall(Label24(:RpnCalc_handle))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c fa 22 08 00 
# 822f6 Instruction { source: "PseudoCall(Label24(:RpnCalc_handle))", opcode: JmpImm, args: [Label24(:RpnCalc_handle)], resolved: None }
40 22 14 08 
# 822fa Instruction { source: "PseudoCall(Label24(:RpnCalc_handle))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82300 Instruction { source: "Restoring reg0xb4 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xb4)], resolved: None }
15 b4 
# 82302 Instruction { source: "Restoring reg0xb5 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xb5)], resolved: None }
15 b5 
# 82304 Instruction { source: "Restoring reg0xb6 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xb6)], resolved: None }
15 b6 
# 82306 Instruction { source: "Restoring reg0xb7 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xb7)], resolved: None }
15 b7 
# 82308 Instruction { source: "Restoring reg0xb8 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xb8)], resolved: None }
15 b8 
# 8230a Instruction { source: "Restoring reg0xb9 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xb9)], resolved: None }
15 b9 
# 8230c Instruction { source: "Restoring reg0xba after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xba)], resolved: None }
15 ba 
# 8230e Instruction { source: "Restoring reg0xbc after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xbc)], resolved: None }
15 bc 
# 82310 Instruction { source: "Restoring reg0xbd after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xbd)], resolved: None }
15 bd 
# 82312 Instruction { source: "Restoring reg0xbe after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xbe)], resolved: None }
15 be 
# 82314 Instruction { source: "Restoring reg0xbf after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xbf)], resolved: None }
15 bf 
# 82316 Instruction { source: "Restoring reg0xc0 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xc0)], resolved: None }
15 c0 
# 82318 Instruction { source: "Restoring reg0xc1 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xc1)], resolved: None }
15 c1 
# 8231a Instruction { source: "Restoring reg0xc2 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xc2)], resolved: None }
15 c2 
# 8231c Instruction { source: "Restoring reg0xc3 after Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Pop8, args: [Register(0xc3)], resolved: None }
15 c3 
# 8231e Instruction { source: "Some(result) <= call RpnCalc_handle(t10,t11,)", opcode: Copy8, args: [Register(0x00), Register(0xb8)], resolved: None }
16 00 b8 
# 82321 Instruction { source: "t12 <- result U8", opcode: Copy8, args: [Register(0xb8), Register(0xb8)], resolved: None }
16 b8 b8 
# 82324 Instruction { source: "t13 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xb9), Constant8(0x00=0)], resolved: None }
00 b9 00 
# 82327 Instruction { source: "if t12 == t13 then 'main_if_true_0_4' else 'main_if_else_0_5'", opcode: Cmp8, args: [Register(0xb8), Register(0xb9)], resolved: None }
25 b8 b9 
# 8232a Instruction { source: "if t12 == t13 then 'main_if_true_0_4' else 'main_if_else_0_5'", opcode: JzImm, args: [Label24(main_if_true_0_4)], resolved: None }
42 32 23 08 
# 8232e Instruction { source: "if t12 == t13 then 'main_if_true_0_4' else 'main_if_else_0_5'", opcode: JmpImm, args: [Label24(main_if_else_0_5)], resolved: None }
40 4e 23 08 
# main_if_true_0_4
# 82332 Instruction { source: "t14 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xba), Constant8(0x00=0)], resolved: None }
00 ba 00 
# 82335 Instruction { source: "t15 <- 0n608/0x00000260u32 ", opcode: LoadImm32, args: [Register(0xbc), Constant32(0x00000260=608)], resolved: None }
80 bc 60 02 00 00 
# 8233b Instruction { source: "__frame_pointer <- __frame_pointer Add t15", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0xbc), Register(0x0c)], resolved: None }
a0 0c bc 0c 
# 8233f Instruction { source: "return Some(t14)", opcode: Copy8, args: [Register(0xba), Register(0x00)], resolved: None }
16 ba 00 
# 82342 Instruction { source: "Dealloc 608 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000260=608)], resolved: None }
a3 0c 60 02 00 00 
# 82348 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 8234a Instruction { source: "goto main_if_end_3", opcode: JmpImm, args: [Label24(main_if_end_3)], resolved: None }
40 4e 23 08 
# main_if_else_0_5
# main_if_end_3
# 8234e Instruction { source: "goto main_while_predicate_0", opcode: JmpImm, args: [Label24(main_while_predicate_0)], resolved: None }
40 96 22 08 
# main_while_end_2
# 82352 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :mul16_32
# Ret Some(U32)
# Arg0=a
# Arg1=b
# Var a (Arg0 a Number(USIZE)) U32 Some([200, 201, 202, 203])
# Var b (Arg1 b Number(USIZE)) U32 Some([204, 205, 206, 207])
# Var c (Local c Number(USIZE) U32) U32 Some([208, 209, 210, 211])
# Var d (Local d Number(USIZE) U32) U32 Some([212, 213, 214, 215])
# Var e (Local e Number(USIZE) U32) U32 Some([200, 201, 202, 203])
# Var f (Local f Number(USIZE) U32) U32 Some([212, 213, 214, 215])
# Var t0 (t0 Ident("a")) U32 Some([200, 201, 202, 203])
# Var t1 (t1 Ident("b")) U32 Some([204, 205, 206, 207])
# Var t10 (t10 Ident("c")) U32 Some([208, 209, 210, 211])
# Var t11 (t11 Ident("f")) U32 Some([212, 213, 214, 215])
# Var t12 (t12 Ident("a")) U32 Some([200, 201, 202, 203])
# Var t13 (t13 Cast { old_type: None, new_type: Number(USIZE), value: Index("b", Number(U8, 1)) }) U32 Some([212, 213, 214, 215])
# Var t14 (t14 Index("b", Number(U8, 1))) U8 Some([216])
# Var t15 (t15 Cast { old_type: None, new_type: Number(USIZE), value: Index("a", Number(U8, 1)) }) U32 Some([200, 201, 202, 203])
# Var t16 (t16 Index("a", Number(U8, 1))) U8 Some([217])
# Var t17 (t17 Ident("b")) U32 Some([204, 205, 206, 207])
# Var t18 (t18 Ident("d")) U32 Some([204, 205, 206, 207])
# Var t19 (t19 Ident("e")) U32 Some([200, 201, 202, 203])
# Var t2 (t2 Cast { old_type: None, new_type: Number(USIZE), value: Index("a", Number(U8, 1)) }) U32 Some([212, 213, 214, 215])
# Var t20 (t20 Index("d", Number(U8, 2))) U8 Some([217])
# Var t21 (t21 Index("d", Number(U8, 1))) U8 Some([217])
# Var t22 (t22 Index("d", Number(U8, 0))) U8 Some([217])
# Var t23 (t23 Number(U8, 0)) U8 Some([217])
# Var t24 (t24 Arithmetic(Add, Ident("c"), Ident("d"))) U32 Some([200, 201, 202, 203])
# Var t25 (t25 Ident("c")) U32 Some([200, 201, 202, 203])
# Var t26 (t26 Ident("d")) U32 Some([204, 205, 206, 207])
# Var t3 (t3 Index("a", Number(U8, 1))) U8 Some([217])
# Var t4 (t4 Cast { old_type: None, new_type: Number(USIZE), value: Index("b", Number(U8, 1)) }) U32 Some([220, 221, 222, 223])
# Var t5 (t5 Index("b", Number(U8, 1))) U8 Some([216])
# Var t6 (t6 Index("f", Number(U8, 1))) U8 Some([224])
# Var t7 (t7 Index("f", Number(U8, 0))) U8 Some([224])
# Var t8 (t8 Number(U8, 0)) U8 Some([225])
# Var t9 (t9 Number(U8, 0)) U8 Some([225])
# 82357 Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [200, 201, 202, 203].", opcode: Copy32, args: [Register(0x00), Register(0xc8)], resolved: None }
81 00 c8 
# 8235a Instruction { source: "Save function parameter 'b' registers [4, 5, 6, 7] to locals [204, 205, 206, 207].", opcode: Copy32, args: [Register(0x04), Register(0xcc)], resolved: None }
81 04 cc 
# 8235d Instruction { source: "t0 <- a U32", opcode: Copy32, args: [Register(0xc8), Register(0xc8)], resolved: None }
81 c8 c8 
# 82360 Instruction { source: "t1 <- b U32", opcode: Copy32, args: [Register(0xcc), Register(0xcc)], resolved: None }
81 cc cc 
# 82363 Instruction { source: "c <- t0 Multiply t1", opcode: LoadImm32, args: [Register(0x00), Constant32(0x00000000=0)], resolved: None }
80 00 00 00 00 00 
# 82369 Instruction { source: "c <- t0 Multiply t1", opcode: Mul8_1, args: [Register(0xc8), Register(0xcc)], resolved: None }
20 c8 cc 
# 8236c Instruction { source: "c <- t0 Multiply t1", opcode: Mul8_2, args: [], resolved: None }
21 
# 8236d Instruction { source: "c <- t0 Multiply t1", opcode: Copy32, args: [Register(0x00), Register(0xd0)], resolved: None }
81 00 d0 
# 82370 Instruction { source: "t3 <- a[0x01..0x02] U8", opcode: Copy8, args: [Register(0xc9), Register(0xd9)], resolved: None }
16 c9 d9 
# 82373 Instruction { source: "Zero-pad for t2 U32 <- t3 U8", opcode: LoadImm32, args: [Register(0xd4), Constant32(0x00000000=0)], resolved: None }
80 d4 00 00 00 00 
# 82379 Instruction { source: "t2 U32 <- t3 U8", opcode: Copy8, args: [Register(0xd9), Register(0xd4)], resolved: None }
16 d9 d4 
# 8237c Instruction { source: "t5 <- b[0x01..0x02] U8", opcode: Copy8, args: [Register(0xcd), Register(0xd8)], resolved: None }
16 cd d8 
# 8237f Instruction { source: "Zero-pad for t4 U32 <- t5 U8", opcode: LoadImm32, args: [Register(0xdc), Constant32(0x00000000=0)], resolved: None }
80 dc 00 00 00 00 
# 82385 Instruction { source: "t4 U32 <- t5 U8", opcode: Copy8, args: [Register(0xd8), Register(0xdc)], resolved: None }
16 d8 dc 
# 82388 Instruction { source: "f <- t2 Multiply t4", opcode: LoadImm32, args: [Register(0x00), Constant32(0x00000000=0)], resolved: None }
80 00 00 00 00 00 
# 8238e Instruction { source: "f <- t2 Multiply t4", opcode: Mul8_1, args: [Register(0xd4), Register(0xdc)], resolved: None }
20 d4 dc 
# 82391 Instruction { source: "f <- t2 Multiply t4", opcode: Mul8_2, args: [], resolved: None }
21 
# 82392 Instruction { source: "f <- t2 Multiply t4", opcode: Copy32, args: [Register(0x00), Register(0xd4)], resolved: None }
81 00 d4 
# 82395 Instruction { source: "t6 <- f[0x01..0x02] U8", opcode: Copy8, args: [Register(0xd5), Register(0xe0)], resolved: None }
16 d5 e0 
# 82398 Instruction { source: "f[0x03..0x04] <- t6 U8", opcode: Copy8, args: [Register(0xe0), Register(0xd7)], resolved: None }
16 e0 d7 
# 8239b Instruction { source: "t7 <- f[0x00..0x01] U8", opcode: Copy8, args: [Register(0xd4), Register(0xe0)], resolved: None }
16 d4 e0 
# 8239e Instruction { source: "f[0x02..0x03] <- t7 U8", opcode: Copy8, args: [Register(0xe0), Register(0xd6)], resolved: None }
16 e0 d6 
# 823a1 Instruction { source: "t8 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xe1), Constant8(0x00=0)], resolved: None }
00 e1 00 
# 823a4 Instruction { source: "f[0x01..0x02] <- t8 U8", opcode: Copy8, args: [Register(0xe1), Register(0xd5)], resolved: None }
16 e1 d5 
# 823a7 Instruction { source: "t9 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xe1), Constant8(0x00=0)], resolved: None }
00 e1 00 
# 823aa Instruction { source: "f[0x00..0x01] <- t9 U8", opcode: Copy8, args: [Register(0xe1), Register(0xd4)], resolved: None }
16 e1 d4 
# 823ad Instruction { source: "t10 <- c U32", opcode: Copy32, args: [Register(0xd0), Register(0xd0)], resolved: None }
81 d0 d0 
# 823b0 Instruction { source: "t11 <- f U32", opcode: Copy32, args: [Register(0xd4), Register(0xd4)], resolved: None }
81 d4 d4 
# 823b3 Instruction { source: "c <- t10 Add t11", opcode: Add32NoCarryIn, args: [Register(0xd0), Register(0xd4), Register(0xd0)], resolved: None }
a0 d0 d4 d0 
# 823b7 Instruction { source: "t12 <- a U32", opcode: Copy32, args: [Register(0xc8), Register(0xc8)], resolved: None }
81 c8 c8 
# 823ba Instruction { source: "t14 <- b[0x01..0x02] U8", opcode: Copy8, args: [Register(0xcd), Register(0xd8)], resolved: None }
16 cd d8 
# 823bd Instruction { source: "Zero-pad for t13 U32 <- t14 U8", opcode: LoadImm32, args: [Register(0xd4), Constant32(0x00000000=0)], resolved: None }
80 d4 00 00 00 00 
# 823c3 Instruction { source: "t13 U32 <- t14 U8", opcode: Copy8, args: [Register(0xd8), Register(0xd4)], resolved: None }
16 d8 d4 
# 823c6 Instruction { source: "d <- t12 Multiply t13", opcode: LoadImm32, args: [Register(0x00), Constant32(0x00000000=0)], resolved: None }
80 00 00 00 00 00 
# 823cc Instruction { source: "d <- t12 Multiply t13", opcode: Mul8_1, args: [Register(0xc8), Register(0xd4)], resolved: None }
20 c8 d4 
# 823cf Instruction { source: "d <- t12 Multiply t13", opcode: Mul8_2, args: [], resolved: None }
21 
# 823d0 Instruction { source: "d <- t12 Multiply t13", opcode: Copy32, args: [Register(0x00), Register(0xd4)], resolved: None }
81 00 d4 
# 823d3 Instruction { source: "t16 <- a[0x01..0x02] U8", opcode: Copy8, args: [Register(0xc9), Register(0xd9)], resolved: None }
16 c9 d9 
# 823d6 Instruction { source: "Zero-pad for t15 U32 <- t16 U8", opcode: LoadImm32, args: [Register(0xc8), Constant32(0x00000000=0)], resolved: None }
80 c8 00 00 00 00 
# 823dc Instruction { source: "t15 U32 <- t16 U8", opcode: Copy8, args: [Register(0xd9), Register(0xc8)], resolved: None }
16 d9 c8 
# 823df Instruction { source: "t17 <- b U32", opcode: Copy32, args: [Register(0xcc), Register(0xcc)], resolved: None }
81 cc cc 
# 823e2 Instruction { source: "e <- t15 Multiply t17", opcode: LoadImm32, args: [Register(0x00), Constant32(0x00000000=0)], resolved: None }
80 00 00 00 00 00 
# 823e8 Instruction { source: "e <- t15 Multiply t17", opcode: Mul8_1, args: [Register(0xc8), Register(0xcc)], resolved: None }
20 c8 cc 
# 823eb Instruction { source: "e <- t15 Multiply t17", opcode: Mul8_2, args: [], resolved: None }
21 
# 823ec Instruction { source: "e <- t15 Multiply t17", opcode: Copy32, args: [Register(0x00), Register(0xc8)], resolved: None }
81 00 c8 
# 823ef Instruction { source: "t18 <- d U32", opcode: Copy32, args: [Register(0xd4), Register(0xcc)], resolved: None }
81 d4 cc 
# 823f2 Instruction { source: "t19 <- e U32", opcode: Copy32, args: [Register(0xc8), Register(0xc8)], resolved: None }
81 c8 c8 
# 823f5 Instruction { source: "d <- t18 Add t19", opcode: Add32NoCarryIn, args: [Register(0xcc), Register(0xc8), Register(0xd4)], resolved: None }
a0 cc c8 d4 
# 823f9 Instruction { source: "t20 <- d[0x02..0x03] U8", opcode: Copy8, args: [Register(0xd6), Register(0xd9)], resolved: None }
16 d6 d9 
# 823fc Instruction { source: "d[0x03..0x04] <- t20 U8", opcode: Copy8, args: [Register(0xd9), Register(0xd7)], resolved: None }
16 d9 d7 
# 823ff Instruction { source: "t21 <- d[0x01..0x02] U8", opcode: Copy8, args: [Register(0xd5), Register(0xd9)], resolved: None }
16 d5 d9 
# 82402 Instruction { source: "d[0x02..0x03] <- t21 U8", opcode: Copy8, args: [Register(0xd9), Register(0xd6)], resolved: None }
16 d9 d6 
# 82405 Instruction { source: "t22 <- d[0x00..0x01] U8", opcode: Copy8, args: [Register(0xd4), Register(0xd9)], resolved: None }
16 d4 d9 
# 82408 Instruction { source: "d[0x01..0x02] <- t22 U8", opcode: Copy8, args: [Register(0xd9), Register(0xd5)], resolved: None }
16 d9 d5 
# 8240b Instruction { source: "t23 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xd9), Constant8(0x00=0)], resolved: None }
00 d9 00 
# 8240e Instruction { source: "d[0x00..0x01] <- t23 U8", opcode: Copy8, args: [Register(0xd9), Register(0xd4)], resolved: None }
16 d9 d4 
# 82411 Instruction { source: "t25 <- c U32", opcode: Copy32, args: [Register(0xd0), Register(0xc8)], resolved: None }
81 d0 c8 
# 82414 Instruction { source: "t26 <- d U32", opcode: Copy32, args: [Register(0xd4), Register(0xcc)], resolved: None }
81 d4 cc 
# 82417 Instruction { source: "t24 <- t25 Add t26", opcode: Add32NoCarryIn, args: [Register(0xc8), Register(0xcc), Register(0xc8)], resolved: None }
a0 c8 cc c8 
# 8241b Instruction { source: "return Some(t24)", opcode: Copy32, args: [Register(0xc8), Register(0x00)], resolved: None }
81 c8 00 
# 8241e Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82420 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :mul32_32
# Ret Some(U32)
# Arg0=a
# Arg1=b
# Var a (Arg0 a Number(USIZE)) U32 Some([228, 229, 230, 231])
# Var a_hi (Local a_hi Number(USIZE) U32) U32 Some([232, 233, 234, 235])
# Var b (Arg1 b Number(USIZE)) U32 Some([236, 237, 238, 239])
# Var b_hi (Local b_hi Number(USIZE) U32) U32 Some([240, 241, 242, 243])
# Var c (Local c Number(USIZE) U32) U32 Some([244, 245, 246, 247])
# Var d (Local d Number(USIZE) U32) U32 Some([228, 229, 230, 231])
# Var t0 (t0 Ident("a")) U32 Some([228, 229, 230, 231])
# Var t1 (t1 Ident("b")) U32 Some([232, 233, 234, 235])
# Var t10 (t10 Ident("a")) U32 Some([228, 229, 230, 231])
# Var t11 (t11 Ident("b_hi")) U32 Some([232, 233, 234, 235])
# Var t12 (t12 Index("d", Number(U8, 1))) U8 Some([248])
# Var t13 (t13 Index("d", Number(U8, 0))) U8 Some([248])
# Var t14 (t14 Number(U8, 0)) U8 Some([249])
# Var t15 (t15 Number(U8, 0)) U8 Some([249])
# Var t16 (t16 Arithmetic(Add, Ident("c"), Ident("d"))) U32 Some([228, 229, 230, 231])
# Var t17 (t17 Ident("c")) U32 Some([232, 233, 234, 235])
# Var t18 (t18 Ident("d")) U32 Some([228, 229, 230, 231])
# Var t2 (t2 Index("a", Number(U8, 3))) U8 Some([248])
# Var t3 (t3 Index("a", Number(U8, 2))) U8 Some([248])
# Var t4 (t4 Index("b", Number(U8, 3))) U8 Some([250])
# Var t5 (t5 Index("b", Number(U8, 2))) U8 Some([250])
# Var t6 (t6 Call(Call { function: "mul16_32", parameters: [Ident("a_hi"), Ident("b")] })) U32 Some([236, 237, 238, 239])
# Var t7 (t7 Ident("a_hi")) U32 Some([232, 233, 234, 235])
# Var t8 (t8 Ident("b")) U32 Some([236, 237, 238, 239])
# Var t9 (t9 Call(Call { function: "mul16_32", parameters: [Ident("a"), Ident("b_hi")] })) U32 Some([228, 229, 230, 231])
# 82425 Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [228, 229, 230, 231].", opcode: Copy32, args: [Register(0x00), Register(0xe4)], resolved: None }
81 00 e4 
# 82428 Instruction { source: "Save function parameter 'b' registers [4, 5, 6, 7] to locals [236, 237, 238, 239].", opcode: Copy32, args: [Register(0x04), Register(0xec)], resolved: None }
81 04 ec 
# 8242b Instruction { source: "t0 <- a U32", opcode: Copy32, args: [Register(0xe4), Register(0xe4)], resolved: None }
81 e4 e4 
# 8242e Instruction { source: "t1 <- b U32", opcode: Copy32, args: [Register(0xec), Register(0xe8)], resolved: None }
81 ec e8 
# 82431 Instruction { source: "Arg0[a]=t0 Some(c) <= call mul16_32(t0,t1,)", opcode: Copy32, args: [Register(0xe4), Register(0x00)], resolved: None }
81 e4 00 
# 82434 Instruction { source: "Arg1[b]=t1 Some(c) <= call mul16_32(t0,t1,)", opcode: Copy32, args: [Register(0xe8), Register(0x04)], resolved: None }
81 e8 04 
# Registers used by this function: {228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250}
# Registers used by callee tree: {200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225}
# Registers to save: []
# 82437 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8243d Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 47 24 08 00 
# 82443 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: JmpImm, args: [Label24(:mul16_32)], resolved: None }
40 57 23 08 
# 82447 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8244d Instruction { source: "Some(c) <= call mul16_32(t0,t1,)", opcode: Copy32, args: [Register(0x00), Register(0xf4)], resolved: None }
81 00 f4 
# 82450 Instruction { source: "a_hi <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0xe8), Constant32(0x00000000=0)], resolved: None }
80 e8 00 00 00 00 
# 82456 Instruction { source: "t2 <- a[0x03..0x04] U8", opcode: Copy8, args: [Register(0xe7), Register(0xf8)], resolved: None }
16 e7 f8 
# 82459 Instruction { source: "a_hi[0x01..0x02] <- t2 U8", opcode: Copy8, args: [Register(0xf8), Register(0xe9)], resolved: None }
16 f8 e9 
# 8245c Instruction { source: "t3 <- a[0x02..0x03] U8", opcode: Copy8, args: [Register(0xe6), Register(0xf8)], resolved: None }
16 e6 f8 
# 8245f Instruction { source: "a_hi[0x00..0x01] <- t3 U8", opcode: Copy8, args: [Register(0xf8), Register(0xe8)], resolved: None }
16 f8 e8 
# 82462 Instruction { source: "b_hi <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0xf0), Constant32(0x00000000=0)], resolved: None }
80 f0 00 00 00 00 
# 82468 Instruction { source: "t4 <- b[0x03..0x04] U8", opcode: Copy8, args: [Register(0xef), Register(0xfa)], resolved: None }
16 ef fa 
# 8246b Instruction { source: "b_hi[0x01..0x02] <- t4 U8", opcode: Copy8, args: [Register(0xfa), Register(0xf1)], resolved: None }
16 fa f1 
# 8246e Instruction { source: "t5 <- b[0x02..0x03] U8", opcode: Copy8, args: [Register(0xee), Register(0xfa)], resolved: None }
16 ee fa 
# 82471 Instruction { source: "b_hi[0x00..0x01] <- t5 U8", opcode: Copy8, args: [Register(0xfa), Register(0xf0)], resolved: None }
16 fa f0 
# 82474 Instruction { source: "t7 <- a_hi U32", opcode: Copy32, args: [Register(0xe8), Register(0xe8)], resolved: None }
81 e8 e8 
# 82477 Instruction { source: "t8 <- b U32", opcode: Copy32, args: [Register(0xec), Register(0xec)], resolved: None }
81 ec ec 
# 8247a Instruction { source: "Arg0[a]=t7 Some(t6) <= call mul16_32(t7,t8,)", opcode: Copy32, args: [Register(0xe8), Register(0x00)], resolved: None }
81 e8 00 
# 8247d Instruction { source: "Arg1[b]=t8 Some(t6) <= call mul16_32(t7,t8,)", opcode: Copy32, args: [Register(0xec), Register(0x04)], resolved: None }
81 ec 04 
# Registers used by this function: {228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250}
# Registers used by callee tree: {200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225}
# Registers to save: []
# 82480 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82486 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 90 24 08 00 
# 8248c Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: JmpImm, args: [Label24(:mul16_32)], resolved: None }
40 57 23 08 
# 82490 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82496 Instruction { source: "Some(t6) <= call mul16_32(t7,t8,)", opcode: Copy32, args: [Register(0x00), Register(0xec)], resolved: None }
81 00 ec 
# 82499 Instruction { source: "t10 <- a U32", opcode: Copy32, args: [Register(0xe4), Register(0xe4)], resolved: None }
81 e4 e4 
# 8249c Instruction { source: "t11 <- b_hi U32", opcode: Copy32, args: [Register(0xf0), Register(0xe8)], resolved: None }
81 f0 e8 
# 8249f Instruction { source: "Arg0[a]=t10 Some(t9) <= call mul16_32(t10,t11,)", opcode: Copy32, args: [Register(0xe4), Register(0x00)], resolved: None }
81 e4 00 
# 824a2 Instruction { source: "Arg1[b]=t11 Some(t9) <= call mul16_32(t10,t11,)", opcode: Copy32, args: [Register(0xe8), Register(0x04)], resolved: None }
81 e8 04 
# Registers used by this function: {228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250}
# Registers used by callee tree: {200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225}
# Registers to save: []
# 824a5 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 824ab Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c b5 24 08 00 
# 824b1 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: JmpImm, args: [Label24(:mul16_32)], resolved: None }
40 57 23 08 
# 824b5 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 824bb Instruction { source: "Some(t9) <= call mul16_32(t10,t11,)", opcode: Copy32, args: [Register(0x00), Register(0xe4)], resolved: None }
81 00 e4 
# 824be Instruction { source: "d <- t6 Add t9", opcode: Add32NoCarryIn, args: [Register(0xec), Register(0xe4), Register(0xe4)], resolved: None }
a0 ec e4 e4 
# 824c2 Instruction { source: "t12 <- d[0x01..0x02] U8", opcode: Copy8, args: [Register(0xe5), Register(0xf8)], resolved: None }
16 e5 f8 
# 824c5 Instruction { source: "d[0x03..0x04] <- t12 U8", opcode: Copy8, args: [Register(0xf8), Register(0xe7)], resolved: None }
16 f8 e7 
# 824c8 Instruction { source: "t13 <- d[0x00..0x01] U8", opcode: Copy8, args: [Register(0xe4), Register(0xf8)], resolved: None }
16 e4 f8 
# 824cb Instruction { source: "d[0x02..0x03] <- t13 U8", opcode: Copy8, args: [Register(0xf8), Register(0xe6)], resolved: None }
16 f8 e6 
# 824ce Instruction { source: "t14 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xf9), Constant8(0x00=0)], resolved: None }
00 f9 00 
# 824d1 Instruction { source: "d[0x01..0x02] <- t14 U8", opcode: Copy8, args: [Register(0xf9), Register(0xe5)], resolved: None }
16 f9 e5 
# 824d4 Instruction { source: "t15 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xf9), Constant8(0x00=0)], resolved: None }
00 f9 00 
# 824d7 Instruction { source: "d[0x00..0x01] <- t15 U8", opcode: Copy8, args: [Register(0xf9), Register(0xe4)], resolved: None }
16 f9 e4 
# 824da Instruction { source: "t17 <- c U32", opcode: Copy32, args: [Register(0xf4), Register(0xe8)], resolved: None }
81 f4 e8 
# 824dd Instruction { source: "t18 <- d U32", opcode: Copy32, args: [Register(0xe4), Register(0xe4)], resolved: None }
81 e4 e4 
# 824e0 Instruction { source: "t16 <- t17 Add t18", opcode: Add32NoCarryIn, args: [Register(0xe8), Register(0xe4), Register(0xe4)], resolved: None }
a0 e8 e4 e4 
# 824e4 Instruction { source: "return Some(t16)", opcode: Copy32, args: [Register(0xe4), Register(0x00)], resolved: None }
81 e4 00 
# 824e7 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 824e9 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :mul32_64
# Ret None
# Arg0=a
# Arg1=b
# Arg2=c
# Var __frame_pointer (__frame_pointer) U32 Some([12, 13, 14, 15])
# Var a (Arg0 a Number(USIZE)) U32 Some([252, 253, 254, 255])
# Var a_hi (Local a_hi Number(USIZE) U32) U32 Some([16, 17, 18, 19])
# Var b (Arg1 b Number(USIZE)) U32 Some([20, 21, 22, 23])
# Var b_hi (Local b_hi Number(USIZE) U32) U32 Some([24, 25, 26, 27])
# Var c (Arg2 c Ptr(Struct("U64"))) U32 Some([28, 29, 30, 31])
# Var t0 (Stack size negated) U32 Some([16, 17, 18, 19])
# Var t1 (t1 Index("a", Number(U8, 3))) U8 Some([32])
# Var t10 (t10 Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") }) U32 Some([28, 29, 30, 31])
# Var t11 (t11 Number(USIZE, 4)) U32 Some([36, 37, 38, 39])
# Var t12 (t12 Call(Call { function: "mul16_32", parameters: [Ident("a_hi"), Ident("b_hi")] })) U32 Some([36, 37, 38, 39])
# Var t13 (t13 Ident("a_hi")) U32 Some([16, 17, 18, 19])
# Var t14 (t14 Ident("b_hi")) U32 Some([24, 25, 26, 27])
# Var t15 (t15 Ident("a_hi")) U32 Some([16, 17, 18, 19])
# Var t16 (t16 Ident("b")) U32 Some([20, 21, 22, 23])
# Var t17 (t17 Index("temp", Number(U8, 0))) U8 Some([40])
# Var t18 (t18 Index("temp", Number(U8, 1))) U8 Some([40])
# Var t19 (t19 Index("temp", Number(U8, 2))) U8 Some([40])
# Var t2 (t2 Index("a", Number(U8, 2))) U8 Some([32])
# Var t20 (t20 Index("temp", Number(U8, 3))) U8 Some([40])
# Var t21 (t21 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Ident("__frame_pointer") }) U32 Some([44, 45, 46, 47])
# Var t22 (t22 Ident("temp_lo")) U32 Some([16, 17, 18, 19])
# Var t23 (t23 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 4)) }) U32 Some([16, 17, 18, 19])
# Var t24 (t24 Ident("__frame_pointer")) U32 Some([44, 45, 46, 47])
# Var t25 (t25 Number(USIZE, 4)) U32 Some([16, 17, 18, 19])
# Var t26 (t26 Ident("temp_hi")) U32 Some([20, 21, 22, 23])
# Var t27 (t27 Call(Call { function: "add_U64", parameters: [Ident("c"), AddressOf(Ident("temp64")), Ident("c")] })) U8 Some([48])
# Var t28 (t28 Ident("c")) U32 Some([16, 17, 18, 19])
# Var t29 (t29 AddressOf(Ident("temp64"))) U32 Some([20, 21, 22, 23])
# Var t3 (t3 Index("b", Number(U8, 3))) U8 Some([49])
# Var t30 (t30 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([20, 21, 22, 23])
# Var t31 (t31 Ident("__frame_pointer")) U32 Some([44, 45, 46, 47])
# Var t32 (t32 Number(USIZE, 0)) U32 Some([20, 21, 22, 23])
# Var t33 (t33 Ident("c")) U32 Some([28, 29, 30, 31])
# Var t34 (t34 Ident("a")) U32 Some([252, 253, 254, 255])
# Var t35 (t35 Ident("b_hi")) U32 Some([16, 17, 18, 19])
# Var t36 (t36 Index("temp", Number(U8, 0))) U8 Some([32])
# Var t37 (t37 Index("temp", Number(U8, 1))) U8 Some([32])
# Var t38 (t38 Index("temp", Number(U8, 2))) U8 Some([32])
# Var t39 (t39 Index("temp", Number(U8, 3))) U8 Some([32])
# Var t4 (t4 Index("b", Number(U8, 2))) U8 Some([49])
# Var t40 (t40 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Ident("__frame_pointer") }) U32 Some([44, 45, 46, 47])
# Var t41 (t41 Ident("temp_lo")) U32 Some([252, 253, 254, 255])
# Var t42 (t42 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 4)) }) U32 Some([252, 253, 254, 255])
# Var t43 (t43 Ident("__frame_pointer")) U32 Some([44, 45, 46, 47])
# Var t44 (t44 Number(USIZE, 4)) U32 Some([252, 253, 254, 255])
# Var t45 (t45 Ident("temp_hi")) U32 Some([16, 17, 18, 19])
# Var t46 (t46 Call(Call { function: "add_U64", parameters: [Ident("c"), AddressOf(Ident("temp64")), Ident("c")] })) U8 Some([48])
# Var t47 (t47 Ident("c")) U32 Some([252, 253, 254, 255])
# Var t48 (t48 AddressOf(Ident("temp64"))) U32 Some([16, 17, 18, 19])
# Var t49 (t49 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([16, 17, 18, 19])
# Var t5 (t5 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") } }) U32 Some([28, 29, 30, 31])
# Var t50 (t50 Ident("__frame_pointer")) U32 Some([44, 45, 46, 47])
# Var t51 (t51 Number(USIZE, 0)) U32 Some([16, 17, 18, 19])
# Var t52 (t52 Ident("c")) U32 Some([20, 21, 22, 23])
# Var t53 (Stack size) U32 Some([252, 253, 254, 255])
# Var t6 (t6 Call(Call { function: "mul16_32", parameters: [Ident("a"), Ident("b")] })) U32 Some([36, 37, 38, 39])
# Var t7 (t7 Ident("a")) U32 Some([252, 253, 254, 255])
# Var t8 (t8 Ident("b")) U32 Some([20, 21, 22, 23])
# Var t9 (t9 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("U64"))), new_type: Number(USIZE), value: Ident("c") }, Number(USIZE, 4)) }) U32 Some([52, 53, 54, 55])
# Var temp (Local temp Number(USIZE) U32) U32 Some([16, 17, 18, 19])
# Var temp64 (Local temp64 Struct("U64") FrameOffset(0)) FrameOffset(0) None
# Var temp_hi (Local temp_hi Number(USIZE) U32) U32 Some([36, 37, 38, 39])
# Var temp_lo (Local temp_lo Number(USIZE) U32) U32 Some([52, 53, 54, 55])
# 824ee Instruction { source: "reserve 8 bytes of stack space for locals", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffff8=4294967288)], resolved: None }
a3 0c f8 ff ff ff 
# 824f4 Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [252, 253, 254, 255].", opcode: Copy32, args: [Register(0x00), Register(0xfc)], resolved: None }
81 00 fc 
# 824f7 Instruction { source: "Save function parameter 'b' registers [4, 5, 6, 7] to locals [20, 21, 22, 23].", opcode: Copy32, args: [Register(0x04), Register(0x14)], resolved: None }
81 04 14 
# 824fa Instruction { source: "Save function parameter 'c' registers [8, 9, 10, 11] to locals [28, 29, 30, 31].", opcode: Copy32, args: [Register(0x08), Register(0x1c)], resolved: None }
81 08 1c 
# 824fd Instruction { source: "t0 <- 0xfffffff8u32 ", opcode: LoadImm32, args: [Register(0x10), Constant32(0xfffffff8=4294967288)], resolved: None }
80 10 f8 ff ff ff 
# 82503 Instruction { source: "__frame_pointer <- __frame_pointer Add t0", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x10), Register(0x0c)], resolved: None }
a0 0c 10 0c 
# 82507 Instruction { source: "a_hi <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x10), Constant32(0x00000000=0)], resolved: None }
80 10 00 00 00 00 
# 8250d Instruction { source: "t1 <- a[0x03..0x04] U8", opcode: Copy8, args: [Register(0xff), Register(0x20)], resolved: None }
16 ff 20 
# 82510 Instruction { source: "a_hi[0x01..0x02] <- t1 U8", opcode: Copy8, args: [Register(0x20), Register(0x11)], resolved: None }
16 20 11 
# 82513 Instruction { source: "t2 <- a[0x02..0x03] U8", opcode: Copy8, args: [Register(0xfe), Register(0x20)], resolved: None }
16 fe 20 
# 82516 Instruction { source: "a_hi[0x00..0x01] <- t2 U8", opcode: Copy8, args: [Register(0x20), Register(0x10)], resolved: None }
16 20 10 
# 82519 Instruction { source: "b_hi <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x18), Constant32(0x00000000=0)], resolved: None }
80 18 00 00 00 00 
# 8251f Instruction { source: "t3 <- b[0x03..0x04] U8", opcode: Copy8, args: [Register(0x17), Register(0x31)], resolved: None }
16 17 31 
# 82522 Instruction { source: "b_hi[0x01..0x02] <- t3 U8", opcode: Copy8, args: [Register(0x31), Register(0x19)], resolved: None }
16 31 19 
# 82525 Instruction { source: "t4 <- b[0x02..0x03] U8", opcode: Copy8, args: [Register(0x16), Register(0x31)], resolved: None }
16 16 31 
# 82528 Instruction { source: "b_hi[0x00..0x01] <- t4 U8", opcode: Copy8, args: [Register(0x31), Register(0x18)], resolved: None }
16 31 18 
# 8252b Instruction { source: "t5 <- c U32", opcode: Copy32, args: [Register(0x1c), Register(0x1c)], resolved: None }
81 1c 1c 
# 8252e Instruction { source: "t7 <- a U32", opcode: Copy32, args: [Register(0xfc), Register(0xfc)], resolved: None }
81 fc fc 
# 82531 Instruction { source: "t8 <- b U32", opcode: Copy32, args: [Register(0x14), Register(0x14)], resolved: None }
81 14 14 
# 82534 Instruction { source: "Arg0[a]=t7 Some(t6) <= call mul16_32(t7,t8,)", opcode: Copy32, args: [Register(0xfc), Register(0x00)], resolved: None }
81 fc 00 
# 82537 Instruction { source: "Arg1[b]=t8 Some(t6) <= call mul16_32(t7,t8,)", opcode: Copy32, args: [Register(0x14), Register(0x04)], resolved: None }
81 14 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 252, 253, 254, 255}
# Registers used by callee tree: {200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225}
# Registers to save: []
# 8253a Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82540 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 4a 25 08 00 
# 82546 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: JmpImm, args: [Label24(:mul16_32)], resolved: None }
40 57 23 08 
# 8254a Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82550 Instruction { source: "Some(t6) <= call mul16_32(t7,t8,)", opcode: Copy32, args: [Register(0x00), Register(0x24)], resolved: None }
81 00 24 
# 82553 Instruction { source: "mem[t5] <- t6 U32", opcode: Store32_1, args: [Register(0x24), Register(0x1c)], resolved: None }
92 24 1c 
# 82556 Instruction { source: "mem[t5] <- t6 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 82557 Instruction { source: "t10 <- c U32", opcode: Copy32, args: [Register(0x1c), Register(0x1c)], resolved: None }
81 1c 1c 
# 8255a Instruction { source: "t11 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x24), Constant32(0x00000004=4)], resolved: None }
80 24 04 00 00 00 
# 82560 Instruction { source: "t9 <- t10 Add t11", opcode: Add32NoCarryIn, args: [Register(0x1c), Register(0x24), Register(0x34)], resolved: None }
a0 1c 24 34 
# 82564 Instruction { source: "t13 <- a_hi U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 82567 Instruction { source: "t14 <- b_hi U32", opcode: Copy32, args: [Register(0x18), Register(0x18)], resolved: None }
81 18 18 
# 8256a Instruction { source: "Arg0[a]=t13 Some(t12) <= call mul16_32(t13,t14,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# 8256d Instruction { source: "Arg1[b]=t14 Some(t12) <= call mul16_32(t13,t14,)", opcode: Copy32, args: [Register(0x18), Register(0x04)], resolved: None }
81 18 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 252, 253, 254, 255}
# Registers used by callee tree: {200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225}
# Registers to save: []
# 82570 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82576 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 80 25 08 00 
# 8257c Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: JmpImm, args: [Label24(:mul16_32)], resolved: None }
40 57 23 08 
# 82580 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82586 Instruction { source: "Some(t12) <= call mul16_32(t13,t14,)", opcode: Copy32, args: [Register(0x00), Register(0x24)], resolved: None }
81 00 24 
# 82589 Instruction { source: "mem[t9] <- t12 U32", opcode: Store32_1, args: [Register(0x24), Register(0x34)], resolved: None }
92 24 34 
# 8258c Instruction { source: "mem[t9] <- t12 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 8258d Instruction { source: "temp_lo <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x34), Constant32(0x00000000=0)], resolved: None }
80 34 00 00 00 00 
# 82593 Instruction { source: "temp_hi <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x24), Constant32(0x00000000=0)], resolved: None }
80 24 00 00 00 00 
# 82599 Instruction { source: "t15 <- a_hi U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 8259c Instruction { source: "t16 <- b U32", opcode: Copy32, args: [Register(0x14), Register(0x14)], resolved: None }
81 14 14 
# 8259f Instruction { source: "Arg0[a]=t15 Some(temp) <= call mul16_32(t15,t16,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# 825a2 Instruction { source: "Arg1[b]=t16 Some(temp) <= call mul16_32(t15,t16,)", opcode: Copy32, args: [Register(0x14), Register(0x04)], resolved: None }
81 14 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 252, 253, 254, 255}
# Registers used by callee tree: {200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225}
# Registers to save: []
# 825a5 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 825ab Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c b5 25 08 00 
# 825b1 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: JmpImm, args: [Label24(:mul16_32)], resolved: None }
40 57 23 08 
# 825b5 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 825bb Instruction { source: "Some(temp) <= call mul16_32(t15,t16,)", opcode: Copy32, args: [Register(0x00), Register(0x10)], resolved: None }
81 00 10 
# 825be Instruction { source: "t17 <- temp[0x00..0x01] U8", opcode: Copy8, args: [Register(0x10), Register(0x28)], resolved: None }
16 10 28 
# 825c1 Instruction { source: "temp_lo[0x02..0x03] <- t17 U8", opcode: Copy8, args: [Register(0x28), Register(0x36)], resolved: None }
16 28 36 
# 825c4 Instruction { source: "t18 <- temp[0x01..0x02] U8", opcode: Copy8, args: [Register(0x11), Register(0x28)], resolved: None }
16 11 28 
# 825c7 Instruction { source: "temp_lo[0x03..0x04] <- t18 U8", opcode: Copy8, args: [Register(0x28), Register(0x37)], resolved: None }
16 28 37 
# 825ca Instruction { source: "t19 <- temp[0x02..0x03] U8", opcode: Copy8, args: [Register(0x12), Register(0x28)], resolved: None }
16 12 28 
# 825cd Instruction { source: "temp_hi[0x00..0x01] <- t19 U8", opcode: Copy8, args: [Register(0x28), Register(0x24)], resolved: None }
16 28 24 
# 825d0 Instruction { source: "t20 <- temp[0x03..0x04] U8", opcode: Copy8, args: [Register(0x13), Register(0x28)], resolved: None }
16 13 28 
# 825d3 Instruction { source: "temp_hi[0x01..0x02] <- t20 U8", opcode: Copy8, args: [Register(0x28), Register(0x25)], resolved: None }
16 28 25 
# 825d6 Instruction { source: "t21 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0x2c)], resolved: None }
81 0c 2c 
# 825d9 Instruction { source: "t22 <- temp_lo U32", opcode: Copy32, args: [Register(0x34), Register(0x10)], resolved: None }
81 34 10 
# 825dc Instruction { source: "mem[t21] <- t22 U32", opcode: Store32_1, args: [Register(0x10), Register(0x2c)], resolved: None }
92 10 2c 
# 825df Instruction { source: "mem[t21] <- t22 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 825e0 Instruction { source: "t24 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0x2c)], resolved: None }
81 0c 2c 
# 825e3 Instruction { source: "t25 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x10), Constant32(0x00000004=4)], resolved: None }
80 10 04 00 00 00 
# 825e9 Instruction { source: "t23 <- t24 Add t25", opcode: Add32NoCarryIn, args: [Register(0x2c), Register(0x10), Register(0x10)], resolved: None }
a0 2c 10 10 
# 825ed Instruction { source: "t26 <- temp_hi U32", opcode: Copy32, args: [Register(0x24), Register(0x14)], resolved: None }
81 24 14 
# 825f0 Instruction { source: "mem[t23] <- t26 U32", opcode: Store32_1, args: [Register(0x14), Register(0x10)], resolved: None }
92 14 10 
# 825f3 Instruction { source: "mem[t23] <- t26 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 825f4 Instruction { source: "t28 <- c U32", opcode: Copy32, args: [Register(0x1c), Register(0x10)], resolved: None }
81 1c 10 
# 825f7 Instruction { source: "t31 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0x2c)], resolved: None }
81 0c 2c 
# 825fa Instruction { source: "t32 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x14), Constant32(0x00000000=0)], resolved: None }
80 14 00 00 00 00 
# 82600 Instruction { source: "t30 <- t31 Add t32", opcode: Add32NoCarryIn, args: [Register(0x2c), Register(0x14), Register(0x14)], resolved: None }
a0 2c 14 14 
# 82604 Instruction { source: "t29 <- t30 U32", opcode: Copy32, args: [Register(0x14), Register(0x14)], resolved: None }
81 14 14 
# 82607 Instruction { source: "t33 <- c U32", opcode: Copy32, args: [Register(0x1c), Register(0x1c)], resolved: None }
81 1c 1c 
# 8260a Instruction { source: "Arg0[a]=t28 None <= call add_U64(t28,t29,t33,)", opcode: Copy32, args: [Register(0x10), Register(0x00)], resolved: None }
81 10 00 
# 8260d Instruction { source: "Arg1[b]=t29 None <= call add_U64(t28,t29,t33,)", opcode: Copy32, args: [Register(0x14), Register(0x04)], resolved: None }
81 14 04 
# 82610 Instruction { source: "Arg2[c]=t33 None <= call add_U64(t28,t29,t33,)", opcode: Copy32, args: [Register(0x1c), Register(0x08)], resolved: None }
81 1c 08 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 252, 253, 254, 255}
# Registers used by callee tree: {80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107}
# Registers to save: []
# 82613 Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82619 Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 23 26 08 00 
# 8261f Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: JmpImm, args: [Label24(:add_U64)], resolved: None }
40 80 1c 08 
# 82623 Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82629 Instruction { source: "t34 <- a U32", opcode: Copy32, args: [Register(0xfc), Register(0xfc)], resolved: None }
81 fc fc 
# 8262c Instruction { source: "t35 <- b_hi U32", opcode: Copy32, args: [Register(0x18), Register(0x10)], resolved: None }
81 18 10 
# 8262f Instruction { source: "Arg0[a]=t34 Some(temp) <= call mul16_32(t34,t35,)", opcode: Copy32, args: [Register(0xfc), Register(0x00)], resolved: None }
81 fc 00 
# 82632 Instruction { source: "Arg1[b]=t35 Some(temp) <= call mul16_32(t34,t35,)", opcode: Copy32, args: [Register(0x10), Register(0x04)], resolved: None }
81 10 04 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 252, 253, 254, 255}
# Registers used by callee tree: {200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225}
# Registers to save: []
# 82635 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8263b Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 45 26 08 00 
# 82641 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: JmpImm, args: [Label24(:mul16_32)], resolved: None }
40 57 23 08 
# 82645 Instruction { source: "PseudoCall(Label24(:mul16_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8264b Instruction { source: "Some(temp) <= call mul16_32(t34,t35,)", opcode: Copy32, args: [Register(0x00), Register(0x10)], resolved: None }
81 00 10 
# 8264e Instruction { source: "t36 <- temp[0x00..0x01] U8", opcode: Copy8, args: [Register(0x10), Register(0x20)], resolved: None }
16 10 20 
# 82651 Instruction { source: "temp_lo[0x02..0x03] <- t36 U8", opcode: Copy8, args: [Register(0x20), Register(0x36)], resolved: None }
16 20 36 
# 82654 Instruction { source: "t37 <- temp[0x01..0x02] U8", opcode: Copy8, args: [Register(0x11), Register(0x20)], resolved: None }
16 11 20 
# 82657 Instruction { source: "temp_lo[0x03..0x04] <- t37 U8", opcode: Copy8, args: [Register(0x20), Register(0x37)], resolved: None }
16 20 37 
# 8265a Instruction { source: "t38 <- temp[0x02..0x03] U8", opcode: Copy8, args: [Register(0x12), Register(0x20)], resolved: None }
16 12 20 
# 8265d Instruction { source: "temp_hi[0x00..0x01] <- t38 U8", opcode: Copy8, args: [Register(0x20), Register(0x24)], resolved: None }
16 20 24 
# 82660 Instruction { source: "t39 <- temp[0x03..0x04] U8", opcode: Copy8, args: [Register(0x13), Register(0x20)], resolved: None }
16 13 20 
# 82663 Instruction { source: "temp_hi[0x01..0x02] <- t39 U8", opcode: Copy8, args: [Register(0x20), Register(0x25)], resolved: None }
16 20 25 
# 82666 Instruction { source: "t40 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0x2c)], resolved: None }
81 0c 2c 
# 82669 Instruction { source: "t41 <- temp_lo U32", opcode: Copy32, args: [Register(0x34), Register(0xfc)], resolved: None }
81 34 fc 
# 8266c Instruction { source: "mem[t40] <- t41 U32", opcode: Store32_1, args: [Register(0xfc), Register(0x2c)], resolved: None }
92 fc 2c 
# 8266f Instruction { source: "mem[t40] <- t41 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 82670 Instruction { source: "t43 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0x2c)], resolved: None }
81 0c 2c 
# 82673 Instruction { source: "t44 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0xfc), Constant32(0x00000004=4)], resolved: None }
80 fc 04 00 00 00 
# 82679 Instruction { source: "t42 <- t43 Add t44", opcode: Add32NoCarryIn, args: [Register(0x2c), Register(0xfc), Register(0xfc)], resolved: None }
a0 2c fc fc 
# 8267d Instruction { source: "t45 <- temp_hi U32", opcode: Copy32, args: [Register(0x24), Register(0x10)], resolved: None }
81 24 10 
# 82680 Instruction { source: "mem[t42] <- t45 U32", opcode: Store32_1, args: [Register(0x10), Register(0xfc)], resolved: None }
92 10 fc 
# 82683 Instruction { source: "mem[t42] <- t45 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 82684 Instruction { source: "t47 <- c U32", opcode: Copy32, args: [Register(0x1c), Register(0xfc)], resolved: None }
81 1c fc 
# 82687 Instruction { source: "t50 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0x2c)], resolved: None }
81 0c 2c 
# 8268a Instruction { source: "t51 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x10), Constant32(0x00000000=0)], resolved: None }
80 10 00 00 00 00 
# 82690 Instruction { source: "t49 <- t50 Add t51", opcode: Add32NoCarryIn, args: [Register(0x2c), Register(0x10), Register(0x10)], resolved: None }
a0 2c 10 10 
# 82694 Instruction { source: "t48 <- t49 U32", opcode: Copy32, args: [Register(0x10), Register(0x10)], resolved: None }
81 10 10 
# 82697 Instruction { source: "t52 <- c U32", opcode: Copy32, args: [Register(0x1c), Register(0x14)], resolved: None }
81 1c 14 
# 8269a Instruction { source: "Arg0[a]=t47 None <= call add_U64(t47,t48,t52,)", opcode: Copy32, args: [Register(0xfc), Register(0x00)], resolved: None }
81 fc 00 
# 8269d Instruction { source: "Arg1[b]=t48 None <= call add_U64(t47,t48,t52,)", opcode: Copy32, args: [Register(0x10), Register(0x04)], resolved: None }
81 10 04 
# 826a0 Instruction { source: "Arg2[c]=t52 None <= call add_U64(t47,t48,t52,)", opcode: Copy32, args: [Register(0x14), Register(0x08)], resolved: None }
81 14 08 
# Registers used by this function: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 252, 253, 254, 255}
# Registers used by callee tree: {80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107}
# Registers to save: []
# 826a3 Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 826a9 Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c b3 26 08 00 
# 826af Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: JmpImm, args: [Label24(:add_U64)], resolved: None }
40 80 1c 08 
# 826b3 Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 826b9 Instruction { source: "t53 <- 0n8/0x00000008u32 ", opcode: LoadImm32, args: [Register(0xfc), Constant32(0x00000008=8)], resolved: None }
80 fc 08 00 00 00 
# 826bf Instruction { source: "__frame_pointer <- __frame_pointer Add t53", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0xfc), Register(0x0c)], resolved: None }
a0 0c fc 0c 
# 826c3 Instruction { source: "Dealloc 8 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000008=8)], resolved: None }
a3 0c 08 00 00 00 
# 826c9 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 826cb Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :mul8
# Ret Some(U8)
# Arg0=x
# Arg1=y
# Var t0 (t0 Arithmetic(Multiply, Ident("x"), Ident("y"))) U8 Some([56])
# Var t1 (t1 Ident("x")) U8 Some([56])
# Var t2 (t2 Ident("y")) U8 Some([57])
# Var x (Arg0 x Number(U8)) U8 Some([56])
# Var y (Arg1 y Number(U8)) U8 Some([57])
# 826d0 Instruction { source: "Save function parameter 'x' registers [0] to locals [56].", opcode: Copy8, args: [Register(0x00), Register(0x38)], resolved: None }
16 00 38 
# 826d3 Instruction { source: "Save function parameter 'y' registers [4] to locals [57].", opcode: Copy8, args: [Register(0x04), Register(0x39)], resolved: None }
16 04 39 
# 826d6 Instruction { source: "t1 <- x U8", opcode: Copy8, args: [Register(0x38), Register(0x38)], resolved: None }
16 38 38 
# 826d9 Instruction { source: "t2 <- y U8", opcode: Copy8, args: [Register(0x39), Register(0x39)], resolved: None }
16 39 39 
# 826dc Instruction { source: "t0 <- t1 Multiply t2", opcode: Mul8_1, args: [Register(0x38), Register(0x39)], resolved: None }
20 38 39 
# 826df Instruction { source: "t0 <- t1 Multiply t2", opcode: Mul8_2, args: [], resolved: None }
21 
# 826e0 Instruction { source: "t0 <- t1 Multiply t2", opcode: Copy8, args: [Register(0x00), Register(0x38)], resolved: None }
16 00 38 
# 826e3 Instruction { source: "return Some(t0)", opcode: Copy8, args: [Register(0x38), Register(0x00)], resolved: None }
16 38 00 
# 826e6 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 826e8 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :mul8_16
# Ret Some(U32)
# Arg0=x
# Arg1=y
# Var t0 (t0 Arithmetic(Multiply, Cast { old_type: None, new_type: Number(USIZE), value: Ident("x") }, Cast { old_type: None, new_type: Number(USIZE), value: Ident("y") })) U32 Some([60, 61, 62, 63])
# Var t1 (t1 Cast { old_type: None, new_type: Number(USIZE), value: Ident("x") }) U32 Some([60, 61, 62, 63])
# Var t2 (t2 Ident("x")) U8 Some([64])
# Var t3 (t3 Cast { old_type: None, new_type: Number(USIZE), value: Ident("y") }) U32 Some([68, 69, 70, 71])
# Var t4 (t4 Ident("y")) U8 Some([72])
# Var x (Arg0 x Number(U8)) U8 Some([64])
# Var y (Arg1 y Number(U8)) U8 Some([72])
# 826ed Instruction { source: "Save function parameter 'x' registers [0] to locals [64].", opcode: Copy8, args: [Register(0x00), Register(0x40)], resolved: None }
16 00 40 
# 826f0 Instruction { source: "Save function parameter 'y' registers [4] to locals [72].", opcode: Copy8, args: [Register(0x04), Register(0x48)], resolved: None }
16 04 48 
# 826f3 Instruction { source: "t2 <- x U8", opcode: Copy8, args: [Register(0x40), Register(0x40)], resolved: None }
16 40 40 
# 826f6 Instruction { source: "Zero-pad for t1 U32 <- t2 U8", opcode: LoadImm32, args: [Register(0x3c), Constant32(0x00000000=0)], resolved: None }
80 3c 00 00 00 00 
# 826fc Instruction { source: "t1 U32 <- t2 U8", opcode: Copy8, args: [Register(0x40), Register(0x3c)], resolved: None }
16 40 3c 
# 826ff Instruction { source: "t4 <- y U8", opcode: Copy8, args: [Register(0x48), Register(0x48)], resolved: None }
16 48 48 
# 82702 Instruction { source: "Zero-pad for t3 U32 <- t4 U8", opcode: LoadImm32, args: [Register(0x44), Constant32(0x00000000=0)], resolved: None }
80 44 00 00 00 00 
# 82708 Instruction { source: "t3 U32 <- t4 U8", opcode: Copy8, args: [Register(0x48), Register(0x44)], resolved: None }
16 48 44 
# 8270b Instruction { source: "t0 <- t1 Multiply t3", opcode: LoadImm32, args: [Register(0x00), Constant32(0x00000000=0)], resolved: None }
80 00 00 00 00 00 
# 82711 Instruction { source: "t0 <- t1 Multiply t3", opcode: Mul8_1, args: [Register(0x3c), Register(0x44)], resolved: None }
20 3c 44 
# 82714 Instruction { source: "t0 <- t1 Multiply t3", opcode: Mul8_2, args: [], resolved: None }
21 
# 82715 Instruction { source: "t0 <- t1 Multiply t3", opcode: Copy32, args: [Register(0x00), Register(0x3c)], resolved: None }
81 00 3c 
# 82718 Instruction { source: "return Some(t0)", opcode: Copy32, args: [Register(0x3c), Register(0x00)], resolved: None }
81 3c 00 
# 8271b Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 8271d Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :print_dec32
# Ret None
# Arg0=a
# Var a (Arg0 a Number(USIZE)) U32 Some([76, 77, 78, 79])
# Var b (Local b Number(USIZE) U32) U32 Some([80, 81, 82, 83])
# Var t0 (t0 Ident("a")) U32 Some([76, 77, 78, 79])
# Var t1 (t1 Number(USIZE, 10)) U32 Some([80, 81, 82, 83])
# Var t10 (t10 Arithmetic(Add, Index("a", Number(U8, 0)), Number(U8, 48))) U8 Some([84])
# Var t11 (t11 Index("a", Number(U8, 0))) U8 Some([84])
# Var t12 (t12 Number(U8, 48)) U8 Some([85])
# Var t2 (t2 Ident("a")) U32 Some([76, 77, 78, 79])
# Var t3 (t3 Number(USIZE, 10)) U32 Some([80, 81, 82, 83])
# Var t4 (t4 Call(Call { function: "print_dec32", parameters: [Ident("b")] })) U8 Some([84])
# Var t5 (t5 Ident("b")) U32 Some([80, 81, 82, 83])
# Var t6 (t6 Ident("a")) U32 Some([76, 77, 78, 79])
# Var t7 (t7 Call(Call { function: "mul32_32", parameters: [Ident("b"), Number(USIZE, 10)] })) U32 Some([80, 81, 82, 83])
# Var t8 (t8 Ident("b")) U32 Some([80, 81, 82, 83])
# Var t9 (t9 Number(USIZE, 10)) U32 Some([88, 89, 90, 91])
# 82722 Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [76, 77, 78, 79].", opcode: Copy32, args: [Register(0x00), Register(0x4c)], resolved: None }
81 00 4c 
# 82725 Instruction { source: "t0 <- a U32", opcode: Copy32, args: [Register(0x4c), Register(0x4c)], resolved: None }
81 4c 4c 
# 82728 Instruction { source: "t1 <- 0n10/0x0000000au32 ", opcode: LoadImm32, args: [Register(0x50), Constant32(0x0000000a=10)], resolved: None }
80 50 0a 00 00 00 
# 8272e Instruction { source: "if t0 >= t1 then 'print_dec32_if_true_0_1' else 'print_dec32_if_else_0_2'", opcode: Cmp8, args: [Register(0x53), Register(0x4f)], resolved: None }
25 53 4f 
# 82731 Instruction { source: "if t0 >= t1 then 'print_dec32_if_true_0_1' else 'print_dec32_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x52), Register(0x4e)], resolved: None }
26 52 4e 
# 82734 Instruction { source: "if t0 >= t1 then 'print_dec32_if_true_0_1' else 'print_dec32_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x51), Register(0x4d)], resolved: None }
26 51 4d 
# 82737 Instruction { source: "if t0 >= t1 then 'print_dec32_if_true_0_1' else 'print_dec32_if_else_0_2'", opcode: Cmp8IfZero, args: [Register(0x50), Register(0x4c)], resolved: None }
26 50 4c 
# 8273a Instruction { source: "if t0 >= t1 then 'print_dec32_if_true_0_1' else 'print_dec32_if_else_0_2'", opcode: JcImm, args: [Label24(print_dec32_if_true_0_1)], resolved: None }
41 42 27 08 
# 8273e Instruction { source: "if t0 >= t1 then 'print_dec32_if_true_0_1' else 'print_dec32_if_else_0_2'", opcode: JmpImm, args: [Label24(print_dec32_if_else_0_2)], resolved: None }
40 2a 28 08 
# print_dec32_if_true_0_1
# 82742 Instruction { source: "t2 <- a U32", opcode: Copy32, args: [Register(0x4c), Register(0x4c)], resolved: None }
81 4c 4c 
# 82745 Instruction { source: "t3 <- 0n10/0x0000000au32 ", opcode: LoadImm32, args: [Register(0x50), Constant32(0x0000000a=10)], resolved: None }
80 50 0a 00 00 00 
# 8274b Instruction { source: "Arg0[a]=t2 Some(b) <= call div32(t2,t3,)", opcode: Copy32, args: [Register(0x4c), Register(0x00)], resolved: None }
81 4c 00 
# 8274e Instruction { source: "Arg1[b]=t3 Some(b) <= call div32(t2,t3,)", opcode: Copy32, args: [Register(0x50), Register(0x04)], resolved: None }
81 50 04 
# Registers used by this function: {76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 88, 89, 90, 91}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 160, 161, 162, 163, 164, 168, 169, 170, 171, 172, 173, 174, 175, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225, 252, 253, 254, 255}
# Registers to save: [80, 81, 82, 83, 84, 85, 88, 89, 90, 91]
# 82751 Instruction { source: "Saving reg0x5b before Some(b) <= call div32(t2,t3,)", opcode: Push8, args: [Register(0x5b)], resolved: None }
14 5b 
# 82753 Instruction { source: "Saving reg0x5a before Some(b) <= call div32(t2,t3,)", opcode: Push8, args: [Register(0x5a)], resolved: None }
14 5a 
# 82755 Instruction { source: "Saving reg0x59 before Some(b) <= call div32(t2,t3,)", opcode: Push8, args: [Register(0x59)], resolved: None }
14 59 
# 82757 Instruction { source: "Saving reg0x58 before Some(b) <= call div32(t2,t3,)", opcode: Push8, args: [Register(0x58)], resolved: None }
14 58 
# 82759 Instruction { source: "Saving reg0x55 before Some(b) <= call div32(t2,t3,)", opcode: Push8, args: [Register(0x55)], resolved: None }
14 55 
# 8275b Instruction { source: "Saving reg0x54 before Some(b) <= call div32(t2,t3,)", opcode: Push8, args: [Register(0x54)], resolved: None }
14 54 
# 8275d Instruction { source: "Saving reg0x53 before Some(b) <= call div32(t2,t3,)", opcode: Push8, args: [Register(0x53)], resolved: None }
14 53 
# 8275f Instruction { source: "Saving reg0x52 before Some(b) <= call div32(t2,t3,)", opcode: Push8, args: [Register(0x52)], resolved: None }
14 52 
# 82761 Instruction { source: "Saving reg0x51 before Some(b) <= call div32(t2,t3,)", opcode: Push8, args: [Register(0x51)], resolved: None }
14 51 
# 82763 Instruction { source: "Saving reg0x50 before Some(b) <= call div32(t2,t3,)", opcode: Push8, args: [Register(0x50)], resolved: None }
14 50 
# 82765 Instruction { source: "PseudoCall(Label24(:div32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8276b Instruction { source: "PseudoCall(Label24(:div32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 75 27 08 00 
# 82771 Instruction { source: "PseudoCall(Label24(:div32))", opcode: JmpImm, args: [Label24(:div32)], resolved: None }
40 f5 1e 08 
# 82775 Instruction { source: "PseudoCall(Label24(:div32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8277b Instruction { source: "Restoring reg0x50 after Some(b) <= call div32(t2,t3,)", opcode: Pop8, args: [Register(0x50)], resolved: None }
15 50 
# 8277d Instruction { source: "Restoring reg0x51 after Some(b) <= call div32(t2,t3,)", opcode: Pop8, args: [Register(0x51)], resolved: None }
15 51 
# 8277f Instruction { source: "Restoring reg0x52 after Some(b) <= call div32(t2,t3,)", opcode: Pop8, args: [Register(0x52)], resolved: None }
15 52 
# 82781 Instruction { source: "Restoring reg0x53 after Some(b) <= call div32(t2,t3,)", opcode: Pop8, args: [Register(0x53)], resolved: None }
15 53 
# 82783 Instruction { source: "Restoring reg0x54 after Some(b) <= call div32(t2,t3,)", opcode: Pop8, args: [Register(0x54)], resolved: None }
15 54 
# 82785 Instruction { source: "Restoring reg0x55 after Some(b) <= call div32(t2,t3,)", opcode: Pop8, args: [Register(0x55)], resolved: None }
15 55 
# 82787 Instruction { source: "Restoring reg0x58 after Some(b) <= call div32(t2,t3,)", opcode: Pop8, args: [Register(0x58)], resolved: None }
15 58 
# 82789 Instruction { source: "Restoring reg0x59 after Some(b) <= call div32(t2,t3,)", opcode: Pop8, args: [Register(0x59)], resolved: None }
15 59 
# 8278b Instruction { source: "Restoring reg0x5a after Some(b) <= call div32(t2,t3,)", opcode: Pop8, args: [Register(0x5a)], resolved: None }
15 5a 
# 8278d Instruction { source: "Restoring reg0x5b after Some(b) <= call div32(t2,t3,)", opcode: Pop8, args: [Register(0x5b)], resolved: None }
15 5b 
# 8278f Instruction { source: "Some(b) <= call div32(t2,t3,)", opcode: Copy32, args: [Register(0x00), Register(0x50)], resolved: None }
81 00 50 
# 82792 Instruction { source: "t5 <- b U32", opcode: Copy32, args: [Register(0x50), Register(0x50)], resolved: None }
81 50 50 
# 82795 Instruction { source: "Arg0[a]=t5 None <= call print_dec32(t5,)", opcode: Copy32, args: [Register(0x50), Register(0x00)], resolved: None }
81 50 00 
# Registers used by this function: {76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 88, 89, 90, 91}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 160, 161, 162, 163, 164, 168, 169, 170, 171, 172, 173, 174, 175, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 252, 253, 254, 255}
# Registers to save: [76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 88, 89, 90, 91]
# 82798 Instruction { source: "Saving reg0x5b before None <= call print_dec32(t5,)", opcode: Push8, args: [Register(0x5b)], resolved: None }
14 5b 
# 8279a Instruction { source: "Saving reg0x5a before None <= call print_dec32(t5,)", opcode: Push8, args: [Register(0x5a)], resolved: None }
14 5a 
# 8279c Instruction { source: "Saving reg0x59 before None <= call print_dec32(t5,)", opcode: Push8, args: [Register(0x59)], resolved: None }
14 59 
# 8279e Instruction { source: "Saving reg0x58 before None <= call print_dec32(t5,)", opcode: Push8, args: [Register(0x58)], resolved: None }
14 58 
# 827a0 Instruction { source: "Saving reg0x55 before None <= call print_dec32(t5,)", opcode: Push8, args: [Register(0x55)], resolved: None }
14 55 
# 827a2 Instruction { source: "Saving reg0x54 before None <= call print_dec32(t5,)", opcode: Push8, args: [Register(0x54)], resolved: None }
14 54 
# 827a4 Instruction { source: "Saving reg0x53 before None <= call print_dec32(t5,)", opcode: Push8, args: [Register(0x53)], resolved: None }
14 53 
# 827a6 Instruction { source: "Saving reg0x52 before None <= call print_dec32(t5,)", opcode: Push8, args: [Register(0x52)], resolved: None }
14 52 
# 827a8 Instruction { source: "Saving reg0x51 before None <= call print_dec32(t5,)", opcode: Push8, args: [Register(0x51)], resolved: None }
14 51 
# 827aa Instruction { source: "Saving reg0x50 before None <= call print_dec32(t5,)", opcode: Push8, args: [Register(0x50)], resolved: None }
14 50 
# 827ac Instruction { source: "Saving reg0x4f before None <= call print_dec32(t5,)", opcode: Push8, args: [Register(0x4f)], resolved: None }
14 4f 
# 827ae Instruction { source: "Saving reg0x4e before None <= call print_dec32(t5,)", opcode: Push8, args: [Register(0x4e)], resolved: None }
14 4e 
# 827b0 Instruction { source: "Saving reg0x4d before None <= call print_dec32(t5,)", opcode: Push8, args: [Register(0x4d)], resolved: None }
14 4d 
# 827b2 Instruction { source: "Saving reg0x4c before None <= call print_dec32(t5,)", opcode: Push8, args: [Register(0x4c)], resolved: None }
14 4c 
# 827b4 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 827ba Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c c4 27 08 00 
# 827c0 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: JmpImm, args: [Label24(:print_dec32)], resolved: None }
40 22 27 08 
# 827c4 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 827ca Instruction { source: "Restoring reg0x4c after None <= call print_dec32(t5,)", opcode: Pop8, args: [Register(0x4c)], resolved: None }
15 4c 
# 827cc Instruction { source: "Restoring reg0x4d after None <= call print_dec32(t5,)", opcode: Pop8, args: [Register(0x4d)], resolved: None }
15 4d 
# 827ce Instruction { source: "Restoring reg0x4e after None <= call print_dec32(t5,)", opcode: Pop8, args: [Register(0x4e)], resolved: None }
15 4e 
# 827d0 Instruction { source: "Restoring reg0x4f after None <= call print_dec32(t5,)", opcode: Pop8, args: [Register(0x4f)], resolved: None }
15 4f 
# 827d2 Instruction { source: "Restoring reg0x50 after None <= call print_dec32(t5,)", opcode: Pop8, args: [Register(0x50)], resolved: None }
15 50 
# 827d4 Instruction { source: "Restoring reg0x51 after None <= call print_dec32(t5,)", opcode: Pop8, args: [Register(0x51)], resolved: None }
15 51 
# 827d6 Instruction { source: "Restoring reg0x52 after None <= call print_dec32(t5,)", opcode: Pop8, args: [Register(0x52)], resolved: None }
15 52 
# 827d8 Instruction { source: "Restoring reg0x53 after None <= call print_dec32(t5,)", opcode: Pop8, args: [Register(0x53)], resolved: None }
15 53 
# 827da Instruction { source: "Restoring reg0x54 after None <= call print_dec32(t5,)", opcode: Pop8, args: [Register(0x54)], resolved: None }
15 54 
# 827dc Instruction { source: "Restoring reg0x55 after None <= call print_dec32(t5,)", opcode: Pop8, args: [Register(0x55)], resolved: None }
15 55 
# 827de Instruction { source: "Restoring reg0x58 after None <= call print_dec32(t5,)", opcode: Pop8, args: [Register(0x58)], resolved: None }
15 58 
# 827e0 Instruction { source: "Restoring reg0x59 after None <= call print_dec32(t5,)", opcode: Pop8, args: [Register(0x59)], resolved: None }
15 59 
# 827e2 Instruction { source: "Restoring reg0x5a after None <= call print_dec32(t5,)", opcode: Pop8, args: [Register(0x5a)], resolved: None }
15 5a 
# 827e4 Instruction { source: "Restoring reg0x5b after None <= call print_dec32(t5,)", opcode: Pop8, args: [Register(0x5b)], resolved: None }
15 5b 
# 827e6 Instruction { source: "t6 <- a U32", opcode: Copy32, args: [Register(0x4c), Register(0x4c)], resolved: None }
81 4c 4c 
# 827e9 Instruction { source: "t8 <- b U32", opcode: Copy32, args: [Register(0x50), Register(0x50)], resolved: None }
81 50 50 
# 827ec Instruction { source: "t9 <- 0n10/0x0000000au32 ", opcode: LoadImm32, args: [Register(0x58), Constant32(0x0000000a=10)], resolved: None }
80 58 0a 00 00 00 
# 827f2 Instruction { source: "Arg0[a]=t8 Some(t7) <= call mul32_32(t8,t9,)", opcode: Copy32, args: [Register(0x50), Register(0x00)], resolved: None }
81 50 00 
# 827f5 Instruction { source: "Arg1[b]=t9 Some(t7) <= call mul32_32(t8,t9,)", opcode: Copy32, args: [Register(0x58), Register(0x04)], resolved: None }
81 58 04 
# Registers used by this function: {76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 88, 89, 90, 91}
# Registers used by callee tree: {200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250}
# Registers to save: []
# 827f8 Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 827fe Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 08 28 08 00 
# 82804 Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: JmpImm, args: [Label24(:mul32_32)], resolved: None }
40 25 24 08 
# 82808 Instruction { source: "PseudoCall(Label24(:mul32_32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8280e Instruction { source: "Some(t7) <= call mul32_32(t8,t9,)", opcode: Copy32, args: [Register(0x00), Register(0x50)], resolved: None }
81 00 50 
# 82811 Instruction { source: "a <- t6 Subtract t7", opcode: Copy32, args: [Register(0x50), Register(0x00)], resolved: None }
81 50 00 
# 82814 Instruction { source: "a <- t6 Subtract t7", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 82816 Instruction { source: "a <- t6 Subtract t7", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 82818 Instruction { source: "a <- t6 Subtract t7", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 8281a Instruction { source: "a <- t6 Subtract t7", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 8281c Instruction { source: "a <- t6 Subtract t7", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 82822 Instruction { source: "a <- t6 Subtract t7", opcode: Add32NoCarryIn, args: [Register(0x4c), Register(0x00), Register(0x4c)], resolved: None }
a0 4c 00 4c 
# 82826 Instruction { source: "goto print_dec32_if_end_0", opcode: JmpImm, args: [Label24(print_dec32_if_end_0)], resolved: None }
40 2a 28 08 
# print_dec32_if_else_0_2
# print_dec32_if_end_0
# 8282a Instruction { source: "t11 <- a[0x00..0x01] U8", opcode: Copy8, args: [Register(0x4c), Register(0x54)], resolved: None }
16 4c 54 
# 8282d Instruction { source: "t12 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x55), Constant8(0x30=48)], resolved: None }
00 55 30 
# 82830 Instruction { source: "t10 <- t11 Add t12", opcode: Add8NoCarryIn, args: [Register(0x54), Register(0x55), Register(0x54)], resolved: None }
24 54 55 54 
# 82834 Instruction { source: "ttyout <- t10", opcode: TtyOut, args: [Register(0x54)], resolved: None }
13 54 
# 82836 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82838 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :print_dec32_test
# Ret Some(U8)
# Arg0=a
# Arg1=b
# Var a (Arg0 a Number(USIZE)) U32 Some([92, 93, 94, 95])
# Var b (Arg1 b Number(USIZE)) U32 Some([96, 97, 98, 99])
# Var t0 (t0 Call(Call { function: "print_dec32", parameters: [Ident("a")] })) U8 Some([100])
# Var t1 (t1 Ident("a")) U32 Some([92, 93, 94, 95])
# Var t2 (t2 Number(U8, 0)) U8 Some([100])
# 8283d Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [92, 93, 94, 95].", opcode: Copy32, args: [Register(0x00), Register(0x5c)], resolved: None }
81 00 5c 
# 82840 Instruction { source: "Save function parameter 'b' registers [4, 5, 6, 7] to locals [96, 97, 98, 99].", opcode: Copy32, args: [Register(0x04), Register(0x60)], resolved: None }
81 04 60 
# 82843 Instruction { source: "t1 <- a U32", opcode: Copy32, args: [Register(0x5c), Register(0x5c)], resolved: None }
81 5c 5c 
# 82846 Instruction { source: "Arg0[a]=t1 None <= call print_dec32(t1,)", opcode: Copy32, args: [Register(0x5c), Register(0x00)], resolved: None }
81 5c 00 
# Registers used by this function: {92, 93, 94, 95, 96, 97, 98, 99, 100}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 160, 161, 162, 163, 164, 168, 169, 170, 171, 172, 173, 174, 175, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 252, 253, 254, 255}
# Registers to save: [92, 93, 94, 95, 96, 97, 98, 99, 100]
# 82849 Instruction { source: "Saving reg0x64 before None <= call print_dec32(t1,)", opcode: Push8, args: [Register(0x64)], resolved: None }
14 64 
# 8284b Instruction { source: "Saving reg0x63 before None <= call print_dec32(t1,)", opcode: Push8, args: [Register(0x63)], resolved: None }
14 63 
# 8284d Instruction { source: "Saving reg0x62 before None <= call print_dec32(t1,)", opcode: Push8, args: [Register(0x62)], resolved: None }
14 62 
# 8284f Instruction { source: "Saving reg0x61 before None <= call print_dec32(t1,)", opcode: Push8, args: [Register(0x61)], resolved: None }
14 61 
# 82851 Instruction { source: "Saving reg0x60 before None <= call print_dec32(t1,)", opcode: Push8, args: [Register(0x60)], resolved: None }
14 60 
# 82853 Instruction { source: "Saving reg0x5f before None <= call print_dec32(t1,)", opcode: Push8, args: [Register(0x5f)], resolved: None }
14 5f 
# 82855 Instruction { source: "Saving reg0x5e before None <= call print_dec32(t1,)", opcode: Push8, args: [Register(0x5e)], resolved: None }
14 5e 
# 82857 Instruction { source: "Saving reg0x5d before None <= call print_dec32(t1,)", opcode: Push8, args: [Register(0x5d)], resolved: None }
14 5d 
# 82859 Instruction { source: "Saving reg0x5c before None <= call print_dec32(t1,)", opcode: Push8, args: [Register(0x5c)], resolved: None }
14 5c 
# 8285b Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82861 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 6b 28 08 00 
# 82867 Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: JmpImm, args: [Label24(:print_dec32)], resolved: None }
40 22 27 08 
# 8286b Instruction { source: "PseudoCall(Label24(:print_dec32))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82871 Instruction { source: "Restoring reg0x5c after None <= call print_dec32(t1,)", opcode: Pop8, args: [Register(0x5c)], resolved: None }
15 5c 
# 82873 Instruction { source: "Restoring reg0x5d after None <= call print_dec32(t1,)", opcode: Pop8, args: [Register(0x5d)], resolved: None }
15 5d 
# 82875 Instruction { source: "Restoring reg0x5e after None <= call print_dec32(t1,)", opcode: Pop8, args: [Register(0x5e)], resolved: None }
15 5e 
# 82877 Instruction { source: "Restoring reg0x5f after None <= call print_dec32(t1,)", opcode: Pop8, args: [Register(0x5f)], resolved: None }
15 5f 
# 82879 Instruction { source: "Restoring reg0x60 after None <= call print_dec32(t1,)", opcode: Pop8, args: [Register(0x60)], resolved: None }
15 60 
# 8287b Instruction { source: "Restoring reg0x61 after None <= call print_dec32(t1,)", opcode: Pop8, args: [Register(0x61)], resolved: None }
15 61 
# 8287d Instruction { source: "Restoring reg0x62 after None <= call print_dec32(t1,)", opcode: Pop8, args: [Register(0x62)], resolved: None }
15 62 
# 8287f Instruction { source: "Restoring reg0x63 after None <= call print_dec32(t1,)", opcode: Pop8, args: [Register(0x63)], resolved: None }
15 63 
# 82881 Instruction { source: "Restoring reg0x64 after None <= call print_dec32(t1,)", opcode: Pop8, args: [Register(0x64)], resolved: None }
15 64 
# 82883 Instruction { source: "t2 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x64), Constant8(0x00=0)], resolved: None }
00 64 00 
# 82886 Instruction { source: "return Some(t2)", opcode: Copy8, args: [Register(0x64), Register(0x00)], resolved: None }
16 64 00 
# 82889 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 8288b Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :print_dec8
# Ret None
# Arg0=a
# Var a (Arg0 a Number(U8)) U8 Some([101])
# Var b (Local b Number(U8) U8) U8 Some([102])
# Var t0 (t0 Ident("a")) U8 Some([101])
# Var t1 (t1 Number(U8, 10)) U8 Some([102])
# Var t10 (t10 Arithmetic(Add, Ident("a"), Number(U8, 48))) U8 Some([101])
# Var t11 (t11 Ident("a")) U8 Some([101])
# Var t12 (t12 Number(U8, 48)) U8 Some([102])
# Var t2 (t2 Ident("a")) U8 Some([101])
# Var t3 (t3 Number(U8, 10)) U8 Some([102])
# Var t4 (t4 Call(Call { function: "print_dec8", parameters: [Ident("b")] })) U8 Some([101])
# Var t5 (t5 Ident("b")) U8 Some([102])
# Var t6 (t6 Ident("a")) U8 Some([101])
# Var t7 (t7 Arithmetic(Multiply, Ident("b"), Number(U8, 10))) U8 Some([102])
# Var t8 (t8 Ident("b")) U8 Some([102])
# Var t9 (t9 Number(U8, 10)) U8 Some([103])
# 82890 Instruction { source: "Save function parameter 'a' registers [0] to locals [101].", opcode: Copy8, args: [Register(0x00), Register(0x65)], resolved: None }
16 00 65 
# 82893 Instruction { source: "t0 <- a U8", opcode: Copy8, args: [Register(0x65), Register(0x65)], resolved: None }
16 65 65 
# 82896 Instruction { source: "t1 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x66), Constant8(0x0a=10)], resolved: None }
00 66 0a 
# 82899 Instruction { source: "if t0 >= t1 then 'print_dec8_if_true_0_1' else 'print_dec8_if_else_0_2'", opcode: Cmp8, args: [Register(0x66), Register(0x65)], resolved: None }
25 66 65 
# 8289c Instruction { source: "if t0 >= t1 then 'print_dec8_if_true_0_1' else 'print_dec8_if_else_0_2'", opcode: JcImm, args: [Label24(print_dec8_if_true_0_1)], resolved: None }
41 a4 28 08 
# 828a0 Instruction { source: "if t0 >= t1 then 'print_dec8_if_true_0_1' else 'print_dec8_if_else_0_2'", opcode: JmpImm, args: [Label24(print_dec8_if_else_0_2)], resolved: None }
40 f3 28 08 
# print_dec8_if_true_0_1
# 828a4 Instruction { source: "t2 <- a U8", opcode: Copy8, args: [Register(0x65), Register(0x65)], resolved: None }
16 65 65 
# 828a7 Instruction { source: "t3 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x66), Constant8(0x0a=10)], resolved: None }
00 66 0a 
# 828aa Instruction { source: "b <- t2 Divide t3", opcode: Divide8, args: [Register(0x65), Register(0x66), Register(0x66)], resolved: None }
27 65 66 66 
# 828ae Instruction { source: "t5 <- b U8", opcode: Copy8, args: [Register(0x66), Register(0x66)], resolved: None }
16 66 66 
# 828b1 Instruction { source: "Arg0[a]=t5 None <= call print_dec8(t5,)", opcode: Copy8, args: [Register(0x66), Register(0x00)], resolved: None }
16 66 00 
# Registers used by this function: {101, 102, 103}
# Registers used by callee tree: {101, 102, 103}
# Registers to save: [101, 102, 103]
# 828b4 Instruction { source: "Saving reg0x67 before None <= call print_dec8(t5,)", opcode: Push8, args: [Register(0x67)], resolved: None }
14 67 
# 828b6 Instruction { source: "Saving reg0x66 before None <= call print_dec8(t5,)", opcode: Push8, args: [Register(0x66)], resolved: None }
14 66 
# 828b8 Instruction { source: "Saving reg0x65 before None <= call print_dec8(t5,)", opcode: Push8, args: [Register(0x65)], resolved: None }
14 65 
# 828ba Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 828c0 Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c ca 28 08 00 
# 828c6 Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: JmpImm, args: [Label24(:print_dec8)], resolved: None }
40 90 28 08 
# 828ca Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 828d0 Instruction { source: "Restoring reg0x65 after None <= call print_dec8(t5,)", opcode: Pop8, args: [Register(0x65)], resolved: None }
15 65 
# 828d2 Instruction { source: "Restoring reg0x66 after None <= call print_dec8(t5,)", opcode: Pop8, args: [Register(0x66)], resolved: None }
15 66 
# 828d4 Instruction { source: "Restoring reg0x67 after None <= call print_dec8(t5,)", opcode: Pop8, args: [Register(0x67)], resolved: None }
15 67 
# 828d6 Instruction { source: "t6 <- a U8", opcode: Copy8, args: [Register(0x65), Register(0x65)], resolved: None }
16 65 65 
# 828d9 Instruction { source: "t8 <- b U8", opcode: Copy8, args: [Register(0x66), Register(0x66)], resolved: None }
16 66 66 
# 828dc Instruction { source: "t9 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x67), Constant8(0x0a=10)], resolved: None }
00 67 0a 
# 828df Instruction { source: "t7 <- t8 Multiply t9", opcode: Mul8_1, args: [Register(0x66), Register(0x67)], resolved: None }
20 66 67 
# 828e2 Instruction { source: "t7 <- t8 Multiply t9", opcode: Mul8_2, args: [], resolved: None }
21 
# 828e3 Instruction { source: "t7 <- t8 Multiply t9", opcode: Copy8, args: [Register(0x00), Register(0x66)], resolved: None }
16 00 66 
# 828e6 Instruction { source: "a <- t6 Subtract t7", opcode: Copy8, args: [Register(0x66), Register(0x00)], resolved: None }
16 66 00 
# 828e9 Instruction { source: "a <- t6 Subtract t7", opcode: Negate8, args: [Register(0x00)], resolved: None }
04 00 
# 828eb Instruction { source: "a <- t6 Subtract t7", opcode: Add8NoCarryIn, args: [Register(0x65), Register(0x00), Register(0x65)], resolved: None }
24 65 00 65 
# 828ef Instruction { source: "goto print_dec8_if_end_0", opcode: JmpImm, args: [Label24(print_dec8_if_end_0)], resolved: None }
40 f3 28 08 
# print_dec8_if_else_0_2
# print_dec8_if_end_0
# 828f3 Instruction { source: "t11 <- a U8", opcode: Copy8, args: [Register(0x65), Register(0x65)], resolved: None }
16 65 65 
# 828f6 Instruction { source: "t12 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x66), Constant8(0x30=48)], resolved: None }
00 66 30 
# 828f9 Instruction { source: "t10 <- t11 Add t12", opcode: Add8NoCarryIn, args: [Register(0x65), Register(0x66), Register(0x65)], resolved: None }
24 65 66 65 
# 828fd Instruction { source: "ttyout <- t10", opcode: TtyOut, args: [Register(0x65)], resolved: None }
13 65 
# 828ff Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82901 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :print_dec8_test
# Ret Some(U8)
# Arg0=a
# Arg1=b
# Var a (Arg0 a Number(U8)) U8 Some([104])
# Var b (Arg1 b Number(U8)) U8 Some([105])
# Var t0 (t0 Call(Call { function: "print_dec8", parameters: [Ident("a")] })) U8 Some([104])
# Var t1 (t1 Ident("a")) U8 Some([104])
# Var t2 (t2 Number(U8, 0)) U8 Some([104])
# 82906 Instruction { source: "Save function parameter 'a' registers [0] to locals [104].", opcode: Copy8, args: [Register(0x00), Register(0x68)], resolved: None }
16 00 68 
# 82909 Instruction { source: "Save function parameter 'b' registers [4] to locals [105].", opcode: Copy8, args: [Register(0x04), Register(0x69)], resolved: None }
16 04 69 
# 8290c Instruction { source: "t1 <- a U8", opcode: Copy8, args: [Register(0x68), Register(0x68)], resolved: None }
16 68 68 
# 8290f Instruction { source: "Arg0[a]=t1 None <= call print_dec8(t1,)", opcode: Copy8, args: [Register(0x68), Register(0x00)], resolved: None }
16 68 00 
# Registers used by this function: {104, 105}
# Registers used by callee tree: {101, 102, 103}
# Registers to save: []
# 82912 Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82918 Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 22 29 08 00 
# 8291e Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: JmpImm, args: [Label24(:print_dec8)], resolved: None }
40 90 28 08 
# 82922 Instruction { source: "PseudoCall(Label24(:print_dec8))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82928 Instruction { source: "t2 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x68), Constant8(0x00=0)], resolved: None }
00 68 00 
# 8292b Instruction { source: "return Some(t2)", opcode: Copy8, args: [Register(0x68), Register(0x00)], resolved: None }
16 68 00 
# 8292e Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82930 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :print_digit
# Ret None
# Arg0=a
# Var a (Arg0 a Number(U8)) U8 Some([106])
# Var t0 (t0 Ident("a")) U8 Some([106])
# Var t1 (t1 Number(U8, 10)) U8 Some([107])
# Var t2 (t2 Arithmetic(Add, Ident("a"), Number(U8, 48))) U8 Some([106])
# Var t3 (t3 Ident("a")) U8 Some([106])
# Var t4 (t4 Number(U8, 48)) U8 Some([107])
# Var t5 (t5 Ident("a")) U8 Some([106])
# Var t6 (t6 Number(U8, 10)) U8 Some([107])
# Var t7 (t7 Ident("a")) U8 Some([106])
# Var t8 (t8 Number(U8, 65)) U8 Some([107])
# Var t9 (t9 Ident("a")) U8 Some([106])
# 82935 Instruction { source: "Save function parameter 'a' registers [0] to locals [106].", opcode: Copy8, args: [Register(0x00), Register(0x6a)], resolved: None }
16 00 6a 
# 82938 Instruction { source: "t0 <- a U8", opcode: Copy8, args: [Register(0x6a), Register(0x6a)], resolved: None }
16 6a 6a 
# 8293b Instruction { source: "t1 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x6b), Constant8(0x0a=10)], resolved: None }
00 6b 0a 
# 8293e Instruction { source: "if t0 < t1 then 'print_digit_if_true_0_1' else 'print_digit_if_else_0_2'", opcode: Cmp8, args: [Register(0x6b), Register(0x6a)], resolved: None }
25 6b 6a 
# 82941 Instruction { source: "if t0 < t1 then 'print_digit_if_true_0_1' else 'print_digit_if_else_0_2'", opcode: JcImm, args: [Label24(print_digit_if_else_0_2)], resolved: None }
41 55 29 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t0 < t1 then 'print_digit_if_true_0_1' else 'print_digit_if_else_0_2'", opcode: JmpImm, args: [Label24(print_digit_if_true_0_1)], resolved: None }
# print_digit_if_true_0_1
# 82945 Instruction { source: "t3 <- a U8", opcode: Copy8, args: [Register(0x6a), Register(0x6a)], resolved: None }
16 6a 6a 
# 82948 Instruction { source: "t4 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x6b), Constant8(0x30=48)], resolved: None }
00 6b 30 
# 8294b Instruction { source: "t2 <- t3 Add t4", opcode: Add8NoCarryIn, args: [Register(0x6a), Register(0x6b), Register(0x6a)], resolved: None }
24 6a 6b 6a 
# 8294f Instruction { source: "ttyout <- t2", opcode: TtyOut, args: [Register(0x6a)], resolved: None }
13 6a 
# 82951 Instruction { source: "goto print_digit_if_end_0", opcode: JmpImm, args: [Label24(print_digit_if_end_0)], resolved: None }
40 73 29 08 
# print_digit_if_else_0_2
# 82955 Instruction { source: "t5 <- a U8", opcode: Copy8, args: [Register(0x6a), Register(0x6a)], resolved: None }
16 6a 6a 
# 82958 Instruction { source: "t6 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x6b), Constant8(0x0a=10)], resolved: None }
00 6b 0a 
# 8295b Instruction { source: "a <- t5 Subtract t6", opcode: Copy8, args: [Register(0x6b), Register(0x00)], resolved: None }
16 6b 00 
# 8295e Instruction { source: "a <- t5 Subtract t6", opcode: Negate8, args: [Register(0x00)], resolved: None }
04 00 
# 82960 Instruction { source: "a <- t5 Subtract t6", opcode: Add8NoCarryIn, args: [Register(0x6a), Register(0x00), Register(0x6a)], resolved: None }
24 6a 00 6a 
# 82964 Instruction { source: "t7 <- a U8", opcode: Copy8, args: [Register(0x6a), Register(0x6a)], resolved: None }
16 6a 6a 
# 82967 Instruction { source: "t8 <- 0n65/0x41u8 ", opcode: LoadImm8, args: [Register(0x6b), Constant8(0x41=65)], resolved: None }
00 6b 41 
# 8296a Instruction { source: "a <- t7 Add t8", opcode: Add8NoCarryIn, args: [Register(0x6a), Register(0x6b), Register(0x6a)], resolved: None }
24 6a 6b 6a 
# 8296e Instruction { source: "t9 <- a U8", opcode: Copy8, args: [Register(0x6a), Register(0x6a)], resolved: None }
16 6a 6a 
# 82971 Instruction { source: "ttyout <- t9", opcode: TtyOut, args: [Register(0x6a)], resolved: None }
13 6a 
# print_digit_if_end_0
# 82973 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82975 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :println
# Ret None
# Arg0=buf
# Var buf (Arg0 buf Ptr(Number(U8))) U32 Some([108, 109, 110, 111])
# Var ch (Local ch Number(U8) U8) U8 Some([112])
# Var t0 (t0 Ident("buf")) U32 Some([108, 109, 110, 111])
# Var t1 (t1 Ident("ch")) U8 Some([112])
# Var t2 (t2 Number(U8, 0)) U8 Some([113])
# Var t3 (t3 Ident("ch")) U8 Some([112])
# Var t4 (t4 Ident("buf")) U32 Some([108, 109, 110, 111])
# Var t5 (t5 Number(USIZE, 1)) U32 Some([116, 117, 118, 119])
# Var t6 (t6 Ident("buf")) U32 Some([108, 109, 110, 111])
# 8297a Instruction { source: "Save function parameter 'buf' registers [0, 1, 2, 3] to locals [108, 109, 110, 111].", opcode: Copy32, args: [Register(0x00), Register(0x6c)], resolved: None }
81 00 6c 
# 8297d Instruction { source: "t0 <- buf U32", opcode: Copy32, args: [Register(0x6c), Register(0x6c)], resolved: None }
81 6c 6c 
# 82980 Instruction { source: "ch <- mem[t0] U8", opcode: Load8, args: [Register(0x6c), Register(0x70)], resolved: None }
10 6c 70 
# println_while_predicate_0
# 82983 Instruction { source: "t1 <- ch U8", opcode: Copy8, args: [Register(0x70), Register(0x70)], resolved: None }
16 70 70 
# 82986 Instruction { source: "t2 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x71), Constant8(0x00=0)], resolved: None }
00 71 00 
# 82989 Instruction { source: "if t1 != t2 then 'println_while_body_1' else 'println_while_end_2'", opcode: Cmp8, args: [Register(0x70), Register(0x71)], resolved: None }
25 70 71 
# 8298c Instruction { source: "if t1 != t2 then 'println_while_body_1' else 'println_while_end_2'", opcode: JzImm, args: [Label24(println_while_end_2)], resolved: None }
42 ac 29 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if t1 != t2 then 'println_while_body_1' else 'println_while_end_2'", opcode: JmpImm, args: [Label24(println_while_body_1)], resolved: None }
# println_while_body_1
# 82990 Instruction { source: "t3 <- ch U8", opcode: Copy8, args: [Register(0x70), Register(0x70)], resolved: None }
16 70 70 
# 82993 Instruction { source: "ttyout <- t3", opcode: TtyOut, args: [Register(0x70)], resolved: None }
13 70 
# 82995 Instruction { source: "t4 <- buf U32", opcode: Copy32, args: [Register(0x6c), Register(0x6c)], resolved: None }
81 6c 6c 
# 82998 Instruction { source: "t5 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x74), Constant32(0x00000001=1)], resolved: None }
80 74 01 00 00 00 
# 8299e Instruction { source: "buf <- t4 Add t5", opcode: Add32NoCarryIn, args: [Register(0x6c), Register(0x74), Register(0x6c)], resolved: None }
a0 6c 74 6c 
# 829a2 Instruction { source: "t6 <- buf U32", opcode: Copy32, args: [Register(0x6c), Register(0x6c)], resolved: None }
81 6c 6c 
# 829a5 Instruction { source: "ch <- mem[t6] U8", opcode: Load8, args: [Register(0x6c), Register(0x70)], resolved: None }
10 6c 70 
# 829a8 Instruction { source: "goto println_while_predicate_0", opcode: JmpImm, args: [Label24(println_while_predicate_0)], resolved: None }
40 83 29 08 
# println_while_end_2
# 829ac Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 829ae Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :readline
# Ret None
# Arg0=buf
# Var buf (Arg0 buf Ptr(Number(U8))) U32 Some([120, 121, 122, 123])
# Var ch (Local ch Number(U8) U8) U8 Some([124])
# Var t0 (t0 Number(U8, 0)) U8 Some([124])
# Var t1 (t1 Number(U8, 0)) U8 Some([125])
# Var t10 (t10 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Number(U8))), new_type: Number(USIZE), value: Ident("buf") }, Number(USIZE, 1)) }) U32 Some([120, 121, 122, 123])
# Var t11 (t11 Cast { old_type: Some(Ptr(Number(U8))), new_type: Number(USIZE), value: Ident("buf") }) U32 Some([120, 121, 122, 123])
# Var t12 (t12 Number(USIZE, 1)) U32 Some([128, 129, 130, 131])
# Var t2 (t2 Ident("ch")) U8 Some([124])
# Var t3 (t3 Number(U8, 13)) U8 Some([125])
# Var t4 (t4 Ident("ch")) U8 Some([124])
# Var t5 (t5 Number(U8, 10)) U8 Some([125])
# Var t6 (t6 Ident("buf")) U32 Some([120, 121, 122, 123])
# Var t7 (t7 Number(U8, 0)) U8 Some([124])
# Var t8 (t8 Ident("buf")) U32 Some([120, 121, 122, 123])
# Var t9 (t9 Ident("ch")) U8 Some([124])
# 829b3 Instruction { source: "Save function parameter 'buf' registers [0, 1, 2, 3] to locals [120, 121, 122, 123].", opcode: Copy32, args: [Register(0x00), Register(0x78)], resolved: None }
81 00 78 
# readline_while_predicate_0
# 829b6 Instruction { source: "t0 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x7c), Constant8(0x00=0)], resolved: None }
00 7c 00 
# 829b9 Instruction { source: "t1 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x7d), Constant8(0x00=0)], resolved: None }
00 7d 00 
# 829bc Instruction { source: "if t0 == t1 then 'readline_while_body_1' else 'readline_while_end_2'", opcode: Cmp8, args: [Register(0x7c), Register(0x7d)], resolved: None }
25 7c 7d 
# 829bf Instruction { source: "if t0 == t1 then 'readline_while_body_1' else 'readline_while_end_2'", opcode: JzImm, args: [Label24(readline_while_body_1)], resolved: None }
42 c7 29 08 
# 829c3 Instruction { source: "if t0 == t1 then 'readline_while_body_1' else 'readline_while_end_2'", opcode: JmpImm, args: [Label24(readline_while_end_2)], resolved: None }
40 32 2a 08 
# readline_while_body_1
# Registers used by this function: {120, 121, 122, 123, 124, 125, 128, 129, 130, 131}
# Registers used by callee tree: {176, 177, 178}
# Registers to save: []
# 829c7 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 829cd Instruction { source: "PseudoCall(Label24(:getchar))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c d7 29 08 00 
# 829d3 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: JmpImm, args: [Label24(:getchar)], resolved: None }
40 12 22 08 
# 829d7 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 829dd Instruction { source: "Some(ch) <= call getchar()", opcode: Copy8, args: [Register(0x00), Register(0x7c)], resolved: None }
16 00 7c 
# 829e0 Instruction { source: "t2 <- ch U8", opcode: Copy8, args: [Register(0x7c), Register(0x7c)], resolved: None }
16 7c 7c 
# 829e3 Instruction { source: "t3 <- 0n13/0x0du8 ", opcode: LoadImm8, args: [Register(0x7d), Constant8(0x0d=13)], resolved: None }
00 7d 0d 
# 829e6 Instruction { source: "if t2 == t3 then 'readline_if_true_0_4' else 'readline_if_else_0_5'", opcode: Cmp8, args: [Register(0x7c), Register(0x7d)], resolved: None }
25 7c 7d 
# 829e9 Instruction { source: "if t2 == t3 then 'readline_if_true_0_4' else 'readline_if_else_0_5'", opcode: JzImm, args: [Label24(readline_if_true_0_4)], resolved: None }
42 f1 29 08 
# 829ed Instruction { source: "if t2 == t3 then 'readline_if_true_0_4' else 'readline_if_else_0_5'", opcode: JmpImm, args: [Label24(readline_if_else_0_5)], resolved: None }
40 f5 29 08 
# readline_if_true_0_4
# 829f1 Instruction { source: "goto readline_if_end_3", opcode: JmpImm, args: [Label24(readline_if_end_3)], resolved: None }
40 2e 2a 08 
# readline_if_else_0_5
# 829f5 Instruction { source: "t4 <- ch U8", opcode: Copy8, args: [Register(0x7c), Register(0x7c)], resolved: None }
16 7c 7c 
# 829f8 Instruction { source: "t5 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x7d), Constant8(0x0a=10)], resolved: None }
00 7d 0a 
# 829fb Instruction { source: "if t4 == t5 then 'readline_if_true_1_6' else 'readline_if_else_1_7'", opcode: Cmp8, args: [Register(0x7c), Register(0x7d)], resolved: None }
25 7c 7d 
# 829fe Instruction { source: "if t4 == t5 then 'readline_if_true_1_6' else 'readline_if_else_1_7'", opcode: JzImm, args: [Label24(readline_if_true_1_6)], resolved: None }
42 06 2a 08 
# 82a02 Instruction { source: "if t4 == t5 then 'readline_if_true_1_6' else 'readline_if_else_1_7'", opcode: JmpImm, args: [Label24(readline_if_else_1_7)], resolved: None }
40 15 2a 08 
# readline_if_true_1_6
# 82a06 Instruction { source: "t6 <- buf U32", opcode: Copy32, args: [Register(0x78), Register(0x78)], resolved: None }
81 78 78 
# 82a09 Instruction { source: "t7 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x7c), Constant8(0x00=0)], resolved: None }
00 7c 00 
# 82a0c Instruction { source: "mem[t6] <- t7 U8", opcode: Store8, args: [Register(0x7c), Register(0x78)], resolved: None }
11 7c 78 
# 82a0f Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82a11 Instruction { source: "goto readline_if_end_3", opcode: JmpImm, args: [Label24(readline_if_end_3)], resolved: None }
40 2e 2a 08 
# readline_if_else_1_7
# 82a15 Instruction { source: "t8 <- buf U32", opcode: Copy32, args: [Register(0x78), Register(0x78)], resolved: None }
81 78 78 
# 82a18 Instruction { source: "t9 <- ch U8", opcode: Copy8, args: [Register(0x7c), Register(0x7c)], resolved: None }
16 7c 7c 
# 82a1b Instruction { source: "mem[t8] <- t9 U8", opcode: Store8, args: [Register(0x7c), Register(0x78)], resolved: None }
11 7c 78 
# 82a1e Instruction { source: "t11 <- buf U32", opcode: Copy32, args: [Register(0x78), Register(0x78)], resolved: None }
81 78 78 
# 82a21 Instruction { source: "t12 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x80), Constant32(0x00000001=1)], resolved: None }
80 80 01 00 00 00 
# 82a27 Instruction { source: "t10 <- t11 Add t12", opcode: Add32NoCarryIn, args: [Register(0x78), Register(0x80), Register(0x78)], resolved: None }
a0 78 80 78 
# 82a2b Instruction { source: "buf <- t10 U32", opcode: Copy32, args: [Register(0x78), Register(0x78)], resolved: None }
81 78 78 
# readline_if_end_3
# 82a2e Instruction { source: "goto readline_while_predicate_0", opcode: JmpImm, args: [Label24(readline_while_predicate_0)], resolved: None }
40 b6 29 08 
# readline_while_end_2
# 82a32 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82a34 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :shiftright1
# Ret Some(U32)
# Arg0=a
# Var a (Arg0 a Number(USIZE)) U32 Some([132, 133, 134, 135])
# Var t0 (t0 Arithmetic(RotateRight, Index("a", Number(U8, 0)), Number(U8, 1))) U8 Some([136])
# Var t1 (t1 Index("a", Number(U8, 0))) U8 Some([137])
# Var t10 (t10 Index("a", Number(U8, 3))) U8 Some([137])
# Var t11 (t11 Number(U8, 1)) U8 Some([136])
# Var t12 (t12 Arithmetic(And, Index("a", Number(U8, 0)), Number(U8, 127))) U8 Some([136])
# Var t13 (t13 Index("a", Number(U8, 0))) U8 Some([137])
# Var t14 (t14 Number(U8, 127)) U8 Some([136])
# Var t15 (t15 Arithmetic(Or, Index("a", Number(U8, 0)), Arithmetic(And, Index("a", Number(U8, 1)), Number(U8, 128)))) U8 Some([136])
# Var t16 (t16 Index("a", Number(U8, 0))) U8 Some([137])
# Var t17 (t17 Arithmetic(And, Index("a", Number(U8, 1)), Number(U8, 128))) U8 Some([136])
# Var t18 (t18 Index("a", Number(U8, 1))) U8 Some([136])
# Var t19 (t19 Number(U8, 128)) U8 Some([138])
# Var t2 (t2 Number(U8, 1)) U8 Some([136])
# Var t20 (t20 Arithmetic(And, Index("a", Number(U8, 1)), Number(U8, 127))) U8 Some([136])
# Var t21 (t21 Index("a", Number(U8, 1))) U8 Some([137])
# Var t22 (t22 Number(U8, 127)) U8 Some([136])
# Var t23 (t23 Arithmetic(Or, Index("a", Number(U8, 1)), Arithmetic(And, Index("a", Number(U8, 2)), Number(U8, 128)))) U8 Some([136])
# Var t24 (t24 Index("a", Number(U8, 1))) U8 Some([137])
# Var t25 (t25 Arithmetic(And, Index("a", Number(U8, 2)), Number(U8, 128))) U8 Some([136])
# Var t26 (t26 Index("a", Number(U8, 2))) U8 Some([136])
# Var t27 (t27 Number(U8, 128)) U8 Some([138])
# Var t28 (t28 Arithmetic(And, Index("a", Number(U8, 2)), Number(U8, 127))) U8 Some([136])
# Var t29 (t29 Index("a", Number(U8, 2))) U8 Some([137])
# Var t3 (t3 Arithmetic(RotateRight, Index("a", Number(U8, 1)), Number(U8, 1))) U8 Some([136])
# Var t30 (t30 Number(U8, 127)) U8 Some([136])
# Var t31 (t31 Arithmetic(Or, Index("a", Number(U8, 2)), Arithmetic(And, Index("a", Number(U8, 3)), Number(U8, 128)))) U8 Some([136])
# Var t32 (t32 Index("a", Number(U8, 2))) U8 Some([137])
# Var t33 (t33 Arithmetic(And, Index("a", Number(U8, 3)), Number(U8, 128))) U8 Some([136])
# Var t34 (t34 Index("a", Number(U8, 3))) U8 Some([136])
# Var t35 (t35 Number(U8, 128)) U8 Some([138])
# Var t36 (t36 Arithmetic(And, Index("a", Number(U8, 3)), Number(U8, 127))) U8 Some([136])
# Var t37 (t37 Index("a", Number(U8, 3))) U8 Some([137])
# Var t38 (t38 Number(U8, 127)) U8 Some([136])
# Var t39 (t39 Ident("a")) U32 Some([132, 133, 134, 135])
# Var t4 (t4 Index("a", Number(U8, 1))) U8 Some([137])
# Var t5 (t5 Number(U8, 1)) U8 Some([136])
# Var t6 (t6 Arithmetic(RotateRight, Index("a", Number(U8, 2)), Number(U8, 1))) U8 Some([136])
# Var t7 (t7 Index("a", Number(U8, 2))) U8 Some([137])
# Var t8 (t8 Number(U8, 1)) U8 Some([136])
# Var t9 (t9 Arithmetic(RotateRight, Index("a", Number(U8, 3)), Number(U8, 1))) U8 Some([136])
# 82a39 Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [132, 133, 134, 135].", opcode: Copy32, args: [Register(0x00), Register(0x84)], resolved: None }
81 00 84 
# 82a3c Instruction { source: "t1 <- a[0x00..0x01] U8", opcode: Copy8, args: [Register(0x84), Register(0x89)], resolved: None }
16 84 89 
# 82a3f Instruction { source: "t2 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x88), Constant8(0x01=1)], resolved: None }
00 88 01 
# 82a42 Instruction { source: "t0 <- t1 RotateRight t2", opcode: Shift8, args: [Constant8(0x04=4), Register(0x88), Register(0x89), Register(0x88)], resolved: None }
36 04 88 89 88 
# 82a47 Instruction { source: "a[0x00..0x01] <- t0 U8", opcode: Copy8, args: [Register(0x88), Register(0x84)], resolved: None }
16 88 84 
# 82a4a Instruction { source: "t4 <- a[0x01..0x02] U8", opcode: Copy8, args: [Register(0x85), Register(0x89)], resolved: None }
16 85 89 
# 82a4d Instruction { source: "t5 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x88), Constant8(0x01=1)], resolved: None }
00 88 01 
# 82a50 Instruction { source: "t3 <- t4 RotateRight t5", opcode: Shift8, args: [Constant8(0x04=4), Register(0x88), Register(0x89), Register(0x88)], resolved: None }
36 04 88 89 88 
# 82a55 Instruction { source: "a[0x01..0x02] <- t3 U8", opcode: Copy8, args: [Register(0x88), Register(0x85)], resolved: None }
16 88 85 
# 82a58 Instruction { source: "t7 <- a[0x02..0x03] U8", opcode: Copy8, args: [Register(0x86), Register(0x89)], resolved: None }
16 86 89 
# 82a5b Instruction { source: "t8 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x88), Constant8(0x01=1)], resolved: None }
00 88 01 
# 82a5e Instruction { source: "t6 <- t7 RotateRight t8", opcode: Shift8, args: [Constant8(0x04=4), Register(0x88), Register(0x89), Register(0x88)], resolved: None }
36 04 88 89 88 
# 82a63 Instruction { source: "a[0x02..0x03] <- t6 U8", opcode: Copy8, args: [Register(0x88), Register(0x86)], resolved: None }
16 88 86 
# 82a66 Instruction { source: "t10 <- a[0x03..0x04] U8", opcode: Copy8, args: [Register(0x87), Register(0x89)], resolved: None }
16 87 89 
# 82a69 Instruction { source: "t11 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x88), Constant8(0x01=1)], resolved: None }
00 88 01 
# 82a6c Instruction { source: "t9 <- t10 RotateRight t11", opcode: Shift8, args: [Constant8(0x04=4), Register(0x88), Register(0x89), Register(0x88)], resolved: None }
36 04 88 89 88 
# 82a71 Instruction { source: "a[0x03..0x04] <- t9 U8", opcode: Copy8, args: [Register(0x88), Register(0x87)], resolved: None }
16 88 87 
# 82a74 Instruction { source: "t13 <- a[0x00..0x01] U8", opcode: Copy8, args: [Register(0x84), Register(0x89)], resolved: None }
16 84 89 
# 82a77 Instruction { source: "t14 <- 0n127/0x7fu8 ", opcode: LoadImm8, args: [Register(0x88), Constant8(0x7f=127)], resolved: None }
00 88 7f 
# 82a7a Instruction { source: "t12 <- t13 BitwiseAnd t14", opcode: And8, args: [Register(0x89), Register(0x88), Register(0x88)], resolved: None }
33 89 88 88 
# 82a7e Instruction { source: "a[0x00..0x01] <- t12 U8", opcode: Copy8, args: [Register(0x88), Register(0x84)], resolved: None }
16 88 84 
# 82a81 Instruction { source: "t16 <- a[0x00..0x01] U8", opcode: Copy8, args: [Register(0x84), Register(0x89)], resolved: None }
16 84 89 
# 82a84 Instruction { source: "t18 <- a[0x01..0x02] U8", opcode: Copy8, args: [Register(0x85), Register(0x88)], resolved: None }
16 85 88 
# 82a87 Instruction { source: "t19 <- 0n128/0x80u8 ", opcode: LoadImm8, args: [Register(0x8a), Constant8(0x80=128)], resolved: None }
00 8a 80 
# 82a8a Instruction { source: "t17 <- t18 BitwiseAnd t19", opcode: And8, args: [Register(0x88), Register(0x8a), Register(0x88)], resolved: None }
33 88 8a 88 
# 82a8e Instruction { source: "t15 <- t16 BitwiseOr t17", opcode: Or8, args: [Register(0x89), Register(0x88), Register(0x88)], resolved: None }
34 89 88 88 
# 82a92 Instruction { source: "a[0x00..0x01] <- t15 U8", opcode: Copy8, args: [Register(0x88), Register(0x84)], resolved: None }
16 88 84 
# 82a95 Instruction { source: "t21 <- a[0x01..0x02] U8", opcode: Copy8, args: [Register(0x85), Register(0x89)], resolved: None }
16 85 89 
# 82a98 Instruction { source: "t22 <- 0n127/0x7fu8 ", opcode: LoadImm8, args: [Register(0x88), Constant8(0x7f=127)], resolved: None }
00 88 7f 
# 82a9b Instruction { source: "t20 <- t21 BitwiseAnd t22", opcode: And8, args: [Register(0x89), Register(0x88), Register(0x88)], resolved: None }
33 89 88 88 
# 82a9f Instruction { source: "a[0x01..0x02] <- t20 U8", opcode: Copy8, args: [Register(0x88), Register(0x85)], resolved: None }
16 88 85 
# 82aa2 Instruction { source: "t24 <- a[0x01..0x02] U8", opcode: Copy8, args: [Register(0x85), Register(0x89)], resolved: None }
16 85 89 
# 82aa5 Instruction { source: "t26 <- a[0x02..0x03] U8", opcode: Copy8, args: [Register(0x86), Register(0x88)], resolved: None }
16 86 88 
# 82aa8 Instruction { source: "t27 <- 0n128/0x80u8 ", opcode: LoadImm8, args: [Register(0x8a), Constant8(0x80=128)], resolved: None }
00 8a 80 
# 82aab Instruction { source: "t25 <- t26 BitwiseAnd t27", opcode: And8, args: [Register(0x88), Register(0x8a), Register(0x88)], resolved: None }
33 88 8a 88 
# 82aaf Instruction { source: "t23 <- t24 BitwiseOr t25", opcode: Or8, args: [Register(0x89), Register(0x88), Register(0x88)], resolved: None }
34 89 88 88 
# 82ab3 Instruction { source: "a[0x01..0x02] <- t23 U8", opcode: Copy8, args: [Register(0x88), Register(0x85)], resolved: None }
16 88 85 
# 82ab6 Instruction { source: "t29 <- a[0x02..0x03] U8", opcode: Copy8, args: [Register(0x86), Register(0x89)], resolved: None }
16 86 89 
# 82ab9 Instruction { source: "t30 <- 0n127/0x7fu8 ", opcode: LoadImm8, args: [Register(0x88), Constant8(0x7f=127)], resolved: None }
00 88 7f 
# 82abc Instruction { source: "t28 <- t29 BitwiseAnd t30", opcode: And8, args: [Register(0x89), Register(0x88), Register(0x88)], resolved: None }
33 89 88 88 
# 82ac0 Instruction { source: "a[0x02..0x03] <- t28 U8", opcode: Copy8, args: [Register(0x88), Register(0x86)], resolved: None }
16 88 86 
# 82ac3 Instruction { source: "t32 <- a[0x02..0x03] U8", opcode: Copy8, args: [Register(0x86), Register(0x89)], resolved: None }
16 86 89 
# 82ac6 Instruction { source: "t34 <- a[0x03..0x04] U8", opcode: Copy8, args: [Register(0x87), Register(0x88)], resolved: None }
16 87 88 
# 82ac9 Instruction { source: "t35 <- 0n128/0x80u8 ", opcode: LoadImm8, args: [Register(0x8a), Constant8(0x80=128)], resolved: None }
00 8a 80 
# 82acc Instruction { source: "t33 <- t34 BitwiseAnd t35", opcode: And8, args: [Register(0x88), Register(0x8a), Register(0x88)], resolved: None }
33 88 8a 88 
# 82ad0 Instruction { source: "t31 <- t32 BitwiseOr t33", opcode: Or8, args: [Register(0x89), Register(0x88), Register(0x88)], resolved: None }
34 89 88 88 
# 82ad4 Instruction { source: "a[0x02..0x03] <- t31 U8", opcode: Copy8, args: [Register(0x88), Register(0x86)], resolved: None }
16 88 86 
# 82ad7 Instruction { source: "t37 <- a[0x03..0x04] U8", opcode: Copy8, args: [Register(0x87), Register(0x89)], resolved: None }
16 87 89 
# 82ada Instruction { source: "t38 <- 0n127/0x7fu8 ", opcode: LoadImm8, args: [Register(0x88), Constant8(0x7f=127)], resolved: None }
00 88 7f 
# 82add Instruction { source: "t36 <- t37 BitwiseAnd t38", opcode: And8, args: [Register(0x89), Register(0x88), Register(0x88)], resolved: None }
33 89 88 88 
# 82ae1 Instruction { source: "a[0x03..0x04] <- t36 U8", opcode: Copy8, args: [Register(0x88), Register(0x87)], resolved: None }
16 88 87 
# 82ae4 Instruction { source: "t39 <- a U32", opcode: Copy32, args: [Register(0x84), Register(0x84)], resolved: None }
81 84 84 
# 82ae7 Instruction { source: "return Some(t39)", opcode: Copy32, args: [Register(0x84), Register(0x00)], resolved: None }
81 84 00 
# 82aea Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82aec Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :stack_get
# Ret Some(U32)
# Arg0=s
# Arg1=n
# Var n (Arg1 n Number(USIZE)) U32 Some([140, 141, 142, 143])
# Var s (Arg0 s Ptr(Struct("Stack"))) U32 Some([144, 145, 146, 147])
# Var t0 (t0 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Array(Number(USIZE), 16)), value: Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") } }) U32 Some([144, 145, 146, 147])
# Var t1 (t1 Index("values", Ident("n"))) U32 Some([140, 141, 142, 143])
# Var t2 (t2 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Number(USIZE))), new_type: Number(USIZE), value: Ident("values") }, Arithmetic(Multiply, Ident("n"), Number(USIZE, 4))) }) U32 Some([140, 141, 142, 143])
# Var t3 (t3 Cast { old_type: Some(Ptr(Number(USIZE))), new_type: Number(USIZE), value: Ident("values") }) U32 Some([144, 145, 146, 147])
# Var t4 (t4 Arithmetic(Multiply, Ident("n"), Number(USIZE, 4))) U32 Some([140, 141, 142, 143])
# Var t5 (t5 Ident("n")) U32 Some([140, 141, 142, 143])
# Var t6 (t6 Number(USIZE, 4)) U32 Some([148, 149, 150, 151])
# Var values (Local values Ptr(Number(USIZE)) U32) U32 Some([144, 145, 146, 147])
# 82af1 Instruction { source: "Save function parameter 's' registers [0, 1, 2, 3] to locals [144, 145, 146, 147].", opcode: Copy32, args: [Register(0x00), Register(0x90)], resolved: None }
81 00 90 
# 82af4 Instruction { source: "Save function parameter 'n' registers [4, 5, 6, 7] to locals [140, 141, 142, 143].", opcode: Copy32, args: [Register(0x04), Register(0x8c)], resolved: None }
81 04 8c 
# 82af7 Instruction { source: "t0 <- s U32", opcode: Copy32, args: [Register(0x90), Register(0x90)], resolved: None }
81 90 90 
# 82afa Instruction { source: "values <- t0 U32", opcode: Copy32, args: [Register(0x90), Register(0x90)], resolved: None }
81 90 90 
# 82afd Instruction { source: "t3 <- values U32", opcode: Copy32, args: [Register(0x90), Register(0x90)], resolved: None }
81 90 90 
# 82b00 Instruction { source: "t5 <- n U32", opcode: Copy32, args: [Register(0x8c), Register(0x8c)], resolved: None }
81 8c 8c 
# 82b03 Instruction { source: "t6 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x94), Constant32(0x00000004=4)], resolved: None }
80 94 04 00 00 00 
# 82b09 Instruction { source: "t4 <- t5 Multiply t6", opcode: LoadImm32, args: [Register(0x00), Constant32(0x00000000=0)], resolved: None }
80 00 00 00 00 00 
# 82b0f Instruction { source: "t4 <- t5 Multiply t6", opcode: Mul8_1, args: [Register(0x8c), Register(0x94)], resolved: None }
20 8c 94 
# 82b12 Instruction { source: "t4 <- t5 Multiply t6", opcode: Mul8_2, args: [], resolved: None }
21 
# 82b13 Instruction { source: "t4 <- t5 Multiply t6", opcode: Copy32, args: [Register(0x00), Register(0x8c)], resolved: None }
81 00 8c 
# 82b16 Instruction { source: "t2 <- t3 Add t4", opcode: Add32NoCarryIn, args: [Register(0x90), Register(0x8c), Register(0x8c)], resolved: None }
a0 90 8c 8c 
# 82b1a Instruction { source: "t1 <- mem[t2] U32", opcode: Load32, args: [Register(0x8c), Register(0x8c)], resolved: None }
90 8c 8c 
# 82b1d Instruction { source: "return Some(t1)", opcode: Copy32, args: [Register(0x8c), Register(0x00)], resolved: None }
81 8c 00 
# 82b20 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82b22 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :stack_init
# Ret None
# Arg0=s
# Var s (Arg0 s Ptr(Struct("Stack"))) U32 Some([152, 153, 154, 155])
# Var t0 (t0 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 64)) }) U32 Some([152, 153, 154, 155])
# Var t1 (t1 Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }) U32 Some([152, 153, 154, 155])
# Var t2 (t2 Number(USIZE, 64)) U32 Some([156, 157, 158, 159])
# Var t3 (t3 Number(USIZE, 0)) U32 Some([156, 157, 158, 159])
# 82b27 Instruction { source: "Save function parameter 's' registers [0, 1, 2, 3] to locals [152, 153, 154, 155].", opcode: Copy32, args: [Register(0x00), Register(0x98)], resolved: None }
81 00 98 
# 82b2a Instruction { source: "t1 <- s U32", opcode: Copy32, args: [Register(0x98), Register(0x98)], resolved: None }
81 98 98 
# 82b2d Instruction { source: "t2 <- 0n64/0x00000040u32 ", opcode: LoadImm32, args: [Register(0x9c), Constant32(0x00000040=64)], resolved: None }
80 9c 40 00 00 00 
# 82b33 Instruction { source: "t0 <- t1 Add t2", opcode: Add32NoCarryIn, args: [Register(0x98), Register(0x9c), Register(0x98)], resolved: None }
a0 98 9c 98 
# 82b37 Instruction { source: "t3 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x9c), Constant32(0x00000000=0)], resolved: None }
80 9c 00 00 00 00 
# 82b3d Instruction { source: "mem[t0] <- t3 U32", opcode: Store32_1, args: [Register(0x9c), Register(0x98)], resolved: None }
92 9c 98 
# 82b40 Instruction { source: "mem[t0] <- t3 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 82b41 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82b43 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :stack_pop
# Ret Some(U32)
# Arg0=s
# Var s (Arg0 s Ptr(Struct("Stack"))) U32 Some([160, 161, 162, 163])
# Var t0 (t0 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 64)) }) U32 Some([164, 165, 166, 167])
# Var t1 (t1 Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }) U32 Some([160, 161, 162, 163])
# Var t10 (t10 Index("values", PtrFieldDeref("s", "first_free"))) U32 Some([160, 161, 162, 163])
# Var t11 (t11 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Number(USIZE))), new_type: Number(USIZE), value: Ident("values") }, Arithmetic(Multiply, PtrFieldDeref("s", "first_free"), Number(USIZE, 4))) }) U32 Some([160, 161, 162, 163])
# Var t12 (t12 Cast { old_type: Some(Ptr(Number(USIZE))), new_type: Number(USIZE), value: Ident("values") }) U32 Some([164, 165, 166, 167])
# Var t13 (t13 Arithmetic(Multiply, PtrFieldDeref("s", "first_free"), Number(USIZE, 4))) U32 Some([160, 161, 162, 163])
# Var t14 (t14 PtrFieldDeref("s", "first_free")) U32 Some([160, 161, 162, 163])
# Var t15 (t15 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 64)) }) U32 Some([160, 161, 162, 163])
# Var t16 (t16 Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }) U32 Some([160, 161, 162, 163])
# Var t17 (t17 Number(USIZE, 64)) U32 Some([168, 169, 170, 171])
# Var t18 (t18 Number(USIZE, 4)) U32 Some([168, 169, 170, 171])
# Var t2 (t2 Number(USIZE, 64)) U32 Some([164, 165, 166, 167])
# Var t3 (t3 Arithmetic(Subtract, PtrFieldDeref("s", "first_free"), Number(U8, 1))) U32 Some([168, 169, 170, 171])
# Var t4 (t4 PtrFieldDeref("s", "first_free")) U32 Some([168, 169, 170, 171])
# Var t5 (t5 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 64)) }) U32 Some([168, 169, 170, 171])
# Var t6 (t6 Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }) U32 Some([160, 161, 162, 163])
# Var t7 (t7 Number(USIZE, 64)) U32 Some([168, 169, 170, 171])
# Var t8 (t8 Number(USIZE, 1)) U32 Some([172, 173, 174, 175])
# Var t9 (t9 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Array(Number(USIZE), 16)), value: Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") } }) U32 Some([160, 161, 162, 163])
# Var values (Local values Ptr(Number(USIZE)) U32) U32 Some([164, 165, 166, 167])
# 82b48 Instruction { source: "Save function parameter 's' registers [0, 1, 2, 3] to locals [160, 161, 162, 163].", opcode: Copy32, args: [Register(0x00), Register(0xa0)], resolved: None }
81 00 a0 
# 82b4b Instruction { source: "t1 <- s U32", opcode: Copy32, args: [Register(0xa0), Register(0xa0)], resolved: None }
81 a0 a0 
# 82b4e Instruction { source: "t2 <- 0n64/0x00000040u32 ", opcode: LoadImm32, args: [Register(0xa4), Constant32(0x00000040=64)], resolved: None }
80 a4 40 00 00 00 
# 82b54 Instruction { source: "t0 <- t1 Add t2", opcode: Add32NoCarryIn, args: [Register(0xa0), Register(0xa4), Register(0xa4)], resolved: None }
a0 a0 a4 a4 
# 82b58 Instruction { source: "t6 <- s U32", opcode: Copy32, args: [Register(0xa0), Register(0xa0)], resolved: None }
81 a0 a0 
# 82b5b Instruction { source: "t7 <- 0n64/0x00000040u32 ", opcode: LoadImm32, args: [Register(0xa8), Constant32(0x00000040=64)], resolved: None }
80 a8 40 00 00 00 
# 82b61 Instruction { source: "t5 <- t6 Add t7", opcode: Add32NoCarryIn, args: [Register(0xa0), Register(0xa8), Register(0xa8)], resolved: None }
a0 a0 a8 a8 
# 82b65 Instruction { source: "t4 <- mem[t5] U32", opcode: Load32, args: [Register(0xa8), Register(0xa8)], resolved: None }
90 a8 a8 
# 82b68 Instruction { source: "t8 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0xac), Constant32(0x00000001=1)], resolved: None }
80 ac 01 00 00 00 
# 82b6e Instruction { source: "t3 <- t4 Subtract t8", opcode: Copy32, args: [Register(0xac), Register(0x00)], resolved: None }
81 ac 00 
# 82b71 Instruction { source: "t3 <- t4 Subtract t8", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 82b73 Instruction { source: "t3 <- t4 Subtract t8", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 82b75 Instruction { source: "t3 <- t4 Subtract t8", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 82b77 Instruction { source: "t3 <- t4 Subtract t8", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 82b79 Instruction { source: "t3 <- t4 Subtract t8", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 82b7f Instruction { source: "t3 <- t4 Subtract t8", opcode: Add32NoCarryIn, args: [Register(0xa8), Register(0x00), Register(0xa8)], resolved: None }
a0 a8 00 a8 
# 82b83 Instruction { source: "mem[t0] <- t3 U32", opcode: Store32_1, args: [Register(0xa8), Register(0xa4)], resolved: None }
92 a8 a4 
# 82b86 Instruction { source: "mem[t0] <- t3 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 82b87 Instruction { source: "t9 <- s U32", opcode: Copy32, args: [Register(0xa0), Register(0xa0)], resolved: None }
81 a0 a0 
# 82b8a Instruction { source: "values <- t9 U32", opcode: Copy32, args: [Register(0xa0), Register(0xa4)], resolved: None }
81 a0 a4 
# 82b8d Instruction { source: "t12 <- values U32", opcode: Copy32, args: [Register(0xa4), Register(0xa4)], resolved: None }
81 a4 a4 
# 82b90 Instruction { source: "t16 <- s U32", opcode: Copy32, args: [Register(0xa0), Register(0xa0)], resolved: None }
81 a0 a0 
# 82b93 Instruction { source: "t17 <- 0n64/0x00000040u32 ", opcode: LoadImm32, args: [Register(0xa8), Constant32(0x00000040=64)], resolved: None }
80 a8 40 00 00 00 
# 82b99 Instruction { source: "t15 <- t16 Add t17", opcode: Add32NoCarryIn, args: [Register(0xa0), Register(0xa8), Register(0xa0)], resolved: None }
a0 a0 a8 a0 
# 82b9d Instruction { source: "t14 <- mem[t15] U32", opcode: Load32, args: [Register(0xa0), Register(0xa0)], resolved: None }
90 a0 a0 
# 82ba0 Instruction { source: "t18 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0xa8), Constant32(0x00000004=4)], resolved: None }
80 a8 04 00 00 00 
# 82ba6 Instruction { source: "t13 <- t14 Multiply t18", opcode: LoadImm32, args: [Register(0x00), Constant32(0x00000000=0)], resolved: None }
80 00 00 00 00 00 
# 82bac Instruction { source: "t13 <- t14 Multiply t18", opcode: Mul8_1, args: [Register(0xa0), Register(0xa8)], resolved: None }
20 a0 a8 
# 82baf Instruction { source: "t13 <- t14 Multiply t18", opcode: Mul8_2, args: [], resolved: None }
21 
# 82bb0 Instruction { source: "t13 <- t14 Multiply t18", opcode: Copy32, args: [Register(0x00), Register(0xa0)], resolved: None }
81 00 a0 
# 82bb3 Instruction { source: "t11 <- t12 Add t13", opcode: Add32NoCarryIn, args: [Register(0xa4), Register(0xa0), Register(0xa0)], resolved: None }
a0 a4 a0 a0 
# 82bb7 Instruction { source: "t10 <- mem[t11] U32", opcode: Load32, args: [Register(0xa0), Register(0xa0)], resolved: None }
90 a0 a0 
# 82bba Instruction { source: "return Some(t10)", opcode: Copy32, args: [Register(0xa0), Register(0x00)], resolved: None }
81 a0 00 
# 82bbd Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82bbf Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :stack_push
# Ret None
# Arg0=s
# Arg1=n
# Var n (Arg1 n Number(USIZE)) U32 Some([176, 177, 178, 179])
# Var s (Arg0 s Ptr(Struct("Stack"))) U32 Some([180, 181, 182, 183])
# Var t0 (t0 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Array(Number(USIZE), 16)), value: Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") } }) U32 Some([180, 181, 182, 183])
# Var t1 (t1 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Number(USIZE))), new_type: Number(USIZE), value: Ident("values") }, Arithmetic(Multiply, PtrFieldDeref("s", "first_free"), Number(USIZE, 4))) }) U32 Some([184, 185, 186, 187])
# Var t10 (t10 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 64)) }) U32 Some([176, 177, 178, 179])
# Var t11 (t11 Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }) U32 Some([176, 177, 178, 179])
# Var t12 (t12 Number(USIZE, 64)) U32 Some([184, 185, 186, 187])
# Var t13 (t13 Arithmetic(Add, PtrFieldDeref("s", "first_free"), Number(U8, 1))) U32 Some([180, 181, 182, 183])
# Var t14 (t14 PtrFieldDeref("s", "first_free")) U32 Some([180, 181, 182, 183])
# Var t15 (t15 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 64)) }) U32 Some([180, 181, 182, 183])
# Var t16 (t16 Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }) U32 Some([180, 181, 182, 183])
# Var t17 (t17 Number(USIZE, 64)) U32 Some([184, 185, 186, 187])
# Var t18 (t18 Number(USIZE, 1)) U32 Some([184, 185, 186, 187])
# Var t2 (t2 Cast { old_type: Some(Ptr(Number(USIZE))), new_type: Number(USIZE), value: Ident("values") }) U32 Some([184, 185, 186, 187])
# Var t3 (t3 Arithmetic(Multiply, PtrFieldDeref("s", "first_free"), Number(USIZE, 4))) U32 Some([188, 189, 190, 191])
# Var t4 (t4 PtrFieldDeref("s", "first_free")) U32 Some([188, 189, 190, 191])
# Var t5 (t5 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 64)) }) U32 Some([188, 189, 190, 191])
# Var t6 (t6 Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }) U32 Some([180, 181, 182, 183])
# Var t7 (t7 Number(USIZE, 64)) U32 Some([188, 189, 190, 191])
# Var t8 (t8 Number(USIZE, 4)) U32 Some([192, 193, 194, 195])
# Var t9 (t9 Ident("n")) U32 Some([176, 177, 178, 179])
# Var values (Local values Ptr(Number(USIZE)) U32) U32 Some([184, 185, 186, 187])
# 82bc4 Instruction { source: "Save function parameter 's' registers [0, 1, 2, 3] to locals [180, 181, 182, 183].", opcode: Copy32, args: [Register(0x00), Register(0xb4)], resolved: None }
81 00 b4 
# 82bc7 Instruction { source: "Save function parameter 'n' registers [4, 5, 6, 7] to locals [176, 177, 178, 179].", opcode: Copy32, args: [Register(0x04), Register(0xb0)], resolved: None }
81 04 b0 
# 82bca Instruction { source: "t0 <- s U32", opcode: Copy32, args: [Register(0xb4), Register(0xb4)], resolved: None }
81 b4 b4 
# 82bcd Instruction { source: "values <- t0 U32", opcode: Copy32, args: [Register(0xb4), Register(0xb8)], resolved: None }
81 b4 b8 
# 82bd0 Instruction { source: "t2 <- values U32", opcode: Copy32, args: [Register(0xb8), Register(0xb8)], resolved: None }
81 b8 b8 
# 82bd3 Instruction { source: "t6 <- s U32", opcode: Copy32, args: [Register(0xb4), Register(0xb4)], resolved: None }
81 b4 b4 
# 82bd6 Instruction { source: "t7 <- 0n64/0x00000040u32 ", opcode: LoadImm32, args: [Register(0xbc), Constant32(0x00000040=64)], resolved: None }
80 bc 40 00 00 00 
# 82bdc Instruction { source: "t5 <- t6 Add t7", opcode: Add32NoCarryIn, args: [Register(0xb4), Register(0xbc), Register(0xbc)], resolved: None }
a0 b4 bc bc 
# 82be0 Instruction { source: "t4 <- mem[t5] U32", opcode: Load32, args: [Register(0xbc), Register(0xbc)], resolved: None }
90 bc bc 
# 82be3 Instruction { source: "t8 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0xc0), Constant32(0x00000004=4)], resolved: None }
80 c0 04 00 00 00 
# 82be9 Instruction { source: "t3 <- t4 Multiply t8", opcode: LoadImm32, args: [Register(0x00), Constant32(0x00000000=0)], resolved: None }
80 00 00 00 00 00 
# 82bef Instruction { source: "t3 <- t4 Multiply t8", opcode: Mul8_1, args: [Register(0xbc), Register(0xc0)], resolved: None }
20 bc c0 
# 82bf2 Instruction { source: "t3 <- t4 Multiply t8", opcode: Mul8_2, args: [], resolved: None }
21 
# 82bf3 Instruction { source: "t3 <- t4 Multiply t8", opcode: Copy32, args: [Register(0x00), Register(0xbc)], resolved: None }
81 00 bc 
# 82bf6 Instruction { source: "t1 <- t2 Add t3", opcode: Add32NoCarryIn, args: [Register(0xb8), Register(0xbc), Register(0xb8)], resolved: None }
a0 b8 bc b8 
# 82bfa Instruction { source: "t9 <- n U32", opcode: Copy32, args: [Register(0xb0), Register(0xb0)], resolved: None }
81 b0 b0 
# 82bfd Instruction { source: "mem[t1] <- t9 U32", opcode: Store32_1, args: [Register(0xb0), Register(0xb8)], resolved: None }
92 b0 b8 
# 82c00 Instruction { source: "mem[t1] <- t9 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 82c01 Instruction { source: "t11 <- s U32", opcode: Copy32, args: [Register(0xb4), Register(0xb0)], resolved: None }
81 b4 b0 
# 82c04 Instruction { source: "t12 <- 0n64/0x00000040u32 ", opcode: LoadImm32, args: [Register(0xb8), Constant32(0x00000040=64)], resolved: None }
80 b8 40 00 00 00 
# 82c0a Instruction { source: "t10 <- t11 Add t12", opcode: Add32NoCarryIn, args: [Register(0xb0), Register(0xb8), Register(0xb0)], resolved: None }
a0 b0 b8 b0 
# 82c0e Instruction { source: "t16 <- s U32", opcode: Copy32, args: [Register(0xb4), Register(0xb4)], resolved: None }
81 b4 b4 
# 82c11 Instruction { source: "t17 <- 0n64/0x00000040u32 ", opcode: LoadImm32, args: [Register(0xb8), Constant32(0x00000040=64)], resolved: None }
80 b8 40 00 00 00 
# 82c17 Instruction { source: "t15 <- t16 Add t17", opcode: Add32NoCarryIn, args: [Register(0xb4), Register(0xb8), Register(0xb4)], resolved: None }
a0 b4 b8 b4 
# 82c1b Instruction { source: "t14 <- mem[t15] U32", opcode: Load32, args: [Register(0xb4), Register(0xb4)], resolved: None }
90 b4 b4 
# 82c1e Instruction { source: "t18 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0xb8), Constant32(0x00000001=1)], resolved: None }
80 b8 01 00 00 00 
# 82c24 Instruction { source: "t13 <- t14 Add t18", opcode: Add32NoCarryIn, args: [Register(0xb4), Register(0xb8), Register(0xb4)], resolved: None }
a0 b4 b8 b4 
# 82c28 Instruction { source: "mem[t10] <- t13 U32", opcode: Store32_1, args: [Register(0xb4), Register(0xb0)], resolved: None }
92 b4 b0 
# 82c2b Instruction { source: "mem[t10] <- t13 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 82c2c Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82c2e Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :test_add_U64
# Ret Some(U32)
# Arg0=a
# Arg1=b
# Var a (Arg0 a Ptr(Struct("U64"))) U32 Some([196, 197, 198, 199])
# Var b (Arg1 b Ptr(Struct("U64"))) U32 Some([200, 201, 202, 203])
# Var c (Local c Struct("U64") Static(524544)) Static(524544) None
# Var t0 (t0 Call(Call { function: "add_U64", parameters: [Ident("a"), Ident("b"), AddressOf(Ident("c"))] })) U8 Some([204])
# Var t1 (t1 Ident("a")) U32 Some([196, 197, 198, 199])
# Var t2 (t2 Ident("b")) U32 Some([200, 201, 202, 203])
# Var t3 (t3 AddressOf(Ident("c"))) U32 Some([208, 209, 210, 211])
# Var t4 (static "c") U32 Some([208, 209, 210, 211])
# Var t5 (t5 AddressOf(Ident("c"))) U32 Some([196, 197, 198, 199])
# Var t6 (static "c") U32 Some([196, 197, 198, 199])
# 82c33 Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [196, 197, 198, 199].", opcode: Copy32, args: [Register(0x00), Register(0xc4)], resolved: None }
81 00 c4 
# 82c36 Instruction { source: "Save function parameter 'b' registers [4, 5, 6, 7] to locals [200, 201, 202, 203].", opcode: Copy32, args: [Register(0x04), Register(0xc8)], resolved: None }
81 04 c8 
# 82c39 Instruction { source: "t1 <- a U32", opcode: Copy32, args: [Register(0xc4), Register(0xc4)], resolved: None }
81 c4 c4 
# 82c3c Instruction { source: "t2 <- b U32", opcode: Copy32, args: [Register(0xc8), Register(0xc8)], resolved: None }
81 c8 c8 
# 82c3f Instruction { source: "t4 <- 0n524544/0x00080100u32 ", opcode: LoadImm32, args: [Register(0xd0), Constant32(0x00080100=524544)], resolved: None }
80 d0 00 01 08 00 
# 82c45 Instruction { source: "t3 <- t4 U32", opcode: Copy32, args: [Register(0xd0), Register(0xd0)], resolved: None }
81 d0 d0 
# 82c48 Instruction { source: "Arg0[a]=t1 None <= call add_U64(t1,t2,t3,)", opcode: Copy32, args: [Register(0xc4), Register(0x00)], resolved: None }
81 c4 00 
# 82c4b Instruction { source: "Arg1[b]=t2 None <= call add_U64(t1,t2,t3,)", opcode: Copy32, args: [Register(0xc8), Register(0x04)], resolved: None }
81 c8 04 
# 82c4e Instruction { source: "Arg2[c]=t3 None <= call add_U64(t1,t2,t3,)", opcode: Copy32, args: [Register(0xd0), Register(0x08)], resolved: None }
81 d0 08 
# Registers used by this function: {196, 197, 198, 199, 200, 201, 202, 203, 204, 208, 209, 210, 211}
# Registers used by callee tree: {80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107}
# Registers to save: []
# 82c51 Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82c57 Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 61 2c 08 00 
# 82c5d Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: JmpImm, args: [Label24(:add_U64)], resolved: None }
40 80 1c 08 
# 82c61 Instruction { source: "PseudoCall(Label24(:add_U64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82c67 Instruction { source: "t6 <- 0n524544/0x00080100u32 ", opcode: LoadImm32, args: [Register(0xc4), Constant32(0x00080100=524544)], resolved: None }
80 c4 00 01 08 00 
# 82c6d Instruction { source: "t5 <- t6 U32", opcode: Copy32, args: [Register(0xc4), Register(0xc4)], resolved: None }
81 c4 c4 
# 82c70 Instruction { source: "return Some(t5)", opcode: Copy32, args: [Register(0xc4), Register(0x00)], resolved: None }
81 c4 00 
# 82c73 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82c75 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :test_echoline
# Ret Some(U8)
# Var __frame_pointer (__frame_pointer) U32 Some([12, 13, 14, 15])
# Var buf (Local buf Array(Number(U8), 20) FrameOffset(0)) FrameOffset(0) None
# Var t0 (Stack size negated) U32 Some([212, 213, 214, 215])
# Var t1 (t1 Call(Call { function: "readline", parameters: [AddressOf(Index("buf", Number(U8, 0)))] })) U8 Some([216])
# Var t10 (t10 Ident("__frame_pointer")) U32 Some([220, 221, 222, 223])
# Var t11 (t11 Cast { old_type: Some(Number(U8)), new_type: Number(USIZE), value: Number(U8, 0) }) U32 Some([212, 213, 214, 215])
# Var t12 (t12 Number(U8, 0)) U8 Some([224])
# Var t13 (t13 Number(U8, 0)) U8 Some([224])
# Var t14 (Stack size) U32 Some([228, 229, 230, 231])
# Var t2 (t2 AddressOf(Index("buf", Number(U8, 0)))) U32 Some([212, 213, 214, 215])
# Var t3 (t3 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Ident("__frame_pointer"), Cast { old_type: Some(Number(U8)), new_type: Number(USIZE), value: Number(U8, 0) }) }) U32 Some([212, 213, 214, 215])
# Var t4 (t4 Ident("__frame_pointer")) U32 Some([220, 221, 222, 223])
# Var t5 (t5 Cast { old_type: Some(Number(U8)), new_type: Number(USIZE), value: Number(U8, 0) }) U32 Some([212, 213, 214, 215])
# Var t6 (t6 Number(U8, 0)) U8 Some([224])
# Var t7 (t7 Call(Call { function: "println", parameters: [AddressOf(Index("buf", Number(U8, 0)))] })) U8 Some([216])
# Var t8 (t8 AddressOf(Index("buf", Number(U8, 0)))) U32 Some([212, 213, 214, 215])
# Var t9 (t9 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Ident("__frame_pointer"), Cast { old_type: Some(Number(U8)), new_type: Number(USIZE), value: Number(U8, 0) }) }) U32 Some([212, 213, 214, 215])
# 82c7a Instruction { source: "reserve 20 bytes of stack space for locals", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xffffffec=4294967276)], resolved: None }
a3 0c ec ff ff ff 
# 82c80 Instruction { source: "t0 <- 0xffffffecu32 ", opcode: LoadImm32, args: [Register(0xd4), Constant32(0xffffffec=4294967276)], resolved: None }
80 d4 ec ff ff ff 
# 82c86 Instruction { source: "__frame_pointer <- __frame_pointer Add t0", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0xd4), Register(0x0c)], resolved: None }
a0 0c d4 0c 
# 82c8a Instruction { source: "t4 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0xdc)], resolved: None }
81 0c dc 
# 82c8d Instruction { source: "t6 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xe0), Constant8(0x00=0)], resolved: None }
00 e0 00 
# 82c90 Instruction { source: "Zero-pad for t5 U32 <- t6 U8", opcode: LoadImm32, args: [Register(0xd4), Constant32(0x00000000=0)], resolved: None }
80 d4 00 00 00 00 
# 82c96 Instruction { source: "t5 U32 <- t6 U8", opcode: Copy8, args: [Register(0xe0), Register(0xd4)], resolved: None }
16 e0 d4 
# 82c99 Instruction { source: "t3 <- t4 Add t5", opcode: Add32NoCarryIn, args: [Register(0xdc), Register(0xd4), Register(0xd4)], resolved: None }
a0 dc d4 d4 
# 82c9d Instruction { source: "t2 <- t3 U32", opcode: Copy32, args: [Register(0xd4), Register(0xd4)], resolved: None }
81 d4 d4 
# 82ca0 Instruction { source: "Arg0[buf]=t2 None <= call readline(t2,)", opcode: Copy32, args: [Register(0xd4), Register(0x00)], resolved: None }
81 d4 00 
# Registers used by this function: {212, 213, 214, 215, 216, 220, 221, 222, 223, 224, 228, 229, 230, 231}
# Registers used by callee tree: {120, 121, 122, 123, 124, 125, 128, 129, 130, 131, 176, 177, 178}
# Registers to save: []
# 82ca3 Instruction { source: "PseudoCall(Label24(:readline))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82ca9 Instruction { source: "PseudoCall(Label24(:readline))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c b3 2c 08 00 
# 82caf Instruction { source: "PseudoCall(Label24(:readline))", opcode: JmpImm, args: [Label24(:readline)], resolved: None }
40 b3 29 08 
# 82cb3 Instruction { source: "PseudoCall(Label24(:readline))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82cb9 Instruction { source: "t10 <- __frame_pointer U32", opcode: Copy32, args: [Register(0x0c), Register(0xdc)], resolved: None }
81 0c dc 
# 82cbc Instruction { source: "t12 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xe0), Constant8(0x00=0)], resolved: None }
00 e0 00 
# 82cbf Instruction { source: "Zero-pad for t11 U32 <- t12 U8", opcode: LoadImm32, args: [Register(0xd4), Constant32(0x00000000=0)], resolved: None }
80 d4 00 00 00 00 
# 82cc5 Instruction { source: "t11 U32 <- t12 U8", opcode: Copy8, args: [Register(0xe0), Register(0xd4)], resolved: None }
16 e0 d4 
# 82cc8 Instruction { source: "t9 <- t10 Add t11", opcode: Add32NoCarryIn, args: [Register(0xdc), Register(0xd4), Register(0xd4)], resolved: None }
a0 dc d4 d4 
# 82ccc Instruction { source: "t8 <- t9 U32", opcode: Copy32, args: [Register(0xd4), Register(0xd4)], resolved: None }
81 d4 d4 
# 82ccf Instruction { source: "Arg0[buf]=t8 None <= call println(t8,)", opcode: Copy32, args: [Register(0xd4), Register(0x00)], resolved: None }
81 d4 00 
# Registers used by this function: {212, 213, 214, 215, 216, 220, 221, 222, 223, 224, 228, 229, 230, 231}
# Registers used by callee tree: {108, 109, 110, 111, 112, 113, 116, 117, 118, 119}
# Registers to save: []
# 82cd2 Instruction { source: "PseudoCall(Label24(:println))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82cd8 Instruction { source: "PseudoCall(Label24(:println))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c e2 2c 08 00 
# 82cde Instruction { source: "PseudoCall(Label24(:println))", opcode: JmpImm, args: [Label24(:println)], resolved: None }
40 7a 29 08 
# 82ce2 Instruction { source: "PseudoCall(Label24(:println))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82ce8 Instruction { source: "t13 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0xe0), Constant8(0x00=0)], resolved: None }
00 e0 00 
# 82ceb Instruction { source: "t14 <- 0n20/0x00000014u32 ", opcode: LoadImm32, args: [Register(0xe4), Constant32(0x00000014=20)], resolved: None }
80 e4 14 00 00 00 
# 82cf1 Instruction { source: "__frame_pointer <- __frame_pointer Add t14", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0xe4), Register(0x0c)], resolved: None }
a0 0c e4 0c 
# 82cf5 Instruction { source: "return Some(t13)", opcode: Copy8, args: [Register(0xe0), Register(0x00)], resolved: None }
16 e0 00 
# 82cf8 Instruction { source: "Dealloc 20 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000014=20)], resolved: None }
a3 0c 14 00 00 00 
# 82cfe Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82d00 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :test_mul32_64
# Ret Some(U32)
# Arg0=a
# Arg1=b
# Var a (Arg0 a Number(USIZE)) U32 Some([232, 233, 234, 235])
# Var b (Arg1 b Number(USIZE)) U32 Some([236, 237, 238, 239])
# Var c (Local c Struct("U64") Static(524552)) Static(524552) None
# Var t0 (t0 Call(Call { function: "mul32_64", parameters: [Ident("a"), Ident("b"), AddressOf(Ident("c"))] })) U8 Some([240])
# Var t1 (t1 Ident("a")) U32 Some([232, 233, 234, 235])
# Var t2 (t2 Ident("b")) U32 Some([236, 237, 238, 239])
# Var t3 (t3 AddressOf(Ident("c"))) U32 Some([244, 245, 246, 247])
# Var t4 (static "c") U32 Some([244, 245, 246, 247])
# Var t5 (t5 AddressOf(Ident("c"))) U32 Some([232, 233, 234, 235])
# Var t6 (static "c") U32 Some([232, 233, 234, 235])
# 82d05 Instruction { source: "Save function parameter 'a' registers [0, 1, 2, 3] to locals [232, 233, 234, 235].", opcode: Copy32, args: [Register(0x00), Register(0xe8)], resolved: None }
81 00 e8 
# 82d08 Instruction { source: "Save function parameter 'b' registers [4, 5, 6, 7] to locals [236, 237, 238, 239].", opcode: Copy32, args: [Register(0x04), Register(0xec)], resolved: None }
81 04 ec 
# 82d0b Instruction { source: "t1 <- a U32", opcode: Copy32, args: [Register(0xe8), Register(0xe8)], resolved: None }
81 e8 e8 
# 82d0e Instruction { source: "t2 <- b U32", opcode: Copy32, args: [Register(0xec), Register(0xec)], resolved: None }
81 ec ec 
# 82d11 Instruction { source: "t4 <- 0n524552/0x00080108u32 ", opcode: LoadImm32, args: [Register(0xf4), Constant32(0x00080108=524552)], resolved: None }
80 f4 08 01 08 00 
# 82d17 Instruction { source: "t3 <- t4 U32", opcode: Copy32, args: [Register(0xf4), Register(0xf4)], resolved: None }
81 f4 f4 
# 82d1a Instruction { source: "Arg0[a]=t1 None <= call mul32_64(t1,t2,t3,)", opcode: Copy32, args: [Register(0xe8), Register(0x00)], resolved: None }
81 e8 00 
# 82d1d Instruction { source: "Arg1[b]=t2 None <= call mul32_64(t1,t2,t3,)", opcode: Copy32, args: [Register(0xec), Register(0x04)], resolved: None }
81 ec 04 
# 82d20 Instruction { source: "Arg2[c]=t3 None <= call mul32_64(t1,t2,t3,)", opcode: Copy32, args: [Register(0xf4), Register(0x08)], resolved: None }
81 f4 08 
# Registers used by this function: {232, 233, 234, 235, 236, 237, 238, 239, 240, 244, 245, 246, 247}
# Registers used by callee tree: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 52, 53, 54, 55, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 220, 221, 222, 223, 224, 225, 252, 253, 254, 255}
# Registers to save: []
# 82d23 Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 82d29 Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 33 2d 08 00 
# 82d2f Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: JmpImm, args: [Label24(:mul32_64)], resolved: None }
40 ee 24 08 
# 82d33 Instruction { source: "PseudoCall(Label24(:mul32_64))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 82d39 Instruction { source: "t6 <- 0n524552/0x00080108u32 ", opcode: LoadImm32, args: [Register(0xe8), Constant32(0x00080108=524552)], resolved: None }
80 e8 08 01 08 00 
# 82d3f Instruction { source: "t5 <- t6 U32", opcode: Copy32, args: [Register(0xe8), Register(0xe8)], resolved: None }
81 e8 e8 
# 82d42 Instruction { source: "return Some(t5)", opcode: Copy32, args: [Register(0xe8), Register(0x00)], resolved: None }
81 e8 00 
# 82d45 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 82d47 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
