v2.0 raw
# ImageBaseAddress=0x00081400
# entry
# 81400 Instruction { source: "Initialzing flags and internal regs.", opcode: Init, args: [], resolved: None }
0f 
# 81401 Instruction { source: "Initialzing stack register to 0x000ffffc.", opcode: LoadImm32, args: [Register(0x0c), Constant32(0x000ffffc=1048572)], resolved: None }
80 0c fc ff 0f 00 
# 81407 Instruction { source: "PseudoCall(Label24(:main))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8140d Instruction { source: "PseudoCall(Label24(:main))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 17 14 08 00 
# 81413 Instruction { source: "PseudoCall(Label24(:main))", opcode: JmpImm, args: [Label24(:main)], resolved: None }
40 51 14 08 
# 81417 Instruction { source: "PseudoCall(Label24(:main))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8141d Instruction { source: "Halting after return from entry function.", opcode: Halt, args: [Constant32(0x00000000=0)], resolved: None }
ff 00 00 00 00 
# :getchar
# Ret Some(U8)
# Var t0 (t0 Arithmetic(And, Ident("tty"), Number(U8, 128))) U8 Some([16])
# Var t2 (t2 Number(U8, 128)) U8 Some([16])
# Var t3 (t3 Number(U8, 0)) U8 Some([17])
# Var t4 (t4 Arithmetic(And, Ident("tty"), Number(U8, 127))) U8 Some([16])
# Var t6 (t6 Number(U8, 127)) U8 Some([16])
# Var tty (Local tty Number(U8) U8) U8 Some([18])
# 81422 Instruction { source: "tty <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x12), Constant8(0x00=0)], resolved: None }
00 12 00 
# getchar_while_predicate_0
# 81425 Instruction { source: "t2 <- 0n128/0x80u8 ", opcode: LoadImm8, args: [Register(0x10), Constant8(0x80=128)], resolved: None }
00 10 80 
# 81428 Instruction { source: "t0 <- tty BitwiseAnd t2", opcode: And8, args: [Register(0x12), Register(0x10), Register(0x10)], resolved: None }
33 12 10 10 
# 8142c Instruction { source: "t3 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x11), Constant8(0x00=0)], resolved: None }
00 11 00 
# 8142f Instruction { source: "if t0 == t3 then 'getchar_while_body_1' else 'getchar_while_end_2'", opcode: Cmp8, args: [Register(0x10), Register(0x11)], resolved: None }
25 10 11 
# 81432 Instruction { source: "if t0 == t3 then 'getchar_while_body_1' else 'getchar_while_end_2'", opcode: JzImm, args: [Label24(getchar_while_body_1)], resolved: None }
42 3a 14 08 
# 81436 Instruction { source: "if t0 == t3 then 'getchar_while_body_1' else 'getchar_while_end_2'", opcode: JmpImm, args: [Label24(getchar_while_end_2)], resolved: None }
40 40 14 08 
# getchar_while_body_1
# 8143a Instruction { source: "tty <- ttyin", opcode: TtyIn, args: [Register(0x12)], resolved: None }
12 12 
# 8143c Instruction { source: "goto getchar_while_predicate_0", opcode: JmpImm, args: [Label24(getchar_while_predicate_0)], resolved: None }
40 25 14 08 
# getchar_while_end_2
# 81440 Instruction { source: "t6 <- 0n127/0x7fu8 ", opcode: LoadImm8, args: [Register(0x10), Constant8(0x7f=127)], resolved: None }
00 10 7f 
# 81443 Instruction { source: "t4 <- tty BitwiseAnd t6", opcode: And8, args: [Register(0x12), Register(0x10), Register(0x10)], resolved: None }
33 12 10 10 
# 81447 Instruction { source: "return Some(t4)", opcode: Copy8, args: [Register(0x10), Register(0x00)], resolved: None }
16 10 00 
# 8144a Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 8144c Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :main
# Ret Some(U8)
# Var __frame_pointer (__frame_pointer) U32 Some([12, 13, 14, 15])
# Var a (Local a Number(U8) U8) U8 Some([19])
# Var b (Local b Number(U8) U8) U8 Some([20])
# Var ch (Local ch Number(U8) U8) U8 Some([21])
# Var diff (Local diff Number(U8) U8) U8 Some([21])
# Var have_num (Local have_num Number(U8) U8) U8 Some([22])
# Var num (Local num Number(U8) U8) U8 Some([23])
# Var product (Local product Number(U8) U8) U8 Some([21])
# Var quotient (Local quotient Number(U8) U8) U8 Some([21])
# Var s (Local s Struct("Stack") FrameOffset(0)) FrameOffset(0) None
# Var stack_count (Local stack_count Number(U8) U8) U8 Some([24])
# Var stack_count_usize (Local stack_count_usize Number(USIZE) U32) U32 Some([28, 29, 30, 31])
# Var stack_needed (Local stack_needed Number(U8) U8) U8 Some([24])
# Var sum (Local sum Number(U8) U8) U8 Some([21])
# Var t0 (t0 Call(Call { function: "stack_init", parameters: [AddressOf(Ident("s"))] })) U8 Some([32])
# Var t101 (t101 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([36, 37, 38, 39])
# Var t103 (t103 Number(USIZE, 0)) U32 Some([36, 37, 38, 39])
# Var t106 (t106 Number(U8, 99)) U8 Some([24])
# Var t107 (t107 Call(Call { function: "stack_init", parameters: [AddressOf(Ident("s"))] })) U8 Some([32])
# Var t109 (t109 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([36, 37, 38, 39])
# Var t11 (t11 Number(U8, 43)) U8 Some([24])
# Var t111 (t111 Number(USIZE, 0)) U32 Some([36, 37, 38, 39])
# Var t113 (t113 Number(U8, 57)) U8 Some([24])
# Var t115 (t115 Number(U8, 48)) U8 Some([24])
# Var t117 (t117 Number(U8, 10)) U8 Some([24])
# Var t119 (t119 Arithmetic(Subtract, Ident("ch"), Number(U8, 48))) U8 Some([21])
# Var t121 (t121 Number(U8, 48)) U8 Some([24])
# Var t13 (t13 Number(U8, 45)) U8 Some([24])
# Var t15 (t15 Number(U8, 42)) U8 Some([24])
# Var t17 (t17 Number(U8, 47)) U8 Some([24])
# Var t19 (t19 Number(U8, 0)) U8 Some([40])
# Var t2 (t2 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([44, 45, 46, 47])
# Var t21 (t21 Number(U8, 0)) U8 Some([40])
# Var t22 (t22 Call(Call { function: "stack_push", parameters: [AddressOf(Ident("s")), Ident("num")] })) U8 Some([32])
# Var t24 (t24 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([48, 49, 50, 51])
# Var t26 (t26 Number(USIZE, 0)) U32 Some([48, 49, 50, 51])
# Var t29 (t29 Number(U8, 0)) U8 Some([40])
# Var t31 (t31 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([44, 45, 46, 47])
# Var t33 (t33 Number(USIZE, 0)) U32 Some([44, 45, 46, 47])
# Var t35 (t35 Number(U8, 1)) U8 Some([40])
# Var t37 (t37 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([52, 53, 54, 55])
# Var t39 (t39 Number(USIZE, 0)) U32 Some([52, 53, 54, 55])
# Var t4 (t4 Number(USIZE, 0)) U32 Some([44, 45, 46, 47])
# Var t41 (t41 Number(U8, 43)) U8 Some([24])
# Var t44 (t44 Call(Call { function: "print_dec", parameters: [Ident("sum")] })) U8 Some([32])
# Var t46 (t46 Number(U8, 10)) U8 Some([24])
# Var t47 (t47 Call(Call { function: "stack_push", parameters: [AddressOf(Ident("s")), Ident("sum")] })) U8 Some([32])
# Var t49 (t49 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([28, 29, 30, 31])
# Var t5 (t5 Number(U8, 0)) U8 Some([21])
# Var t51 (t51 Number(USIZE, 0)) U32 Some([28, 29, 30, 31])
# Var t54 (t54 Number(U8, 45)) U8 Some([24])
# Var t57 (t57 Call(Call { function: "print_dec", parameters: [Ident("diff")] })) U8 Some([32])
# Var t59 (t59 Number(U8, 10)) U8 Some([24])
# Var t6 (t6 Number(U8, 0)) U8 Some([24])
# Var t60 (t60 Call(Call { function: "stack_push", parameters: [AddressOf(Ident("s")), Ident("diff")] })) U8 Some([32])
# Var t62 (t62 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([28, 29, 30, 31])
# Var t64 (t64 Number(USIZE, 0)) U32 Some([28, 29, 30, 31])
# Var t67 (t67 Number(U8, 42)) U8 Some([24])
# Var t7 (t7 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 4)) }) U32 Some([28, 29, 30, 31])
# Var t70 (t70 Call(Call { function: "print_dec", parameters: [Ident("product")] })) U8 Some([32])
# Var t72 (t72 Number(U8, 10)) U8 Some([24])
# Var t73 (t73 Call(Call { function: "stack_push", parameters: [AddressOf(Ident("s")), Ident("product")] })) U8 Some([32])
# Var t75 (t75 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([28, 29, 30, 31])
# Var t77 (t77 Number(USIZE, 0)) U32 Some([28, 29, 30, 31])
# Var t80 (t80 Number(U8, 47)) U8 Some([24])
# Var t83 (t83 Call(Call { function: "print_dec", parameters: [Ident("quotient")] })) U8 Some([32])
# Var t85 (t85 Number(U8, 10)) U8 Some([24])
# Var t86 (t86 Call(Call { function: "stack_push", parameters: [AddressOf(Ident("s")), Ident("quotient")] })) U8 Some([32])
# Var t88 (t88 Arithmetic(Add, Ident("__frame_pointer"), Number(USIZE, 0))) U32 Some([28, 29, 30, 31])
# Var t9 (t9 Number(USIZE, 4)) U32 Some([28, 29, 30, 31])
# Var t90 (t90 Number(USIZE, 0)) U32 Some([28, 29, 30, 31])
# Var t93 (t93 Number(U8, 113)) U8 Some([24])
# Var t94 (t94 Number(U8, 0)) U8 Some([32])
# Var t96 (t96 Number(U8, 10)) U8 Some([24])
# Var t98 (t98 Number(U8, 0)) U8 Some([21])
# Var t99 (t99 Call(Call { function: "stack_push", parameters: [AddressOf(Ident("s")), Ident("num")] })) U8 Some([32])
# 81451 Instruction { source: "reserve 104 bytes of stack space for locals", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xffffff98=4294967192)], resolved: None }
a3 0c 98 ff ff ff 
# 81457 Instruction { source: "t4 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x2c), Constant32(0x00000000=0)], resolved: None }
80 2c 00 00 00 00 
# 8145d Instruction { source: "t2 <- __frame_pointer Add t4", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x2c), Register(0x2c)], resolved: None }
a0 0c 2c 2c 
# 81461 Instruction { source: "Arg0[s]=t2 None <= call stack_init(t2,)", opcode: Copy32, args: [Register(0x2c), Register(0x00)], resolved: None }
81 2c 00 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55}
# Registers used by callee tree: {88, 89, 90, 91, 92, 93, 94, 95}
# Registers to save: []
# 81464 Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8146a Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 74 14 08 00 
# 81470 Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: JmpImm, args: [Label24(:stack_init)], resolved: None }
40 c2 19 08 
# 81474 Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8147a Instruction { source: "num <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x17), Constant8(0x00=0)], resolved: None }
00 17 00 
# 8147d Instruction { source: "a <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x13), Constant8(0x00=0)], resolved: None }
00 13 00 
# 81480 Instruction { source: "b <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x14), Constant8(0x00=0)], resolved: None }
00 14 00 
# 81483 Instruction { source: "have_num <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x16), Constant8(0x00=0)], resolved: None }
00 16 00 
# main_while_predicate_0
# 81486 Instruction { source: "t5 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x15), Constant8(0x00=0)], resolved: None }
00 15 00 
# 81489 Instruction { source: "t6 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x00=0)], resolved: None }
00 18 00 
# 8148c Instruction { source: "if t5 == t6 then 'main_while_body_1' else 'main_while_end_2'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 8148f Instruction { source: "if t5 == t6 then 'main_while_body_1' else 'main_while_end_2'", opcode: JzImm, args: [Label24(main_while_body_1)], resolved: None }
42 97 14 08 
# 81493 Instruction { source: "if t5 == t6 then 'main_while_body_1' else 'main_while_end_2'", opcode: JmpImm, args: [Label24(main_while_end_2)], resolved: None }
40 1d 18 08 
# main_while_body_1
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55}
# Registers used by callee tree: {16, 17, 18}
# Registers to save: []
# 81497 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8149d Instruction { source: "PseudoCall(Label24(:getchar))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c a7 14 08 00 
# 814a3 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: JmpImm, args: [Label24(:getchar)], resolved: None }
40 22 14 08 
# 814a7 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 814ad Instruction { source: "Some(ch) <= call getchar()", opcode: Copy8, args: [Register(0x00), Register(0x15)], resolved: None }
16 00 15 
# 814b0 Instruction { source: "t9 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x1c), Constant32(0x00000004=4)], resolved: None }
80 1c 04 00 00 00 
# 814b6 Instruction { source: "t7 <- __frame_pointer Add t9", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x1c), Register(0x1c)], resolved: None }
a0 0c 1c 1c 
# 814ba Instruction { source: "stack_count_usize <- mem[t7] U32", opcode: Load32, args: [Register(0x1c), Register(0x1c)], resolved: None }
90 1c 1c 
# 814bd Instruction { source: "stack_count <- stack_count_usize[0x00..0x01] U8", opcode: Copy8, args: [Register(0x1c), Register(0x18)], resolved: None }
16 1c 18 
# 814c0 Instruction { source: "t11 <- 0n43/0x2bu8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x2b=43)], resolved: None }
00 18 2b 
# 814c3 Instruction { source: "if ch == t11 then 'main_if_true_0_4' else 'main_if_else_0_5'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 814c6 Instruction { source: "if ch == t11 then 'main_if_true_0_4' else 'main_if_else_0_5'", opcode: JzImm, args: [Label24(main_if_true_0_4)], resolved: None }
42 ce 14 08 
# 814ca Instruction { source: "if ch == t11 then 'main_if_true_0_4' else 'main_if_else_0_5'", opcode: JmpImm, args: [Label24(main_if_else_0_5)], resolved: None }
40 d5 14 08 
# main_if_true_0_4
# 814ce Instruction { source: "stack_needed <- 0n2/0x02u8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x02=2)], resolved: None }
00 18 02 
# 814d1 Instruction { source: "goto main_if_end_3", opcode: JmpImm, args: [Label24(main_if_end_3)], resolved: None }
40 17 15 08 
# main_if_else_0_5
# 814d5 Instruction { source: "t13 <- 0n45/0x2du8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x2d=45)], resolved: None }
00 18 2d 
# 814d8 Instruction { source: "if ch == t13 then 'main_if_true_1_6' else 'main_if_else_1_7'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 814db Instruction { source: "if ch == t13 then 'main_if_true_1_6' else 'main_if_else_1_7'", opcode: JzImm, args: [Label24(main_if_true_1_6)], resolved: None }
42 e3 14 08 
# 814df Instruction { source: "if ch == t13 then 'main_if_true_1_6' else 'main_if_else_1_7'", opcode: JmpImm, args: [Label24(main_if_else_1_7)], resolved: None }
40 ea 14 08 
# main_if_true_1_6
# 814e3 Instruction { source: "stack_needed <- 0n2/0x02u8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x02=2)], resolved: None }
00 18 02 
# 814e6 Instruction { source: "goto main_if_end_3", opcode: JmpImm, args: [Label24(main_if_end_3)], resolved: None }
40 17 15 08 
# main_if_else_1_7
# 814ea Instruction { source: "t15 <- 0n42/0x2au8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x2a=42)], resolved: None }
00 18 2a 
# 814ed Instruction { source: "if ch == t15 then 'main_if_true_2_8' else 'main_if_else_2_9'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 814f0 Instruction { source: "if ch == t15 then 'main_if_true_2_8' else 'main_if_else_2_9'", opcode: JzImm, args: [Label24(main_if_true_2_8)], resolved: None }
42 f8 14 08 
# 814f4 Instruction { source: "if ch == t15 then 'main_if_true_2_8' else 'main_if_else_2_9'", opcode: JmpImm, args: [Label24(main_if_else_2_9)], resolved: None }
40 ff 14 08 
# main_if_true_2_8
# 814f8 Instruction { source: "stack_needed <- 0n2/0x02u8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x02=2)], resolved: None }
00 18 02 
# 814fb Instruction { source: "goto main_if_end_3", opcode: JmpImm, args: [Label24(main_if_end_3)], resolved: None }
40 17 15 08 
# main_if_else_2_9
# 814ff Instruction { source: "t17 <- 0n47/0x2fu8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x2f=47)], resolved: None }
00 18 2f 
# 81502 Instruction { source: "if ch == t17 then 'main_if_true_3_10' else 'main_if_else_3_11'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 81505 Instruction { source: "if ch == t17 then 'main_if_true_3_10' else 'main_if_else_3_11'", opcode: JzImm, args: [Label24(main_if_true_3_10)], resolved: None }
42 0d 15 08 
# 81509 Instruction { source: "if ch == t17 then 'main_if_true_3_10' else 'main_if_else_3_11'", opcode: JmpImm, args: [Label24(main_if_else_3_11)], resolved: None }
40 14 15 08 
# main_if_true_3_10
# 8150d Instruction { source: "stack_needed <- 0n2/0x02u8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x02=2)], resolved: None }
00 18 02 
# 81510 Instruction { source: "goto main_if_end_3", opcode: JmpImm, args: [Label24(main_if_end_3)], resolved: None }
40 17 15 08 
# main_if_else_3_11
# 81514 Instruction { source: "stack_needed <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x00=0)], resolved: None }
00 18 00 
# main_if_end_3
# 81517 Instruction { source: "t19 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x28), Constant8(0x00=0)], resolved: None }
00 28 00 
# 8151a Instruction { source: "if stack_needed > t19 then 'main_if_true_0_13' else 'main_if_else_0_14'", opcode: Cmp8, args: [Register(0x18), Register(0x28)], resolved: None }
25 18 28 
# 8151d Instruction { source: "if stack_needed > t19 then 'main_if_true_0_13' else 'main_if_else_0_14'", opcode: JcImm, args: [Label24(main_if_else_0_14)], resolved: None }
41 5f 15 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if stack_needed > t19 then 'main_if_true_0_13' else 'main_if_else_0_14'", opcode: JmpImm, args: [Label24(main_if_true_0_13)], resolved: None }
# main_if_true_0_13
# 81521 Instruction { source: "t21 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x28), Constant8(0x00=0)], resolved: None }
00 28 00 
# 81524 Instruction { source: "if have_num != t21 then 'main_if_true_0_16' else 'main_if_else_0_17'", opcode: Cmp8, args: [Register(0x16), Register(0x28)], resolved: None }
25 16 28 
# 81527 Instruction { source: "if have_num != t21 then 'main_if_true_0_16' else 'main_if_else_0_17'", opcode: JzImm, args: [Label24(main_if_else_0_17)], resolved: None }
42 5b 15 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if have_num != t21 then 'main_if_true_0_16' else 'main_if_else_0_17'", opcode: JmpImm, args: [Label24(main_if_true_0_16)], resolved: None }
# main_if_true_0_16
# 8152b Instruction { source: "t26 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x30), Constant32(0x00000000=0)], resolved: None }
80 30 00 00 00 00 
# 81531 Instruction { source: "t24 <- __frame_pointer Add t26", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x30), Register(0x30)], resolved: None }
a0 0c 30 30 
# 81535 Instruction { source: "Arg0[s]=t24 None <= call stack_push(t24,num,)", opcode: Copy32, args: [Register(0x30), Register(0x00)], resolved: None }
81 30 00 
# 81538 Instruction { source: "Arg1[n]=num None <= call stack_push(t24,num,)", opcode: Copy8, args: [Register(0x17), Register(0x04)], resolved: None }
16 17 04 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55}
# Registers used by callee tree: {116, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131}
# Registers to save: []
# 8153b Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81541 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 4b 15 08 00 
# 81547 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 37 1a 08 
# 8154b Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81551 Instruction { source: "num <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x17), Constant8(0x00=0)], resolved: None }
00 17 00 
# 81554 Instruction { source: "have_num <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x16), Constant8(0x00=0)], resolved: None }
00 16 00 
# 81557 Instruction { source: "goto main_if_end_15", opcode: JmpImm, args: [Label24(main_if_end_15)], resolved: None }
40 5b 15 08 
# main_if_else_0_17
# main_if_end_15
# 8155b Instruction { source: "goto main_if_end_12", opcode: JmpImm, args: [Label24(main_if_end_12)], resolved: None }
40 5f 15 08 
# main_if_else_0_14
# main_if_end_12
# 8155f Instruction { source: "t29 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x28), Constant8(0x00=0)], resolved: None }
00 28 00 
# 81562 Instruction { source: "if stack_needed > t29 then 'main_if_true_0_19' else 'main_if_else_0_20'", opcode: Cmp8, args: [Register(0x18), Register(0x28)], resolved: None }
25 18 28 
# 81565 Instruction { source: "if stack_needed > t29 then 'main_if_true_0_19' else 'main_if_else_0_20'", opcode: JcImm, args: [Label24(main_if_else_0_20)], resolved: None }
41 93 15 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if stack_needed > t29 then 'main_if_true_0_19' else 'main_if_else_0_20'", opcode: JmpImm, args: [Label24(main_if_true_0_19)], resolved: None }
# main_if_true_0_19
# 81569 Instruction { source: "t33 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x2c), Constant32(0x00000000=0)], resolved: None }
80 2c 00 00 00 00 
# 8156f Instruction { source: "t31 <- __frame_pointer Add t33", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x2c), Register(0x2c)], resolved: None }
a0 0c 2c 2c 
# 81573 Instruction { source: "Arg0[s]=t31 Some(a) <= call stack_pop(t31,)", opcode: Copy32, args: [Register(0x2c), Register(0x00)], resolved: None }
81 2c 00 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55}
# Registers used by callee tree: {96, 97, 98, 99, 100, 101, 102, 103, 104, 108, 109, 110, 111, 112, 113, 114, 115}
# Registers to save: []
# 81576 Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8157c Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 86 15 08 00 
# 81582 Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: JmpImm, args: [Label24(:stack_pop)], resolved: None }
40 e0 19 08 
# 81586 Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8158c Instruction { source: "Some(a) <= call stack_pop(t31,)", opcode: Copy8, args: [Register(0x00), Register(0x13)], resolved: None }
16 00 13 
# 8158f Instruction { source: "goto main_if_end_18", opcode: JmpImm, args: [Label24(main_if_end_18)], resolved: None }
40 93 15 08 
# main_if_else_0_20
# main_if_end_18
# 81593 Instruction { source: "t35 <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x28), Constant8(0x01=1)], resolved: None }
00 28 01 
# 81596 Instruction { source: "if stack_needed > t35 then 'main_if_true_0_22' else 'main_if_else_0_23'", opcode: Cmp8, args: [Register(0x18), Register(0x28)], resolved: None }
25 18 28 
# 81599 Instruction { source: "if stack_needed > t35 then 'main_if_true_0_22' else 'main_if_else_0_23'", opcode: JcImm, args: [Label24(main_if_else_0_23)], resolved: None }
41 c7 15 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if stack_needed > t35 then 'main_if_true_0_22' else 'main_if_else_0_23'", opcode: JmpImm, args: [Label24(main_if_true_0_22)], resolved: None }
# main_if_true_0_22
# 8159d Instruction { source: "t39 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x34), Constant32(0x00000000=0)], resolved: None }
80 34 00 00 00 00 
# 815a3 Instruction { source: "t37 <- __frame_pointer Add t39", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x34), Register(0x34)], resolved: None }
a0 0c 34 34 
# 815a7 Instruction { source: "Arg0[s]=t37 Some(b) <= call stack_pop(t37,)", opcode: Copy32, args: [Register(0x34), Register(0x00)], resolved: None }
81 34 00 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55}
# Registers used by callee tree: {96, 97, 98, 99, 100, 101, 102, 103, 104, 108, 109, 110, 111, 112, 113, 114, 115}
# Registers to save: []
# 815aa Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 815b0 Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c ba 15 08 00 
# 815b6 Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: JmpImm, args: [Label24(:stack_pop)], resolved: None }
40 e0 19 08 
# 815ba Instruction { source: "PseudoCall(Label24(:stack_pop))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 815c0 Instruction { source: "Some(b) <= call stack_pop(t37,)", opcode: Copy8, args: [Register(0x00), Register(0x14)], resolved: None }
16 00 14 
# 815c3 Instruction { source: "goto main_if_end_21", opcode: JmpImm, args: [Label24(main_if_end_21)], resolved: None }
40 c7 15 08 
# main_if_else_0_23
# main_if_end_21
# 815c7 Instruction { source: "t41 <- 0n43/0x2bu8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x2b=43)], resolved: None }
00 18 2b 
# 815ca Instruction { source: "if ch == t41 then 'main_if_true_0_25' else 'main_if_else_0_26'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 815cd Instruction { source: "if ch == t41 then 'main_if_true_0_25' else 'main_if_else_0_26'", opcode: JzImm, args: [Label24(main_if_true_0_25)], resolved: None }
42 d5 15 08 
# 815d1 Instruction { source: "if ch == t41 then 'main_if_true_0_25' else 'main_if_else_0_26'", opcode: JmpImm, args: [Label24(main_if_else_0_26)], resolved: None }
40 21 16 08 
# main_if_true_0_25
# 815d5 Instruction { source: "sum <- b Add a", opcode: Add8NoCarryIn, args: [Register(0x14), Register(0x13), Register(0x15)], resolved: None }
24 14 13 15 
# 815d9 Instruction { source: "Arg0[a]=sum None <= call print_dec(sum,)", opcode: Copy8, args: [Register(0x15), Register(0x00)], resolved: None }
16 15 00 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55}
# Registers used by callee tree: {56, 57, 58}
# Registers to save: []
# 815dc Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 815e2 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c ec 15 08 00 
# 815e8 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: JmpImm, args: [Label24(:print_dec)], resolved: None }
40 22 18 08 
# 815ec Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 815f2 Instruction { source: "t46 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x0a=10)], resolved: None }
00 18 0a 
# 815f5 Instruction { source: "ttyout <- t46", opcode: TtyOut, args: [Register(0x18)], resolved: None }
13 18 
# 815f7 Instruction { source: "t51 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x1c), Constant32(0x00000000=0)], resolved: None }
80 1c 00 00 00 00 
# 815fd Instruction { source: "t49 <- __frame_pointer Add t51", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x1c), Register(0x1c)], resolved: None }
a0 0c 1c 1c 
# 81601 Instruction { source: "Arg0[s]=t49 None <= call stack_push(t49,sum,)", opcode: Copy32, args: [Register(0x1c), Register(0x00)], resolved: None }
81 1c 00 
# 81604 Instruction { source: "Arg1[n]=sum None <= call stack_push(t49,sum,)", opcode: Copy8, args: [Register(0x15), Register(0x04)], resolved: None }
16 15 04 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55}
# Registers used by callee tree: {116, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131}
# Registers to save: []
# 81607 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8160d Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 17 16 08 00 
# 81613 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 37 1a 08 
# 81617 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8161d Instruction { source: "goto main_if_end_24", opcode: JmpImm, args: [Label24(main_if_end_24)], resolved: None }
40 19 18 08 
# main_if_else_0_26
# 81621 Instruction { source: "t54 <- 0n45/0x2du8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x2d=45)], resolved: None }
00 18 2d 
# 81624 Instruction { source: "if ch == t54 then 'main_if_true_1_27' else 'main_if_else_1_28'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 81627 Instruction { source: "if ch == t54 then 'main_if_true_1_27' else 'main_if_else_1_28'", opcode: JzImm, args: [Label24(main_if_true_1_27)], resolved: None }
42 2f 16 08 
# 8162b Instruction { source: "if ch == t54 then 'main_if_true_1_27' else 'main_if_else_1_28'", opcode: JmpImm, args: [Label24(main_if_else_1_28)], resolved: None }
40 80 16 08 
# main_if_true_1_27
# 8162f Instruction { source: "diff <- b Subtract a", opcode: Copy8, args: [Register(0x13), Register(0x00)], resolved: None }
16 13 00 
# 81632 Instruction { source: "diff <- b Subtract a", opcode: Negate8, args: [Register(0x00)], resolved: None }
04 00 
# 81634 Instruction { source: "diff <- b Subtract a", opcode: Add8NoCarryIn, args: [Register(0x14), Register(0x00), Register(0x15)], resolved: None }
24 14 00 15 
# 81638 Instruction { source: "Arg0[a]=diff None <= call print_dec(diff,)", opcode: Copy8, args: [Register(0x15), Register(0x00)], resolved: None }
16 15 00 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55}
# Registers used by callee tree: {56, 57, 58}
# Registers to save: []
# 8163b Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81641 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 4b 16 08 00 
# 81647 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: JmpImm, args: [Label24(:print_dec)], resolved: None }
40 22 18 08 
# 8164b Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81651 Instruction { source: "t59 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x0a=10)], resolved: None }
00 18 0a 
# 81654 Instruction { source: "ttyout <- t59", opcode: TtyOut, args: [Register(0x18)], resolved: None }
13 18 
# 81656 Instruction { source: "t64 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x1c), Constant32(0x00000000=0)], resolved: None }
80 1c 00 00 00 00 
# 8165c Instruction { source: "t62 <- __frame_pointer Add t64", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x1c), Register(0x1c)], resolved: None }
a0 0c 1c 1c 
# 81660 Instruction { source: "Arg0[s]=t62 None <= call stack_push(t62,diff,)", opcode: Copy32, args: [Register(0x1c), Register(0x00)], resolved: None }
81 1c 00 
# 81663 Instruction { source: "Arg1[n]=diff None <= call stack_push(t62,diff,)", opcode: Copy8, args: [Register(0x15), Register(0x04)], resolved: None }
16 15 04 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55}
# Registers used by callee tree: {116, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131}
# Registers to save: []
# 81666 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8166c Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 76 16 08 00 
# 81672 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 37 1a 08 
# 81676 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 8167c Instruction { source: "goto main_if_end_24", opcode: JmpImm, args: [Label24(main_if_end_24)], resolved: None }
40 19 18 08 
# main_if_else_1_28
# 81680 Instruction { source: "t67 <- 0n42/0x2au8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x2a=42)], resolved: None }
00 18 2a 
# 81683 Instruction { source: "if ch == t67 then 'main_if_true_2_29' else 'main_if_else_2_30'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 81686 Instruction { source: "if ch == t67 then 'main_if_true_2_29' else 'main_if_else_2_30'", opcode: JzImm, args: [Label24(main_if_true_2_29)], resolved: None }
42 8e 16 08 
# 8168a Instruction { source: "if ch == t67 then 'main_if_true_2_29' else 'main_if_else_2_30'", opcode: JmpImm, args: [Label24(main_if_else_2_30)], resolved: None }
40 dd 16 08 
# main_if_true_2_29
# 8168e Instruction { source: "product <- b Multiply a", opcode: Mul8_1, args: [Register(0x14), Register(0x13)], resolved: None }
20 14 13 
# 81691 Instruction { source: "product <- b Multiply a", opcode: Mul8_2, args: [], resolved: None }
21 
# 81692 Instruction { source: "product <- b Multiply a", opcode: Copy8, args: [Register(0x00), Register(0x15)], resolved: None }
16 00 15 
# 81695 Instruction { source: "Arg0[a]=product None <= call print_dec(product,)", opcode: Copy8, args: [Register(0x15), Register(0x00)], resolved: None }
16 15 00 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55}
# Registers used by callee tree: {56, 57, 58}
# Registers to save: []
# 81698 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 8169e Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c a8 16 08 00 
# 816a4 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: JmpImm, args: [Label24(:print_dec)], resolved: None }
40 22 18 08 
# 816a8 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 816ae Instruction { source: "t72 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x0a=10)], resolved: None }
00 18 0a 
# 816b1 Instruction { source: "ttyout <- t72", opcode: TtyOut, args: [Register(0x18)], resolved: None }
13 18 
# 816b3 Instruction { source: "t77 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x1c), Constant32(0x00000000=0)], resolved: None }
80 1c 00 00 00 00 
# 816b9 Instruction { source: "t75 <- __frame_pointer Add t77", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x1c), Register(0x1c)], resolved: None }
a0 0c 1c 1c 
# 816bd Instruction { source: "Arg0[s]=t75 None <= call stack_push(t75,product,)", opcode: Copy32, args: [Register(0x1c), Register(0x00)], resolved: None }
81 1c 00 
# 816c0 Instruction { source: "Arg1[n]=product None <= call stack_push(t75,product,)", opcode: Copy8, args: [Register(0x15), Register(0x04)], resolved: None }
16 15 04 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55}
# Registers used by callee tree: {116, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131}
# Registers to save: []
# 816c3 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 816c9 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c d3 16 08 00 
# 816cf Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 37 1a 08 
# 816d3 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 816d9 Instruction { source: "goto main_if_end_24", opcode: JmpImm, args: [Label24(main_if_end_24)], resolved: None }
40 19 18 08 
# main_if_else_2_30
# 816dd Instruction { source: "t80 <- 0n47/0x2fu8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x2f=47)], resolved: None }
00 18 2f 
# 816e0 Instruction { source: "if ch == t80 then 'main_if_true_3_31' else 'main_if_else_3_32'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 816e3 Instruction { source: "if ch == t80 then 'main_if_true_3_31' else 'main_if_else_3_32'", opcode: JzImm, args: [Label24(main_if_true_3_31)], resolved: None }
42 eb 16 08 
# 816e7 Instruction { source: "if ch == t80 then 'main_if_true_3_31' else 'main_if_else_3_32'", opcode: JmpImm, args: [Label24(main_if_else_3_32)], resolved: None }
40 37 17 08 
# main_if_true_3_31
# 816eb Instruction { source: "quotient <- b Divide a", opcode: Divide8, args: [Register(0x14), Register(0x13), Register(0x15)], resolved: None }
27 14 13 15 
# 816ef Instruction { source: "Arg0[a]=quotient None <= call print_dec(quotient,)", opcode: Copy8, args: [Register(0x15), Register(0x00)], resolved: None }
16 15 00 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55}
# Registers used by callee tree: {56, 57, 58}
# Registers to save: []
# 816f2 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 816f8 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 02 17 08 00 
# 816fe Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: JmpImm, args: [Label24(:print_dec)], resolved: None }
40 22 18 08 
# 81702 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81708 Instruction { source: "t85 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x0a=10)], resolved: None }
00 18 0a 
# 8170b Instruction { source: "ttyout <- t85", opcode: TtyOut, args: [Register(0x18)], resolved: None }
13 18 
# 8170d Instruction { source: "t90 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x1c), Constant32(0x00000000=0)], resolved: None }
80 1c 00 00 00 00 
# 81713 Instruction { source: "t88 <- __frame_pointer Add t90", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x1c), Register(0x1c)], resolved: None }
a0 0c 1c 1c 
# 81717 Instruction { source: "Arg0[s]=t88 None <= call stack_push(t88,quotient,)", opcode: Copy32, args: [Register(0x1c), Register(0x00)], resolved: None }
81 1c 00 
# 8171a Instruction { source: "Arg1[n]=quotient None <= call stack_push(t88,quotient,)", opcode: Copy8, args: [Register(0x15), Register(0x04)], resolved: None }
16 15 04 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55}
# Registers used by callee tree: {116, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131}
# Registers to save: []
# 8171d Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81723 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 2d 17 08 00 
# 81729 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 37 1a 08 
# 8172d Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81733 Instruction { source: "goto main_if_end_24", opcode: JmpImm, args: [Label24(main_if_end_24)], resolved: None }
40 19 18 08 
# main_if_else_3_32
# 81737 Instruction { source: "t93 <- 0n113/0x71u8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x71=113)], resolved: None }
00 18 71 
# 8173a Instruction { source: "if ch == t93 then 'main_if_true_4_33' else 'main_if_else_4_34'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 8173d Instruction { source: "if ch == t93 then 'main_if_true_4_33' else 'main_if_else_4_34'", opcode: JzImm, args: [Label24(main_if_true_4_33)], resolved: None }
42 45 17 08 
# 81741 Instruction { source: "if ch == t93 then 'main_if_true_4_33' else 'main_if_else_4_34'", opcode: JmpImm, args: [Label24(main_if_else_4_34)], resolved: None }
40 57 17 08 
# main_if_true_4_33
# 81745 Instruction { source: "t94 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x20), Constant8(0x00=0)], resolved: None }
00 20 00 
# 81748 Instruction { source: "return Some(t94)", opcode: Copy8, args: [Register(0x20), Register(0x00)], resolved: None }
16 20 00 
# 8174b Instruction { source: "Dealloc 104 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000068=104)], resolved: None }
a3 0c 68 00 00 00 
# 81751 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81753 Instruction { source: "goto main_if_end_24", opcode: JmpImm, args: [Label24(main_if_end_24)], resolved: None }
40 19 18 08 
# main_if_else_4_34
# 81757 Instruction { source: "t96 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x0a=10)], resolved: None }
00 18 0a 
# 8175a Instruction { source: "if ch == t96 then 'main_if_true_5_35' else 'main_if_else_5_36'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 8175d Instruction { source: "if ch == t96 then 'main_if_true_5_35' else 'main_if_else_5_36'", opcode: JzImm, args: [Label24(main_if_true_5_35)], resolved: None }
42 65 17 08 
# 81761 Instruction { source: "if ch == t96 then 'main_if_true_5_35' else 'main_if_else_5_36'", opcode: JmpImm, args: [Label24(main_if_else_5_36)], resolved: None }
40 a3 17 08 
# main_if_true_5_35
# 81765 Instruction { source: "t98 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x15), Constant8(0x00=0)], resolved: None }
00 15 00 
# 81768 Instruction { source: "if have_num != t98 then 'main_if_true_0_38' else 'main_if_else_0_39'", opcode: Cmp8, args: [Register(0x16), Register(0x15)], resolved: None }
25 16 15 
# 8176b Instruction { source: "if have_num != t98 then 'main_if_true_0_38' else 'main_if_else_0_39'", opcode: JzImm, args: [Label24(main_if_else_0_39)], resolved: None }
42 9f 17 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if have_num != t98 then 'main_if_true_0_38' else 'main_if_else_0_39'", opcode: JmpImm, args: [Label24(main_if_true_0_38)], resolved: None }
# main_if_true_0_38
# 8176f Instruction { source: "t103 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x24), Constant32(0x00000000=0)], resolved: None }
80 24 00 00 00 00 
# 81775 Instruction { source: "t101 <- __frame_pointer Add t103", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x24), Register(0x24)], resolved: None }
a0 0c 24 24 
# 81779 Instruction { source: "Arg0[s]=t101 None <= call stack_push(t101,num,)", opcode: Copy32, args: [Register(0x24), Register(0x00)], resolved: None }
81 24 00 
# 8177c Instruction { source: "Arg1[n]=num None <= call stack_push(t101,num,)", opcode: Copy8, args: [Register(0x17), Register(0x04)], resolved: None }
16 17 04 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55}
# Registers used by callee tree: {116, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131}
# Registers to save: []
# 8177f Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81785 Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 8f 17 08 00 
# 8178b Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: JmpImm, args: [Label24(:stack_push)], resolved: None }
40 37 1a 08 
# 8178f Instruction { source: "PseudoCall(Label24(:stack_push))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81795 Instruction { source: "num <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x17), Constant8(0x00=0)], resolved: None }
00 17 00 
# 81798 Instruction { source: "have_num <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x16), Constant8(0x00=0)], resolved: None }
00 16 00 
# 8179b Instruction { source: "goto main_if_end_37", opcode: JmpImm, args: [Label24(main_if_end_37)], resolved: None }
40 9f 17 08 
# main_if_else_0_39
# main_if_end_37
# 8179f Instruction { source: "goto main_if_end_24", opcode: JmpImm, args: [Label24(main_if_end_24)], resolved: None }
40 19 18 08 
# main_if_else_5_36
# 817a3 Instruction { source: "t106 <- 0n99/0x63u8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x63=99)], resolved: None }
00 18 63 
# 817a6 Instruction { source: "if ch == t106 then 'main_if_true_6_40' else 'main_if_else_6_41'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 817a9 Instruction { source: "if ch == t106 then 'main_if_true_6_40' else 'main_if_else_6_41'", opcode: JzImm, args: [Label24(main_if_true_6_40)], resolved: None }
42 b1 17 08 
# 817ad Instruction { source: "if ch == t106 then 'main_if_true_6_40' else 'main_if_else_6_41'", opcode: JmpImm, args: [Label24(main_if_else_6_41)], resolved: None }
40 d8 17 08 
# main_if_true_6_40
# 817b1 Instruction { source: "t111 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x24), Constant32(0x00000000=0)], resolved: None }
80 24 00 00 00 00 
# 817b7 Instruction { source: "t109 <- __frame_pointer Add t111", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x24), Register(0x24)], resolved: None }
a0 0c 24 24 
# 817bb Instruction { source: "Arg0[s]=t109 None <= call stack_init(t109,)", opcode: Copy32, args: [Register(0x24), Register(0x00)], resolved: None }
81 24 00 
# Registers used by this function: {19, 20, 21, 22, 23, 24, 28, 29, 30, 31, 32, 36, 37, 38, 39, 40, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55}
# Registers used by callee tree: {88, 89, 90, 91, 92, 93, 94, 95}
# Registers to save: []
# 817be Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 817c4 Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c ce 17 08 00 
# 817ca Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: JmpImm, args: [Label24(:stack_init)], resolved: None }
40 c2 19 08 
# 817ce Instruction { source: "PseudoCall(Label24(:stack_init))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 817d4 Instruction { source: "goto main_if_end_24", opcode: JmpImm, args: [Label24(main_if_end_24)], resolved: None }
40 19 18 08 
# main_if_else_6_41
# 817d8 Instruction { source: "t113 <- 0n57/0x39u8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x39=57)], resolved: None }
00 18 39 
# 817db Instruction { source: "if ch <= t113 then 'main_if_true_7_42' else 'main_if_else_7_43'", opcode: Cmp8, args: [Register(0x15), Register(0x18)], resolved: None }
25 15 18 
# 817de Instruction { source: "if ch <= t113 then 'main_if_true_7_42' else 'main_if_else_7_43'", opcode: JcImm, args: [Label24(main_if_true_7_42)], resolved: None }
41 e6 17 08 
# 817e2 Instruction { source: "if ch <= t113 then 'main_if_true_7_42' else 'main_if_else_7_43'", opcode: JmpImm, args: [Label24(main_if_else_7_43)], resolved: None }
40 19 18 08 
# main_if_true_7_42
# 817e6 Instruction { source: "t115 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x30=48)], resolved: None }
00 18 30 
# 817e9 Instruction { source: "if ch >= t115 then 'main_if_true_0_45' else 'main_if_else_0_46'", opcode: Cmp8, args: [Register(0x18), Register(0x15)], resolved: None }
25 18 15 
# 817ec Instruction { source: "if ch >= t115 then 'main_if_true_0_45' else 'main_if_else_0_46'", opcode: JcImm, args: [Label24(main_if_true_0_45)], resolved: None }
41 f4 17 08 
# 817f0 Instruction { source: "if ch >= t115 then 'main_if_true_0_45' else 'main_if_else_0_46'", opcode: JmpImm, args: [Label24(main_if_else_0_46)], resolved: None }
40 15 18 08 
# main_if_true_0_45
# 817f4 Instruction { source: "have_num <- 0n1/0x01u8 ", opcode: LoadImm8, args: [Register(0x16), Constant8(0x01=1)], resolved: None }
00 16 01 
# 817f7 Instruction { source: "t117 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x0a=10)], resolved: None }
00 18 0a 
# 817fa Instruction { source: "num <- num Multiply t117", opcode: Mul8_1, args: [Register(0x17), Register(0x18)], resolved: None }
20 17 18 
# 817fd Instruction { source: "num <- num Multiply t117", opcode: Mul8_2, args: [], resolved: None }
21 
# 817fe Instruction { source: "num <- num Multiply t117", opcode: Copy8, args: [Register(0x00), Register(0x17)], resolved: None }
16 00 17 
# 81801 Instruction { source: "t121 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x18), Constant8(0x30=48)], resolved: None }
00 18 30 
# 81804 Instruction { source: "t119 <- ch Subtract t121", opcode: Copy8, args: [Register(0x18), Register(0x00)], resolved: None }
16 18 00 
# 81807 Instruction { source: "t119 <- ch Subtract t121", opcode: Negate8, args: [Register(0x00)], resolved: None }
04 00 
# 81809 Instruction { source: "t119 <- ch Subtract t121", opcode: Add8NoCarryIn, args: [Register(0x15), Register(0x00), Register(0x15)], resolved: None }
24 15 00 15 
# 8180d Instruction { source: "num <- num Add t119", opcode: Add8NoCarryIn, args: [Register(0x17), Register(0x15), Register(0x17)], resolved: None }
24 17 15 17 
# 81811 Instruction { source: "goto main_if_end_44", opcode: JmpImm, args: [Label24(main_if_end_44)], resolved: None }
40 15 18 08 
# main_if_else_0_46
# main_if_end_44
# 81815 Instruction { source: "goto main_if_end_24", opcode: JmpImm, args: [Label24(main_if_end_24)], resolved: None }
40 19 18 08 
# main_if_else_7_43
# main_if_end_24
# 81819 Instruction { source: "goto main_while_predicate_0", opcode: JmpImm, args: [Label24(main_while_predicate_0)], resolved: None }
40 86 14 08 
# main_while_end_2
# 8181d Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :print_dec
# Ret None
# Arg0=a
# Var a (Arg0 a Number(U8)) U8 Some([56])
# Var b (Local b Number(U8) U8) U8 Some([57])
# Var t1 (t1 Number(U8, 100)) U8 Some([57])
# Var t10 (t10 Number(U8, 100)) U8 Some([58])
# Var t12 (t12 Number(U8, 10)) U8 Some([57])
# Var t13 (t13 Arithmetic(Add, Ident("b"), Number(U8, 48))) U8 Some([58])
# Var t15 (t15 Number(U8, 48)) U8 Some([58])
# Var t17 (t17 Arithmetic(Multiply, Ident("b"), Number(U8, 10))) U8 Some([57])
# Var t19 (t19 Number(U8, 10)) U8 Some([58])
# Var t21 (t21 Number(U8, 10)) U8 Some([57])
# Var t23 (t23 Number(U8, 10)) U8 Some([57])
# Var t24 (t24 Arithmetic(Add, Ident("b"), Number(U8, 48))) U8 Some([58])
# Var t26 (t26 Number(U8, 48)) U8 Some([58])
# Var t28 (t28 Arithmetic(Multiply, Ident("b"), Number(U8, 10))) U8 Some([57])
# Var t3 (t3 Number(U8, 100)) U8 Some([57])
# Var t30 (t30 Number(U8, 10)) U8 Some([58])
# Var t31 (t31 Arithmetic(Add, Ident("a"), Number(U8, 48))) U8 Some([56])
# Var t33 (t33 Number(U8, 48)) U8 Some([57])
# Var t4 (t4 Arithmetic(Add, Ident("b"), Number(U8, 48))) U8 Some([58])
# Var t6 (t6 Number(U8, 48)) U8 Some([58])
# Var t8 (t8 Arithmetic(Multiply, Ident("b"), Number(U8, 100))) U8 Some([57])
# 81822 Instruction { source: "Save function parameter 'a' registers [0] to locals [56].", opcode: Copy8, args: [Register(0x00), Register(0x38)], resolved: None }
16 00 38 
# 81825 Instruction { source: "t1 <- 0n100/0x64u8 ", opcode: LoadImm8, args: [Register(0x39), Constant8(0x64=100)], resolved: None }
00 39 64 
# 81828 Instruction { source: "if a >= t1 then 'print_dec_if_true_0_1' else 'print_dec_if_else_0_2'", opcode: Cmp8, args: [Register(0x39), Register(0x38)], resolved: None }
25 39 38 
# 8182b Instruction { source: "if a >= t1 then 'print_dec_if_true_0_1' else 'print_dec_if_else_0_2'", opcode: JcImm, args: [Label24(print_dec_if_true_0_1)], resolved: None }
41 33 18 08 
# 8182f Instruction { source: "if a >= t1 then 'print_dec_if_true_0_1' else 'print_dec_if_else_0_2'", opcode: JmpImm, args: [Label24(print_dec_if_else_0_2)], resolved: None }
40 7d 18 08 
# print_dec_if_true_0_1
# 81833 Instruction { source: "t3 <- 0n100/0x64u8 ", opcode: LoadImm8, args: [Register(0x39), Constant8(0x64=100)], resolved: None }
00 39 64 
# 81836 Instruction { source: "b <- a Divide t3", opcode: Divide8, args: [Register(0x38), Register(0x39), Register(0x39)], resolved: None }
27 38 39 39 
# 8183a Instruction { source: "t6 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x3a), Constant8(0x30=48)], resolved: None }
00 3a 30 
# 8183d Instruction { source: "t4 <- b Add t6", opcode: Add8NoCarryIn, args: [Register(0x39), Register(0x3a), Register(0x3a)], resolved: None }
24 39 3a 3a 
# 81841 Instruction { source: "ttyout <- t4", opcode: TtyOut, args: [Register(0x3a)], resolved: None }
13 3a 
# 81843 Instruction { source: "t10 <- 0n100/0x64u8 ", opcode: LoadImm8, args: [Register(0x3a), Constant8(0x64=100)], resolved: None }
00 3a 64 
# 81846 Instruction { source: "t8 <- b Multiply t10", opcode: Mul8_1, args: [Register(0x39), Register(0x3a)], resolved: None }
20 39 3a 
# 81849 Instruction { source: "t8 <- b Multiply t10", opcode: Mul8_2, args: [], resolved: None }
21 
# 8184a Instruction { source: "t8 <- b Multiply t10", opcode: Copy8, args: [Register(0x00), Register(0x39)], resolved: None }
16 00 39 
# 8184d Instruction { source: "a <- a Subtract t8", opcode: Copy8, args: [Register(0x39), Register(0x00)], resolved: None }
16 39 00 
# 81850 Instruction { source: "a <- a Subtract t8", opcode: Negate8, args: [Register(0x00)], resolved: None }
04 00 
# 81852 Instruction { source: "a <- a Subtract t8", opcode: Add8NoCarryIn, args: [Register(0x38), Register(0x00), Register(0x38)], resolved: None }
24 38 00 38 
# 81856 Instruction { source: "t12 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x39), Constant8(0x0a=10)], resolved: None }
00 39 0a 
# 81859 Instruction { source: "b <- a Divide t12", opcode: Divide8, args: [Register(0x38), Register(0x39), Register(0x39)], resolved: None }
27 38 39 39 
# 8185d Instruction { source: "t15 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x3a), Constant8(0x30=48)], resolved: None }
00 3a 30 
# 81860 Instruction { source: "t13 <- b Add t15", opcode: Add8NoCarryIn, args: [Register(0x39), Register(0x3a), Register(0x3a)], resolved: None }
24 39 3a 3a 
# 81864 Instruction { source: "ttyout <- t13", opcode: TtyOut, args: [Register(0x3a)], resolved: None }
13 3a 
# 81866 Instruction { source: "t19 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x3a), Constant8(0x0a=10)], resolved: None }
00 3a 0a 
# 81869 Instruction { source: "t17 <- b Multiply t19", opcode: Mul8_1, args: [Register(0x39), Register(0x3a)], resolved: None }
20 39 3a 
# 8186c Instruction { source: "t17 <- b Multiply t19", opcode: Mul8_2, args: [], resolved: None }
21 
# 8186d Instruction { source: "t17 <- b Multiply t19", opcode: Copy8, args: [Register(0x00), Register(0x39)], resolved: None }
16 00 39 
# 81870 Instruction { source: "a <- a Subtract t17", opcode: Copy8, args: [Register(0x39), Register(0x00)], resolved: None }
16 39 00 
# 81873 Instruction { source: "a <- a Subtract t17", opcode: Negate8, args: [Register(0x00)], resolved: None }
04 00 
# 81875 Instruction { source: "a <- a Subtract t17", opcode: Add8NoCarryIn, args: [Register(0x38), Register(0x00), Register(0x38)], resolved: None }
24 38 00 38 
# 81879 Instruction { source: "goto print_dec_if_end_0", opcode: JmpImm, args: [Label24(print_dec_if_end_0)], resolved: None }
40 b2 18 08 
# print_dec_if_else_0_2
# 8187d Instruction { source: "t21 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x39), Constant8(0x0a=10)], resolved: None }
00 39 0a 
# 81880 Instruction { source: "if a >= t21 then 'print_dec_if_true_1_3' else 'print_dec_if_else_1_4'", opcode: Cmp8, args: [Register(0x39), Register(0x38)], resolved: None }
25 39 38 
# 81883 Instruction { source: "if a >= t21 then 'print_dec_if_true_1_3' else 'print_dec_if_else_1_4'", opcode: JcImm, args: [Label24(print_dec_if_true_1_3)], resolved: None }
41 8b 18 08 
# 81887 Instruction { source: "if a >= t21 then 'print_dec_if_true_1_3' else 'print_dec_if_else_1_4'", opcode: JmpImm, args: [Label24(print_dec_if_else_1_4)], resolved: None }
40 b2 18 08 
# print_dec_if_true_1_3
# 8188b Instruction { source: "t23 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x39), Constant8(0x0a=10)], resolved: None }
00 39 0a 
# 8188e Instruction { source: "b <- a Divide t23", opcode: Divide8, args: [Register(0x38), Register(0x39), Register(0x39)], resolved: None }
27 38 39 39 
# 81892 Instruction { source: "t26 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x3a), Constant8(0x30=48)], resolved: None }
00 3a 30 
# 81895 Instruction { source: "t24 <- b Add t26", opcode: Add8NoCarryIn, args: [Register(0x39), Register(0x3a), Register(0x3a)], resolved: None }
24 39 3a 3a 
# 81899 Instruction { source: "ttyout <- t24", opcode: TtyOut, args: [Register(0x3a)], resolved: None }
13 3a 
# 8189b Instruction { source: "t30 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x3a), Constant8(0x0a=10)], resolved: None }
00 3a 0a 
# 8189e Instruction { source: "t28 <- b Multiply t30", opcode: Mul8_1, args: [Register(0x39), Register(0x3a)], resolved: None }
20 39 3a 
# 818a1 Instruction { source: "t28 <- b Multiply t30", opcode: Mul8_2, args: [], resolved: None }
21 
# 818a2 Instruction { source: "t28 <- b Multiply t30", opcode: Copy8, args: [Register(0x00), Register(0x39)], resolved: None }
16 00 39 
# 818a5 Instruction { source: "a <- a Subtract t28", opcode: Copy8, args: [Register(0x39), Register(0x00)], resolved: None }
16 39 00 
# 818a8 Instruction { source: "a <- a Subtract t28", opcode: Negate8, args: [Register(0x00)], resolved: None }
04 00 
# 818aa Instruction { source: "a <- a Subtract t28", opcode: Add8NoCarryIn, args: [Register(0x38), Register(0x00), Register(0x38)], resolved: None }
24 38 00 38 
# 818ae Instruction { source: "goto print_dec_if_end_0", opcode: JmpImm, args: [Label24(print_dec_if_end_0)], resolved: None }
40 b2 18 08 
# print_dec_if_else_1_4
# print_dec_if_end_0
# 818b2 Instruction { source: "t33 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x39), Constant8(0x30=48)], resolved: None }
00 39 30 
# 818b5 Instruction { source: "t31 <- a Add t33", opcode: Add8NoCarryIn, args: [Register(0x38), Register(0x39), Register(0x38)], resolved: None }
24 38 39 38 
# 818b9 Instruction { source: "ttyout <- t31", opcode: TtyOut, args: [Register(0x38)], resolved: None }
13 38 
# 818bb Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 818bd Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :print_dec_test
# Ret Some(U8)
# Arg0=a
# Arg1=b
# Var a (Arg0 a Number(U8)) U8 Some([59])
# Var b (Arg1 b Number(U8)) U8 Some([60])
# Var t0 (t0 Call(Call { function: "print_dec", parameters: [Ident("a")] })) U8 Some([59])
# Var t2 (t2 Number(U8, 0)) U8 Some([59])
# 818c2 Instruction { source: "Save function parameter 'a' registers [0] to locals [59].", opcode: Copy8, args: [Register(0x00), Register(0x3b)], resolved: None }
16 00 3b 
# 818c5 Instruction { source: "Save function parameter 'b' registers [4] to locals [60].", opcode: Copy8, args: [Register(0x04), Register(0x3c)], resolved: None }
16 04 3c 
# 818c8 Instruction { source: "Arg0[a]=a None <= call print_dec(a,)", opcode: Copy8, args: [Register(0x3b), Register(0x00)], resolved: None }
16 3b 00 
# Registers used by this function: {59, 60}
# Registers used by callee tree: {56, 57, 58}
# Registers to save: []
# 818cb Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 818d1 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c db 18 08 00 
# 818d7 Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: JmpImm, args: [Label24(:print_dec)], resolved: None }
40 22 18 08 
# 818db Instruction { source: "PseudoCall(Label24(:print_dec))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 818e1 Instruction { source: "t2 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x3b), Constant8(0x00=0)], resolved: None }
00 3b 00 
# 818e4 Instruction { source: "return Some(t2)", opcode: Copy8, args: [Register(0x3b), Register(0x00)], resolved: None }
16 3b 00 
# 818e7 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 818e9 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :print_digit
# Ret None
# Arg0=a
# Var a (Arg0 a Number(U8)) U8 Some([61])
# Var t1 (t1 Number(U8, 10)) U8 Some([62])
# Var t2 (t2 Arithmetic(Add, Ident("a"), Number(U8, 48))) U8 Some([61])
# Var t4 (t4 Number(U8, 48)) U8 Some([62])
# Var t6 (t6 Number(U8, 10)) U8 Some([62])
# Var t8 (t8 Number(U8, 65)) U8 Some([62])
# 818ee Instruction { source: "Save function parameter 'a' registers [0] to locals [61].", opcode: Copy8, args: [Register(0x00), Register(0x3d)], resolved: None }
16 00 3d 
# 818f1 Instruction { source: "t1 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x3e), Constant8(0x0a=10)], resolved: None }
00 3e 0a 
# 818f4 Instruction { source: "if a < t1 then 'print_digit_if_true_0_1' else 'print_digit_if_else_0_2'", opcode: Cmp8, args: [Register(0x3e), Register(0x3d)], resolved: None }
25 3e 3d 
# 818f7 Instruction { source: "if a < t1 then 'print_digit_if_true_0_1' else 'print_digit_if_else_0_2'", opcode: JcImm, args: [Label24(print_digit_if_else_0_2)], resolved: None }
41 08 19 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if a < t1 then 'print_digit_if_true_0_1' else 'print_digit_if_else_0_2'", opcode: JmpImm, args: [Label24(print_digit_if_true_0_1)], resolved: None }
# print_digit_if_true_0_1
# 818fb Instruction { source: "t4 <- 0n48/0x30u8 ", opcode: LoadImm8, args: [Register(0x3e), Constant8(0x30=48)], resolved: None }
00 3e 30 
# 818fe Instruction { source: "t2 <- a Add t4", opcode: Add8NoCarryIn, args: [Register(0x3d), Register(0x3e), Register(0x3d)], resolved: None }
24 3d 3e 3d 
# 81902 Instruction { source: "ttyout <- t2", opcode: TtyOut, args: [Register(0x3d)], resolved: None }
13 3d 
# 81904 Instruction { source: "goto print_digit_if_end_0", opcode: JmpImm, args: [Label24(print_digit_if_end_0)], resolved: None }
40 1d 19 08 
# print_digit_if_else_0_2
# 81908 Instruction { source: "t6 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x3e), Constant8(0x0a=10)], resolved: None }
00 3e 0a 
# 8190b Instruction { source: "a <- a Subtract t6", opcode: Copy8, args: [Register(0x3e), Register(0x00)], resolved: None }
16 3e 00 
# 8190e Instruction { source: "a <- a Subtract t6", opcode: Negate8, args: [Register(0x00)], resolved: None }
04 00 
# 81910 Instruction { source: "a <- a Subtract t6", opcode: Add8NoCarryIn, args: [Register(0x3d), Register(0x00), Register(0x3d)], resolved: None }
24 3d 00 3d 
# 81914 Instruction { source: "t8 <- 0n65/0x41u8 ", opcode: LoadImm8, args: [Register(0x3e), Constant8(0x41=65)], resolved: None }
00 3e 41 
# 81917 Instruction { source: "a <- a Add t8", opcode: Add8NoCarryIn, args: [Register(0x3d), Register(0x3e), Register(0x3d)], resolved: None }
24 3d 3e 3d 
# 8191b Instruction { source: "ttyout <- a", opcode: TtyOut, args: [Register(0x3d)], resolved: None }
13 3d 
# print_digit_if_end_0
# 8191d Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 8191f Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :println
# Ret None
# Arg0=buf
# Var buf (Arg0 buf Ptr(Number(U8))) U32 Some([64, 65, 66, 67])
# Var ch (Local ch Number(U8) U8) U8 Some([68])
# Var t2 (t2 Number(U8, 0)) U8 Some([69])
# Var t5 (t5 Number(USIZE, 1)) U32 Some([72, 73, 74, 75])
# 81924 Instruction { source: "Save function parameter 'buf' registers [0, 1, 2, 3] to locals [64, 65, 66, 67].", opcode: Copy32, args: [Register(0x00), Register(0x40)], resolved: None }
81 00 40 
# 81927 Instruction { source: "ch <- mem[buf] U8", opcode: Load8, args: [Register(0x40), Register(0x44)], resolved: None }
10 40 44 
# println_while_predicate_0
# 8192a Instruction { source: "t2 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x45), Constant8(0x00=0)], resolved: None }
00 45 00 
# 8192d Instruction { source: "if ch != t2 then 'println_while_body_1' else 'println_while_end_2'", opcode: Cmp8, args: [Register(0x44), Register(0x45)], resolved: None }
25 44 45 
# 81930 Instruction { source: "if ch != t2 then 'println_while_body_1' else 'println_while_end_2'", opcode: JzImm, args: [Label24(println_while_end_2)], resolved: None }
42 47 19 08 
# Optimized away unconditional jump to the next instruction: Instruction { source: "if ch != t2 then 'println_while_body_1' else 'println_while_end_2'", opcode: JmpImm, args: [Label24(println_while_body_1)], resolved: None }
# println_while_body_1
# 81934 Instruction { source: "ttyout <- ch", opcode: TtyOut, args: [Register(0x44)], resolved: None }
13 44 
# 81936 Instruction { source: "t5 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x48), Constant32(0x00000001=1)], resolved: None }
80 48 01 00 00 00 
# 8193c Instruction { source: "buf <- buf Add t5", opcode: Add32NoCarryIn, args: [Register(0x40), Register(0x48), Register(0x40)], resolved: None }
a0 40 48 40 
# 81940 Instruction { source: "ch <- mem[buf] U8", opcode: Load8, args: [Register(0x40), Register(0x44)], resolved: None }
10 40 44 
# 81943 Instruction { source: "goto println_while_predicate_0", opcode: JmpImm, args: [Label24(println_while_predicate_0)], resolved: None }
40 2a 19 08 
# println_while_end_2
# 81947 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81949 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :readline
# Ret None
# Arg0=buf
# Var buf (Arg0 buf Ptr(Number(U8))) U32 Some([76, 77, 78, 79])
# Var ch (Local ch Number(U8) U8) U8 Some([80])
# Var t0 (t0 Number(U8, 0)) U8 Some([80])
# Var t1 (t1 Number(U8, 0)) U8 Some([81])
# Var t10 (t10 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Number(U8))), new_type: Number(USIZE), value: Ident("buf") }, Number(USIZE, 1)) }) U32 Some([76, 77, 78, 79])
# Var t12 (t12 Number(USIZE, 1)) U32 Some([84, 85, 86, 87])
# Var t3 (t3 Number(U8, 13)) U8 Some([81])
# Var t5 (t5 Number(U8, 10)) U8 Some([81])
# Var t7 (t7 Number(U8, 0)) U8 Some([80])
# 8194e Instruction { source: "Save function parameter 'buf' registers [0, 1, 2, 3] to locals [76, 77, 78, 79].", opcode: Copy32, args: [Register(0x00), Register(0x4c)], resolved: None }
81 00 4c 
# readline_while_predicate_0
# 81951 Instruction { source: "t0 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x50), Constant8(0x00=0)], resolved: None }
00 50 00 
# 81954 Instruction { source: "t1 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x51), Constant8(0x00=0)], resolved: None }
00 51 00 
# 81957 Instruction { source: "if t0 == t1 then 'readline_while_body_1' else 'readline_while_end_2'", opcode: Cmp8, args: [Register(0x50), Register(0x51)], resolved: None }
25 50 51 
# 8195a Instruction { source: "if t0 == t1 then 'readline_while_body_1' else 'readline_while_end_2'", opcode: JzImm, args: [Label24(readline_while_body_1)], resolved: None }
42 62 19 08 
# 8195e Instruction { source: "if t0 == t1 then 'readline_while_body_1' else 'readline_while_end_2'", opcode: JmpImm, args: [Label24(readline_while_end_2)], resolved: None }
40 bb 19 08 
# readline_while_body_1
# Registers used by this function: {76, 77, 78, 79, 80, 81, 84, 85, 86, 87}
# Registers used by callee tree: {16, 17, 18}
# Registers to save: []
# 81962 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81968 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c 72 19 08 00 
# 8196e Instruction { source: "PseudoCall(Label24(:getchar))", opcode: JmpImm, args: [Label24(:getchar)], resolved: None }
40 22 14 08 
# 81972 Instruction { source: "PseudoCall(Label24(:getchar))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81978 Instruction { source: "Some(ch) <= call getchar()", opcode: Copy8, args: [Register(0x00), Register(0x50)], resolved: None }
16 00 50 
# 8197b Instruction { source: "t3 <- 0n13/0x0du8 ", opcode: LoadImm8, args: [Register(0x51), Constant8(0x0d=13)], resolved: None }
00 51 0d 
# 8197e Instruction { source: "if ch == t3 then 'readline_if_true_0_4' else 'readline_if_else_0_5'", opcode: Cmp8, args: [Register(0x50), Register(0x51)], resolved: None }
25 50 51 
# 81981 Instruction { source: "if ch == t3 then 'readline_if_true_0_4' else 'readline_if_else_0_5'", opcode: JzImm, args: [Label24(readline_if_true_0_4)], resolved: None }
42 89 19 08 
# 81985 Instruction { source: "if ch == t3 then 'readline_if_true_0_4' else 'readline_if_else_0_5'", opcode: JmpImm, args: [Label24(readline_if_else_0_5)], resolved: None }
40 8d 19 08 
# readline_if_true_0_4
# 81989 Instruction { source: "goto readline_if_end_3", opcode: JmpImm, args: [Label24(readline_if_end_3)], resolved: None }
40 b7 19 08 
# readline_if_else_0_5
# 8198d Instruction { source: "t5 <- 0n10/0x0au8 ", opcode: LoadImm8, args: [Register(0x51), Constant8(0x0a=10)], resolved: None }
00 51 0a 
# 81990 Instruction { source: "if ch == t5 then 'readline_if_true_1_6' else 'readline_if_else_1_7'", opcode: Cmp8, args: [Register(0x50), Register(0x51)], resolved: None }
25 50 51 
# 81993 Instruction { source: "if ch == t5 then 'readline_if_true_1_6' else 'readline_if_else_1_7'", opcode: JzImm, args: [Label24(readline_if_true_1_6)], resolved: None }
42 9b 19 08 
# 81997 Instruction { source: "if ch == t5 then 'readline_if_true_1_6' else 'readline_if_else_1_7'", opcode: JmpImm, args: [Label24(readline_if_else_1_7)], resolved: None }
40 a7 19 08 
# readline_if_true_1_6
# 8199b Instruction { source: "t7 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x50), Constant8(0x00=0)], resolved: None }
00 50 00 
# 8199e Instruction { source: "mem[buf] <- t7 U8", opcode: Store8, args: [Register(0x50), Register(0x4c)], resolved: None }
11 50 4c 
# 819a1 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 819a3 Instruction { source: "goto readline_if_end_3", opcode: JmpImm, args: [Label24(readline_if_end_3)], resolved: None }
40 b7 19 08 
# readline_if_else_1_7
# 819a7 Instruction { source: "mem[buf] <- ch U8", opcode: Store8, args: [Register(0x50), Register(0x4c)], resolved: None }
11 50 4c 
# 819aa Instruction { source: "t12 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x54), Constant32(0x00000001=1)], resolved: None }
80 54 01 00 00 00 
# 819b0 Instruction { source: "t10 <- buf Add t12", opcode: Add32NoCarryIn, args: [Register(0x4c), Register(0x54), Register(0x4c)], resolved: None }
a0 4c 54 4c 
# 819b4 Instruction { source: "buf <- t10 U32", opcode: Copy32, args: [Register(0x4c), Register(0x4c)], resolved: None }
81 4c 4c 
# readline_if_end_3
# 819b7 Instruction { source: "goto readline_while_predicate_0", opcode: JmpImm, args: [Label24(readline_while_predicate_0)], resolved: None }
40 51 19 08 
# readline_while_end_2
# 819bb Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 819bd Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :stack_init
# Ret None
# Arg0=s
# Var s (Arg0 s Ptr(Struct("Stack"))) U32 Some([88, 89, 90, 91])
# Var t0 (t0 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 4)) }) U32 Some([88, 89, 90, 91])
# Var t2 (t2 Number(USIZE, 4)) U32 Some([92, 93, 94, 95])
# Var t3 (t3 Number(USIZE, 0)) U32 Some([92, 93, 94, 95])
# 819c2 Instruction { source: "Save function parameter 's' registers [0, 1, 2, 3] to locals [88, 89, 90, 91].", opcode: Copy32, args: [Register(0x00), Register(0x58)], resolved: None }
81 00 58 
# 819c5 Instruction { source: "t2 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x5c), Constant32(0x00000004=4)], resolved: None }
80 5c 04 00 00 00 
# 819cb Instruction { source: "t0 <- s Add t2", opcode: Add32NoCarryIn, args: [Register(0x58), Register(0x5c), Register(0x58)], resolved: None }
a0 58 5c 58 
# 819cf Instruction { source: "t3 <- 0n0/0x00000000u32 ", opcode: LoadImm32, args: [Register(0x5c), Constant32(0x00000000=0)], resolved: None }
80 5c 00 00 00 00 
# 819d5 Instruction { source: "mem[t0] <- t3 U32", opcode: Store32_1, args: [Register(0x5c), Register(0x58)], resolved: None }
92 5c 58 
# 819d8 Instruction { source: "mem[t0] <- t3 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 819d9 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 819db Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :stack_pop
# Ret Some(U8)
# Arg0=s
# Var s (Arg0 s Ptr(Struct("Stack"))) U32 Some([96, 97, 98, 99])
# Var t0 (t0 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 4)) }) U32 Some([100, 101, 102, 103])
# Var t10 (t10 Index("values", PtrFieldDeref("s", "first_free"))) U8 Some([104])
# Var t11 (t11 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Number(U8))), new_type: Number(USIZE), value: Ident("values") }, PtrFieldDeref("s", "first_free")) }) U32 Some([96, 97, 98, 99])
# Var t13 (t13 PtrFieldDeref("s", "first_free")) U32 Some([100, 101, 102, 103])
# Var t14 (t14 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 4)) }) U32 Some([100, 101, 102, 103])
# Var t16 (t16 Number(USIZE, 4)) U32 Some([100, 101, 102, 103])
# Var t2 (t2 Number(USIZE, 4)) U32 Some([100, 101, 102, 103])
# Var t3 (t3 Arithmetic(Subtract, PtrFieldDeref("s", "first_free"), Number(U8, 1))) U32 Some([108, 109, 110, 111])
# Var t4 (t4 PtrFieldDeref("s", "first_free")) U32 Some([108, 109, 110, 111])
# Var t5 (t5 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 4)) }) U32 Some([108, 109, 110, 111])
# Var t7 (t7 Number(USIZE, 4)) U32 Some([108, 109, 110, 111])
# Var t8 (t8 Number(USIZE, 1)) U32 Some([112, 113, 114, 115])
# 819e0 Instruction { source: "Save function parameter 's' registers [0, 1, 2, 3] to locals [96, 97, 98, 99].", opcode: Copy32, args: [Register(0x00), Register(0x60)], resolved: None }
81 00 60 
# 819e3 Instruction { source: "t2 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x64), Constant32(0x00000004=4)], resolved: None }
80 64 04 00 00 00 
# 819e9 Instruction { source: "t0 <- s Add t2", opcode: Add32NoCarryIn, args: [Register(0x60), Register(0x64), Register(0x64)], resolved: None }
a0 60 64 64 
# 819ed Instruction { source: "t7 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x6c), Constant32(0x00000004=4)], resolved: None }
80 6c 04 00 00 00 
# 819f3 Instruction { source: "t5 <- s Add t7", opcode: Add32NoCarryIn, args: [Register(0x60), Register(0x6c), Register(0x6c)], resolved: None }
a0 60 6c 6c 
# 819f7 Instruction { source: "t4 <- mem[t5] U32", opcode: Load32, args: [Register(0x6c), Register(0x6c)], resolved: None }
90 6c 6c 
# 819fa Instruction { source: "t8 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x70), Constant32(0x00000001=1)], resolved: None }
80 70 01 00 00 00 
# 81a00 Instruction { source: "t3 <- t4 Subtract t8", opcode: Copy32, args: [Register(0x70), Register(0x00)], resolved: None }
81 70 00 
# 81a03 Instruction { source: "t3 <- t4 Subtract t8", opcode: Invert8, args: [Register(0x00)], resolved: None }
03 00 
# 81a05 Instruction { source: "t3 <- t4 Subtract t8", opcode: Invert8, args: [Register(0x01)], resolved: None }
03 01 
# 81a07 Instruction { source: "t3 <- t4 Subtract t8", opcode: Invert8, args: [Register(0x02)], resolved: None }
03 02 
# 81a09 Instruction { source: "t3 <- t4 Subtract t8", opcode: Invert8, args: [Register(0x03)], resolved: None }
03 03 
# 81a0b Instruction { source: "t3 <- t4 Subtract t8", opcode: AddImm32IgnoreCarry, args: [Register(0x00), Constant32(0x00000001=1)], resolved: None }
a3 00 01 00 00 00 
# 81a11 Instruction { source: "t3 <- t4 Subtract t8", opcode: Add32NoCarryIn, args: [Register(0x6c), Register(0x00), Register(0x6c)], resolved: None }
a0 6c 00 6c 
# 81a15 Instruction { source: "mem[t0] <- t3 U32", opcode: Store32_1, args: [Register(0x6c), Register(0x64)], resolved: None }
92 6c 64 
# 81a18 Instruction { source: "mem[t0] <- t3 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 81a19 Instruction { source: "t16 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x64), Constant32(0x00000004=4)], resolved: None }
80 64 04 00 00 00 
# 81a1f Instruction { source: "t14 <- s Add t16", opcode: Add32NoCarryIn, args: [Register(0x60), Register(0x64), Register(0x64)], resolved: None }
a0 60 64 64 
# 81a23 Instruction { source: "t13 <- mem[t14] U32", opcode: Load32, args: [Register(0x64), Register(0x64)], resolved: None }
90 64 64 
# 81a26 Instruction { source: "t11 <- s Add t13", opcode: Add32NoCarryIn, args: [Register(0x60), Register(0x64), Register(0x60)], resolved: None }
a0 60 64 60 
# 81a2a Instruction { source: "t10 <- mem[t11] U8", opcode: Load8, args: [Register(0x60), Register(0x68)], resolved: None }
10 60 68 
# 81a2d Instruction { source: "return Some(t10)", opcode: Copy8, args: [Register(0x68), Register(0x00)], resolved: None }
16 68 00 
# 81a30 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81a32 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :stack_push
# Ret None
# Arg0=s
# Arg1=n
# Var n (Arg1 n Number(U8)) U8 Some([116])
# Var s (Arg0 s Ptr(Struct("Stack"))) U32 Some([120, 121, 122, 123])
# Var t1 (t1 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Number(U8))), new_type: Number(USIZE), value: Ident("values") }, PtrFieldDeref("s", "first_free")) }) U32 Some([124, 125, 126, 127])
# Var t10 (t10 Number(USIZE, 4)) U32 Some([128, 129, 130, 131])
# Var t11 (t11 Arithmetic(Add, PtrFieldDeref("s", "first_free"), Number(U8, 1))) U32 Some([128, 129, 130, 131])
# Var t12 (t12 PtrFieldDeref("s", "first_free")) U32 Some([128, 129, 130, 131])
# Var t13 (t13 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 4)) }) U32 Some([128, 129, 130, 131])
# Var t15 (t15 Number(USIZE, 4)) U32 Some([128, 129, 130, 131])
# Var t16 (t16 Number(USIZE, 1)) U32 Some([120, 121, 122, 123])
# Var t3 (t3 PtrFieldDeref("s", "first_free")) U32 Some([124, 125, 126, 127])
# Var t4 (t4 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 4)) }) U32 Some([124, 125, 126, 127])
# Var t6 (t6 Number(USIZE, 4)) U32 Some([124, 125, 126, 127])
# Var t8 (t8 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(USIZE)), value: Arithmetic(Add, Cast { old_type: Some(Ptr(Struct("Stack"))), new_type: Number(USIZE), value: Ident("s") }, Number(USIZE, 4)) }) U32 Some([124, 125, 126, 127])
# 81a37 Instruction { source: "Save function parameter 's' registers [0, 1, 2, 3] to locals [120, 121, 122, 123].", opcode: Copy32, args: [Register(0x00), Register(0x78)], resolved: None }
81 00 78 
# 81a3a Instruction { source: "Save function parameter 'n' registers [4] to locals [116].", opcode: Copy8, args: [Register(0x04), Register(0x74)], resolved: None }
16 04 74 
# 81a3d Instruction { source: "t6 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x7c), Constant32(0x00000004=4)], resolved: None }
80 7c 04 00 00 00 
# 81a43 Instruction { source: "t4 <- s Add t6", opcode: Add32NoCarryIn, args: [Register(0x78), Register(0x7c), Register(0x7c)], resolved: None }
a0 78 7c 7c 
# 81a47 Instruction { source: "t3 <- mem[t4] U32", opcode: Load32, args: [Register(0x7c), Register(0x7c)], resolved: None }
90 7c 7c 
# 81a4a Instruction { source: "t1 <- s Add t3", opcode: Add32NoCarryIn, args: [Register(0x78), Register(0x7c), Register(0x7c)], resolved: None }
a0 78 7c 7c 
# 81a4e Instruction { source: "mem[t1] <- n U8", opcode: Store8, args: [Register(0x74), Register(0x7c)], resolved: None }
11 74 7c 
# 81a51 Instruction { source: "t10 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x80), Constant32(0x00000004=4)], resolved: None }
80 80 04 00 00 00 
# 81a57 Instruction { source: "t8 <- s Add t10", opcode: Add32NoCarryIn, args: [Register(0x78), Register(0x80), Register(0x7c)], resolved: None }
a0 78 80 7c 
# 81a5b Instruction { source: "t15 <- 0n4/0x00000004u32 ", opcode: LoadImm32, args: [Register(0x80), Constant32(0x00000004=4)], resolved: None }
80 80 04 00 00 00 
# 81a61 Instruction { source: "t13 <- s Add t15", opcode: Add32NoCarryIn, args: [Register(0x78), Register(0x80), Register(0x80)], resolved: None }
a0 78 80 80 
# 81a65 Instruction { source: "t12 <- mem[t13] U32", opcode: Load32, args: [Register(0x80), Register(0x80)], resolved: None }
90 80 80 
# 81a68 Instruction { source: "t16 <- 0n1/0x00000001u32 ", opcode: LoadImm32, args: [Register(0x78), Constant32(0x00000001=1)], resolved: None }
80 78 01 00 00 00 
# 81a6e Instruction { source: "t11 <- t12 Add t16", opcode: Add32NoCarryIn, args: [Register(0x80), Register(0x78), Register(0x80)], resolved: None }
a0 80 78 80 
# 81a72 Instruction { source: "mem[t8] <- t11 U32", opcode: Store32_1, args: [Register(0x80), Register(0x7c)], resolved: None }
92 80 7c 
# 81a75 Instruction { source: "mem[t8] <- t11 U32", opcode: Store32_2, args: [], resolved: None }
93 
# 81a76 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81a78 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
# :test_echoline
# Ret Some(U8)
# Var __frame_pointer (__frame_pointer) U32 Some([12, 13, 14, 15])
# Var buf (Local buf Array(Number(U8), 20) FrameOffset(0)) FrameOffset(0) None
# Var t0 (t0 Call(Call { function: "readline", parameters: [AddressOf(Index("buf", Number(U8, 0)))] })) U8 Some([132])
# Var t10 (t10 Cast { old_type: Some(Number(U8)), new_type: Number(USIZE), value: Number(U8, 0) }) U32 Some([136, 137, 138, 139])
# Var t11 (t11 Number(U8, 0)) U8 Some([140])
# Var t12 (t12 Number(U8, 0)) U8 Some([132])
# Var t2 (t2 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Ident("__frame_pointer"), Cast { old_type: Some(Number(U8)), new_type: Number(USIZE), value: Number(U8, 0) }) }) U32 Some([136, 137, 138, 139])
# Var t4 (t4 Cast { old_type: Some(Number(U8)), new_type: Number(USIZE), value: Number(U8, 0) }) U32 Some([136, 137, 138, 139])
# Var t5 (t5 Number(U8, 0)) U8 Some([140])
# Var t6 (t6 Call(Call { function: "println", parameters: [AddressOf(Index("buf", Number(U8, 0)))] })) U8 Some([132])
# Var t8 (t8 Cast { old_type: Some(Number(USIZE)), new_type: Ptr(Number(U8)), value: Arithmetic(Add, Ident("__frame_pointer"), Cast { old_type: Some(Number(U8)), new_type: Number(USIZE), value: Number(U8, 0) }) }) U32 Some([144, 145, 146, 147])
# 81a7d Instruction { source: "reserve 20 bytes of stack space for locals", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xffffffec=4294967276)], resolved: None }
a3 0c ec ff ff ff 
# 81a83 Instruction { source: "t5 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x8c), Constant8(0x00=0)], resolved: None }
00 8c 00 
# 81a86 Instruction { source: "Zero-pad for t4 U32 <- t5 U8", opcode: LoadImm32, args: [Register(0x88), Constant32(0x00000000=0)], resolved: None }
80 88 00 00 00 00 
# 81a8c Instruction { source: "t4 U32 <- t5 U8", opcode: Copy8, args: [Register(0x8c), Register(0x88)], resolved: None }
16 8c 88 
# 81a8f Instruction { source: "t2 <- __frame_pointer Add t4", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x88), Register(0x88)], resolved: None }
a0 0c 88 88 
# 81a93 Instruction { source: "Arg0[buf]=t2 None <= call readline(t2,)", opcode: Copy32, args: [Register(0x88), Register(0x00)], resolved: None }
81 88 00 
# Registers used by this function: {132, 136, 137, 138, 139, 140, 144, 145, 146, 147}
# Registers used by callee tree: {16, 17, 18, 76, 77, 78, 79, 80, 81, 84, 85, 86, 87}
# Registers to save: []
# 81a96 Instruction { source: "PseudoCall(Label24(:readline))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81a9c Instruction { source: "PseudoCall(Label24(:readline))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c a6 1a 08 00 
# 81aa2 Instruction { source: "PseudoCall(Label24(:readline))", opcode: JmpImm, args: [Label24(:readline)], resolved: None }
40 4e 19 08 
# 81aa6 Instruction { source: "PseudoCall(Label24(:readline))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81aac Instruction { source: "t11 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x8c), Constant8(0x00=0)], resolved: None }
00 8c 00 
# 81aaf Instruction { source: "Zero-pad for t10 U32 <- t11 U8", opcode: LoadImm32, args: [Register(0x88), Constant32(0x00000000=0)], resolved: None }
80 88 00 00 00 00 
# 81ab5 Instruction { source: "t10 U32 <- t11 U8", opcode: Copy8, args: [Register(0x8c), Register(0x88)], resolved: None }
16 8c 88 
# 81ab8 Instruction { source: "t8 <- __frame_pointer Add t10", opcode: Add32NoCarryIn, args: [Register(0x0c), Register(0x88), Register(0x90)], resolved: None }
a0 0c 88 90 
# 81abc Instruction { source: "Arg0[buf]=t8 None <= call println(t8,)", opcode: Copy32, args: [Register(0x90), Register(0x00)], resolved: None }
81 90 00 
# Registers used by this function: {132, 136, 137, 138, 139, 140, 144, 145, 146, 147}
# Registers used by callee tree: {64, 65, 66, 67, 68, 69, 72, 73, 74, 75}
# Registers to save: []
# 81abf Instruction { source: "PseudoCall(Label24(:println))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0xfffffffc=4294967292)], resolved: None }
a3 0c fc ff ff ff 
# 81ac5 Instruction { source: "PseudoCall(Label24(:println))", opcode: StoreImm32, args: [Register(0x0c), PcOffset(0x0000000a)], resolved: None }
94 0c cf 1a 08 00 
# 81acb Instruction { source: "PseudoCall(Label24(:println))", opcode: JmpImm, args: [Label24(:println)], resolved: None }
40 24 19 08 
# 81acf Instruction { source: "PseudoCall(Label24(:println))", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000004=4)], resolved: None }
a3 0c 04 00 00 00 
# 81ad5 Instruction { source: "t12 <- 0n0/0x00u8 ", opcode: LoadImm8, args: [Register(0x84), Constant8(0x00=0)], resolved: None }
00 84 00 
# 81ad8 Instruction { source: "return Some(t12)", opcode: Copy8, args: [Register(0x84), Register(0x00)], resolved: None }
16 84 00 
# 81adb Instruction { source: "Dealloc 20 bytes from stack", opcode: AddImm32IgnoreCarry, args: [Register(0x0c), Constant32(0x00000014=20)], resolved: None }
a3 0c 14 00 00 00 
# 81ae1 Instruction { source: "PseudoReturn", opcode: JmpMem, args: [Register(0x0c)], resolved: None }
49 0c 
# 81ae3 Instruction { source: "Unreachable", opcode: Halt, args: [Constant32(0x10000000=268435456)], resolved: None }
ff 00 00 00 10 
